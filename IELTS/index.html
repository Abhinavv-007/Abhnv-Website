<!DOCTYPE html>
<html lang="en" class="antialiased">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IELTS ACE</title>
  <script>
    window.process = { env: { NODE_ENV: 'production' } };
    window.global = window;
  </script>
  <script>
    window.onerror = function (msg, url, line, col, error) {
      var div = document.createElement("div");
      div.style.cssText = "position:fixed;top:0;left:0;width:100%;background:red;color:white;z-index:9999;padding:20px;font-family:monospace;white-space:pre-wrap;";
      div.innerText = "Runtime Error:\n" + msg + "\n" + url + ":" + line + ":" + col + "\n" + (error ? error.stack : "");
      document.body.appendChild(div);
    };
    window.addEventListener('unhandledrejection', function (event) {
      var div = document.createElement("div");
      div.style.cssText = "position:fixed;bottom:0;left:0;width:100%;background:orange;color:black;z-index:9999;padding:20px;font-family:monospace;white-space:pre-wrap;";
      div.innerText = "Unhandled Promise Rejection:\n" + event.reason;
      document.body.appendChild(div);
    });
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
          },
          animation: {
            'blob': 'blob 7s infinite',
          },
          keyframes: {
            blob: {
              '0%': { transform: 'translate(0px, 0px) scale(1)' },
              '33%': { transform: 'translate(30px, -50px) scale(1.1)' },
              '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },
              '100%': { transform: 'translate(0px, 0px) scale(1)' },
            }
          }
        }
      }
    }
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    /* Custom scrollbar for cleaner look */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .dark ::-webkit-scrollbar-thumb {
      background: #475569;
    }
  </style>


  <script type="importmap">
{
  "imports": {
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react-router-dom": "https://aistudiocdn.com/react-router-dom@^7.9.6",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "firebase/app": "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js",
    "firebase/analytics": "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js",
    "firebase/auth": "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js"
  }
}
</script>
  <script type="module" crossorigin>var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import { initializeApp, getApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
import { getAuth, GoogleAuthProvider, signInWithPopup, signInAnonymously, linkWithPopup, signOut, onAuthStateChanged } from "firebase/auth";
var require_index_001 = __commonJS({
  "index-CL_YyvLl.js"(exports) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production = {};
    /**
     * @license React
     * react-jsx-runtime.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactJsxRuntime_production;
    function requireReactJsxRuntime_production() {
      if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
      hasRequiredReactJsxRuntime_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_production.jsx = jsxProd;
      reactJsxRuntime_production.jsxs = jsxProd;
      return reactJsxRuntime_production;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var react = { exports: {} };
    var react_production = {};
    /**
     * @license React
     * react.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReact_production;
    function requireReact_production() {
      if (hasRequiredReact_production) return react_production;
      hasRequiredReact_production = 1;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, assign = Object.assign, emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      react_production.Activity = REACT_ACTIVITY_TYPE;
      react_production.Children = Children;
      react_production.Component = Component;
      react_production.Fragment = REACT_FRAGMENT_TYPE;
      react_production.Profiler = REACT_PROFILER_TYPE;
      react_production.PureComponent = PureComponent;
      react_production.StrictMode = REACT_STRICT_MODE_TYPE;
      react_production.Suspense = REACT_SUSPENSE_TYPE;
      react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      react_production.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      react_production.cacheSignal = function() {
        return null;
      };
      react_production.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      react_production.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      react_production.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      react_production.createRef = function() {
        return { current: null };
      };
      react_production.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      react_production.isValidElement = isValidElement;
      react_production.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      react_production.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      react_production.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      react_production.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      react_production.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      react_production.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      react_production.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      react_production.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      react_production.useDebugValue = function() {
      };
      react_production.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      react_production.useEffect = function(create, deps) {
        return ReactSharedInternals.H.useEffect(create, deps);
      };
      react_production.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      react_production.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      react_production.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      react_production.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      react_production.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      react_production.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      react_production.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      react_production.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      react_production.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      react_production.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      react_production.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      react_production.version = "19.2.0";
      return react_production;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production();
      }
      return react.exports;
    }
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    var client = { exports: {} };
    var reactDomClient_production = {};
    var scheduler = { exports: {} };
    var scheduler_production = {};
    /**
     * @license React
     * scheduler.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredScheduler_production;
    function requireScheduler_production() {
      if (hasRequiredScheduler_production) return scheduler_production;
      hasRequiredScheduler_production = 1;
      (function(exports$1) {
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        exports$1.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports$1.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports$1.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
        var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        function shouldYieldToHost() {
          return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
        }
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports$1.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports$1.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        var schedulePerformWorkUntilDeadline;
        if ("function" === typeof localSetImmediate)
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports$1.unstable_now());
          }, ms);
        }
        exports$1.unstable_IdlePriority = 5;
        exports$1.unstable_ImmediatePriority = 1;
        exports$1.unstable_LowPriority = 4;
        exports$1.unstable_NormalPriority = 3;
        exports$1.unstable_Profiling = null;
        exports$1.unstable_UserBlockingPriority = 2;
        exports$1.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports$1.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports$1.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports$1.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports$1.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports$1.unstable_shouldYield = shouldYieldToHost;
        exports$1.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
      })(scheduler_production);
      return scheduler_production;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production();
      }
      return scheduler.exports;
    }
    var reactDom = { exports: {} };
    var reactDom_production = {};
    /**
     * @license React
     * react-dom.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDom_production;
    function requireReactDom_production() {
      if (hasRequiredReactDom_production) return reactDom_production;
      hasRequiredReactDom_production = 1;
      var React2 = requireReact();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      reactDom_production.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      reactDom_production.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      reactDom_production.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      reactDom_production.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      reactDom_production.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      reactDom_production.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      reactDom_production.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      reactDom_production.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      reactDom_production.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      reactDom_production.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      reactDom_production.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      reactDom_production.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      reactDom_production.version = "19.2.0";
      return reactDom_production;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production();
      }
      return reactDom.exports;
    }
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDomClient_production;
    function requireReactDomClient_production() {
      if (hasRequiredReactDomClient_production) return reactDomClient_production;
      hasRequiredReactDomClient_production = 1;
      var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState) return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, valueStack = [], index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var prefix, suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$1) {
                      control = x$1;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$2) {
                    control = x$2;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do
            info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
          entanglements[index$7] = 0;
          expirationTimes[index$7] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$7];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
              var update = hiddenUpdatesForLane[index$7];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
          lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$10 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
        track(element);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$1() {
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null, restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var root = null, startText = null, fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null, activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        var JSCompiler_inline_result$jscomp$286;
        if (canUseDOM) {
          var isSupported$jscomp$inline_427 = "oninput" in document;
          if (!isSupported$jscomp$inline_427) {
            var element$jscomp$inline_428 = document.createElement("div");
            element$jscomp$inline_428.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
          }
          JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
        } else JSCompiler_inline_result$jscomp$286 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
      }
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiberImplClass(18, null, null, 0);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(
          formatProdErrorMessage(
            418,
            1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
            ""
          )
        );
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        globalMostRecentTransitionTime = now();
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          var init = lazyType._init;
          return init(lazyType._payload);
        } catch (x) {
          if (null !== x && "object" === typeof x && "function" === typeof x.then)
            throw suspendedThenable = x, SuspenseException;
          throw x;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var thenableState$1 = null, thenableIndexCounter$1 = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        return trackUsedThenable(thenableState$1, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        thenable = trackUsedThenable(thenableState, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
          subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$66) {
            onActionError(actionQueue, node, error$66);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, deps) {
        tag = { tag, create, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          { destroy: void 0 },
          create,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, deps) {
        mountEffectImpl(8390656, 8, create, deps);
      }
      function updateEffect(create, deps) {
        updateEffectImpl(2048, 8, create, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function updateEvent(callback) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback });
        return function() {
          if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      }
      function noop() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane()
        );
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$69 = enqueueUpdate(provider, fiber, lane);
              null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        },
        useEffectEvent: function(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
      }, HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnRerender.useEffectEvent = updateEvent;
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextProps = workInProgress2.child = current.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current, workInProgress2) {
        null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
        current.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current;
      }
      function updateActivityComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current.memoizedState;
        if (null !== prevState) {
          var dehydrated = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else throw Error(formatProdErrorMessage(558));
          else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
              throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        current = createWorkInProgress(current.child, {
          mode: nextProps.mode,
          children: nextProps.children
        });
        current.ref = workInProgress2.ref;
        workInProgress2.child = current;
        current.return = workInProgress2;
        return current;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            ), nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
            JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
              throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              nextPrimaryChildren.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: showFallback
          }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
        shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
        push(suspenseStackCursor, suspenseContext);
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        nextProps = isHydrating ? treeForkCount : 0;
        if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              nextProps
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              nextProps
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              nextProps
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            var state$102 = workInProgress2.memoizedState;
            if (null !== state$102) {
              if (null !== state$102.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state$102 || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state$102)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state$102) break;
            else return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              var props = workInProgress2.pendingProps;
              current = resolveLazy(workInProgress2.elementType);
              workInProgress2.type = current;
              if ("function" === typeof current)
                shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                ));
              else {
                if (void 0 !== current && null !== current) {
                  var $$typeof = current.$$typeof;
                  if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  } else if ($$typeof === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(current) || current;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
              props,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              props,
              $$typeof,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              props = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              $$typeof = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, props, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              props = nextState.cache;
              pushProvider(workInProgress2, CacheContext, props);
              props !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              props = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if (props !== $$typeof) {
                  $$typeof = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError($$typeof);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    props,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (props === $$typeof) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, props, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if ($$typeof = props = nextHydratableInstance)
                props = canHydrateInstance(
                  props,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
              $$typeof || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            $$typeof = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            props = prevState.children;
            shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = $$typeof);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, props, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              props,
              renderLanes2
            ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
          case 9:
            return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return updateActivityComponent(current, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = 0 !== (workInProgress2.mode & 32)) type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$106 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
        else
          for (child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              nextResource = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2);
              else {
                var ownerDocument = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (nextResource) {
                  case 1:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case 2:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/2000/svg",
                          type
                        );
                        break;
                      case "math":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          type
                        );
                        break;
                      case "script":
                        nextResource = ownerDocument.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                          is: newProps.is
                        }) : ownerDocument.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                  if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                    nextResource.appendChild(ownerDocument.stateNode);
                  else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                    ownerDocument.child.return = ownerDocument;
                    ownerDocument = ownerDocument.child;
                    continue;
                  }
                  if (ownerDocument === workInProgress2) break a;
                  for (; null === ownerDocument.sibling; ) {
                    if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                      break a;
                    ownerDocument = ownerDocument.return;
                  }
                  ownerDocument.sibling.return = ownerDocument.return;
                  ownerDocument = ownerDocument.sibling;
                }
                workInProgress2.stateNode = nextResource;
                a: switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current ? null : current.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2, true);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current) {
                  if (!newProps) throw Error(formatProdErrorMessage(318));
                  current = workInProgress2.memoizedState;
                  current = null !== current ? current.dehydrated : null;
                  if (!current) throw Error(formatProdErrorMessage(557));
                  current[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                current = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
              if (!current) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(formatProdErrorMessage(558));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            newProps = workInProgress2.memoizedState;
            if (null === newProps) return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type) cutOffTailIfNeeded(newProps, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    nextResource = findFirstSuspended(current);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current = nextResource.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current = findFirstSuspended(nextResource), null !== current) {
                  if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
                suspenseStackCursor,
                type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
              ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$140) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$140);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                      anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset
                      );
                      root2 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$139) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$139
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null, hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (18 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      var instance = wasHidden.stateNode;
                      hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$141 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
                var before$142 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
                break;
              case 3:
              case 4:
                var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$144,
                  parent$143
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 31:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || false
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        }
      }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
      function requestUpdateLane() {
        return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                pendingEffectsLanes = lanes;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    "Throttled",
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                null,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          suspendedCommitReason = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$1
          };
          accumulateSuspenseyCommitOnFiber(
            finishedWork,
            lanes,
            suspendedCommitReason
          );
          var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
          timeoutOffset = waitForCommitToBeReady(
            suspendedCommitReason,
            timeoutOffset
          );
          if (null !== timeoutOffset) {
            pendingEffectsLanes = lanes;
            root2.cancelPendingCommit = timeoutOffset(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedCommitReason,
                null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
          didAttemptEntireTree[index$6] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
            lanes |= root2[index$4];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$165) {
            handleThrow(root2, thrownValue$165);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$170 = firstScheduledRoot; null !== root$170; ) {
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$170.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              root$170 = root$170.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
        var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1579,
          "on" + capitalizedEvent$jscomp$inline_1580
        );
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ), nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance = reactEventType;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                        lastHostComponent++;
                      _instance = 0;
                      for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                        _instance++;
                      for (; 0 < lastHostComponent - _instance; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance - lastHostComponent; )
                        instance = inCapturePhase(instance), _instance--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance = inCapturePhase(instance);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$184 = props[hasSrc];
                if (null != propValue$184)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$184;
                      break;
                    case "type":
                      propValue = propValue$184;
                      break;
                    case "checked":
                      checked = propValue$184;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$184;
                      break;
                    case "value":
                      propKey = propValue$184;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$184;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$184)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$184, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$184 in props)
                props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$184,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$201 in nextProps) {
              var propKey = nextProps[propKey$201];
              lastProp = lastProps[propKey$201];
              if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
                switch (propKey$201) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$201 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$201 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$201 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$201 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$201, propKey);
            return;
          case "option":
            for (var propKey$217 in lastProps)
              if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
                switch (propKey$217) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$217,
                      null,
                      nextProps,
                      propKey$201
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$222 in lastProps)
              propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
            for (checked in nextProps)
              if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$201)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$227 in lastProps)
                propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$227,
                  void 0,
                  nextProps,
                  propKey$201
                );
              for (defaultChecked in nextProps)
                propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$201,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$232 in lastProps)
          propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
        for (lastProp in nextProps)
          propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
            var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i += 1; i < resourceEntries.length; i++) {
                var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration) break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count) break;
            }
          }
          if (0 < count) return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      var eventsEnabled = null, selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node || "/&" === node) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
              depth++;
            else if ("html" === node)
              releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
            else if ("head" === node) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node)
              if (0 === suspenseInstance) break;
              else suspenseInstance--;
            else
              "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
        for (; 8 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return "$?" === instance.data || "$~" === instance.data;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$~" === instance.data) instance._reactRetry = callback;
        else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType || "/&" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if ("/$" === data || "/&" === data) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" !== data && "/&" !== data || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$244 = styles$243.get(type);
              resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$244;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$249 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$249)
                return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$249);
              var linkInstance = instance$249;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$249, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$249, props.precedence, hoistableRoot);
              return resource.instance = instance$249;
            case "script":
              instance$249 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$249))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      var estimatedBytesWithinLimit = 0;
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4 + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve) {
                return pendingResolve = resolve;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
            navigation.removeEventListener("navigateerror", handleNavigateComplete);
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
      if ("19.2.0" !== isomorphicReactPackageVersion$jscomp$inline_1840)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1840,
            "19.2.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2347 = {
        bundleType: 0,
        version: "19.2.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2348.inject(
              internals$jscomp$inline_2347
            ), injectedHook = hook$jscomp$inline_2348;
          } catch (err) {
          }
      }
      reactDomClient_production.createRoot = function(container, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      reactDomClient_production.version = "19.2.0";
      return reactDomClient_production;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client.exports;
      hasRequiredClient = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        client.exports = requireReactDomClient_production();
      }
      return client.exports;
    }
    var clientExports = requireClient();
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
    /**
     * react-router v7.9.6
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    var PopStateEventType = "popstate";
    function createHashHistory(options = {}) {
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substring(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          { pathname, search, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to === "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(
          location.pathname.charAt(0) === "/",
          `relative pathnames are not supported in hash history.push(${JSON.stringify(
            to
          )})`
        );
      }
      return getUrlBasedHistory(
        createHashLocation,
        createHashHref,
        validateHashLocation,
        options
      );
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state = null, key) {
      let location = __spreadProps(__spreadValues({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to), {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
      return location;
    }
    function createPath({
      pathname = "/",
      search = "",
      hash = ""
    }) {
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substring(hashIndex);
          path = path.substring(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substring(searchIndex);
          path = path.substring(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
      let { window: window2 = document.defaultView, v5Compat = false } = options;
      let globalHistory = window2.history;
      let action = "POP";
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState(__spreadProps(__spreadValues({}, globalHistory.state), { idx: index }), "");
      }
      function getIndex() {
        let state = globalHistory.state || { idx: null };
        return state.idx;
      }
      function handlePop() {
        action = "POP";
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({ action, location: history.location, delta });
        }
      }
      function push(to, state) {
        action = "PUSH";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 1 });
        }
      }
      function replace2(to, state) {
        action = "REPLACE";
        let location = createLocation(history.location, to, state);
        if (validateLocation) validateLocation(location, to);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 0 });
        }
      }
      function createURL(to) {
        return createBrowserURLImpl(to);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref2(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    function createBrowserURLImpl(to, isAbsolute = false) {
      let base = "http://localhost";
      if (typeof window !== "undefined") {
        base = window.location.origin !== "null" ? window.location.origin : window.location.href;
      }
      invariant(base, "No window.location.(origin|href) available to create URL");
      let href = typeof to === "string" ? to : createPath(to);
      href = href.replace(/ $/, "%20");
      if (!isAbsolute && href.startsWith("//")) {
        href = base + href;
      }
      return new URL(href, base);
    }
    function matchRoutes(routes, locationArg, basename = "/") {
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(
          branches[i],
          decoded,
          allowPartial
        );
      }
      return matches;
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
      let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
            return;
          }
          invariant(
            meta.relativePath.startsWith(parentPath),
            `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
          );
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
          );
          flattenRoutes(
            route.children,
            branches,
            routesMeta,
            path,
            hasParentOptionalSegments
          );
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _a;
        if (route.path === "" || !((_a = route.path) == null ? void 0 : _a.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, true, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(
        ...restExploded.map(
          (subpath) => subpath === "" ? required : [required, subpath].join("/")
        )
      );
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map(
        (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
      );
    }
    function rankRouteBranches(branches) {
      branches.sort(
        (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
          a.routesMeta.map((meta) => meta.childrenIndex),
          b.routesMeta.map((meta) => meta.childrenIndex)
        )
      );
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce(
        (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
        initialScore
      );
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
      let { routesMeta } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath(
          { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
          remainingPathname
        );
        let route = meta.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath(
            {
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end: false
            },
            remainingPathname
          );
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(
            joinPaths([matchedPathname, match.pathnameBase])
          ),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = { path: pattern, caseSensitive: false, end: true };
      }
      let [matcher, compiledParams] = compilePath(
        pattern.path,
        pattern.caseSensitive,
        pattern.end
      );
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce(
        (memo2, { paramName, isOptional }, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index];
          if (isOptional && !value) {
            memo2[paramName] = void 0;
          } else {
            memo2[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo2;
        },
        {}
      );
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive = false, end = true) {
      warning(
        path === "*" || !path.endsWith("*") || path.endsWith("/*"),
        `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
      );
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
        /\/:([\w-]+)(\?)?/g,
        (_, paramName, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
      if (path.endsWith("*")) {
        params.push({ paramName: "*" });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(
          false,
          `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
        );
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function resolvePath(to, fromPathname = "/") {
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname;
      if (toPathname) {
        if (isAbsoluteUrl(toPathname)) {
          pathname = toPathname;
        } else {
          if (toPathname.includes("//")) {
            let oldPathname = toPathname;
            toPathname = toPathname.replace(/\/\/+/g, "/");
            warning(
              false,
              `Pathnames cannot have embedded double slashes - normalizing ${oldPathname} -> ${toPathname}`
            );
          }
          if (toPathname.startsWith("/")) {
            pathname = resolvePathname(toPathname.substring(1), "/");
          } else {
            pathname = resolvePathname(toPathname, fromPathname);
          }
        }
      } else {
        pathname = fromPathname;
      }
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
        path
      )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches) {
      return matches.filter(
        (match, index) => index === 0 || match.route.path && match.route.path.length > 0
      );
    }
    function getResolveToMatches(matches) {
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches.map(
        (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
      );
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = __spreadValues({}, toArg);
        invariant(
          !to.pathname || !to.pathname.includes("?"),
          getInvalidPathError("?", "pathname", "search", to)
        );
        invariant(
          !to.pathname || !to.pathname.includes("#"),
          getInvalidPathError("#", "pathname", "hash", to)
        );
        invariant(
          !to.search || !to.search.includes("#"),
          getInvalidPathError("#", "search", "hash", to)
        );
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    var validMutationMethodsArr = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE"
    ];
    new Set(
      validMutationMethodsArr
    );
    var validRequestMethodsArr = [
      "GET",
      ...validMutationMethodsArr
    ];
    new Set(validRequestMethodsArr);
    var DataRouterContext = reactExports.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = reactExports.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    reactExports.createContext(false);
    var ViewTransitionContext = reactExports.createContext({
      isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = reactExports.createContext(
      /* @__PURE__ */ new Map()
    );
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = reactExports.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = reactExports.createContext(
      null
    );
    NavigationContext.displayName = "Navigation";
    var LocationContext = reactExports.createContext(
      null
    );
    LocationContext.displayName = "Location";
    var RouteContext = reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = reactExports.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    function useHref(to, { relative } = {}) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useHref() may be used only in the context of a <Router> component.`
      );
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { hash, pathname, search } = useResolvedPath(to, { relative });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({ pathname: joinedPathname, search, hash });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useLocation() may be used only in the context of a <Router> component.`
      );
      return reactExports.useContext(LocationContext).location;
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect(cb) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let { isDataRoute } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useNavigate() may be used only in the context of a <Router> component.`
      );
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            navigator2.go(to);
            return;
          }
          let path = resolveTo(
            to,
            JSON.parse(routePathnamesJson),
            locationPathname,
            options.relative === "path"
          );
          if (dataRouterContext == null && basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
          }
          (!!options.replace ? navigator2.replace : navigator2.push)(
            path,
            options.state,
            options
          );
        },
        [
          basename,
          navigator2,
          routePathnamesJson,
          locationPathname,
          dataRouterContext
        ]
      );
      return navigate;
    }
    reactExports.createContext(null);
    function useResolvedPath(to, { relative } = {}) {
      let { matches } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
      return reactExports.useMemo(
        () => resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          relative === "path"
        ),
        [to, routePathnamesJson, locationPathname, relative]
      );
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
      var _a;
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useRoutes() may be used only in the context of a <Router> component.`
      );
      let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches: parentMatches } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      let parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      let parentRoute = routeMatch && routeMatch.route;
      {
        let parentPath = parentRoute && parentRoute.path || "";
        warningOnce(
          parentPathname,
          !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
          `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
        );
      }
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        invariant(
          parentPathnameBase === "/" || ((_a = parsedLocationArg.pathname) == null ? void 0 : _a.startsWith(parentPathnameBase)),
          `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
        );
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches = matchRoutes(routes, { pathname: remainingPathname });
      {
        warning(
          parentRoute || matches != null,
          `No routes matched location "${location.pathname}${location.search}${location.hash}" `
        );
        warning(
          matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
          `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
      }
      let renderedMatches = _renderMatches(
        matches && matches.map(
          (match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes.
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathname
            ]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
              // `new URL()` internally and we need to prevent it from treating
              // them as separators
              navigator2.encodeLocation ? navigator2.encodeLocation(
                match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
              ).pathname : match.pathnameBase
            ])
          })
        ),
        parentMatches,
        dataRouterState,
        unstable_onError,
        future
      );
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(
          LocationContext.Provider,
          {
            value: {
              location: __spreadValues({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
              }, location),
              navigationType: "POP"
              /* Pop */
            }
          },
          renderedMatches
        );
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
      let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
      let devInfo = null;
      {
        console.error(
          "Error handled by React Router default ErrorBoundary:",
          error
        );
        devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
    }
    var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        if (this.props.onError) {
          this.props.onError(error, errorInfo);
        } else {
          console.error(
            "React Router caught the following error during render",
            error
          );
        }
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
          RouteErrorContext.Provider,
          {
            value: this.state.error,
            children: this.props.component
          }
        )) : this.props.children;
      }
    };
    function RenderedRoute({ routeContext, match, children }) {
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
    }
    function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
      if (matches == null) {
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex(
          (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
        );
        invariant(
          errorIndex >= 0,
          `Could not find a matching route for errors on route IDs: ${Object.keys(
            errors
          ).join(",")}`
        );
        renderedMatches = renderedMatches.slice(
          0,
          Math.min(renderedMatches.length, errorIndex + 1)
        );
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let { loaderData, errors: errors2 } = dataRouterState;
            let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      let onError = dataRouterState && unstable_onError ? (error, errorInfo) => {
        var _a, _b, _c;
        unstable_onError(error, {
          location: dataRouterState.location,
          params: (_c = (_b = (_a = dataRouterState.matches) == null ? void 0 : _a[0]) == null ? void 0 : _b.params) != null ? _c : {},
          errorInfo
        });
      } : void 0;
      return renderedMatches.reduceRight(
        (outlet, match, index) => {
          let error;
          let shouldRenderHydrateFallback = false;
          let errorElement = null;
          let hydrateFallbackElement = null;
          if (dataRouterState) {
            error = errors && match.route.id ? errors[match.route.id] : void 0;
            errorElement = match.route.errorElement || defaultErrorElement;
            if (renderFallback) {
              if (fallbackIndex < 0 && index === 0) {
                warningOnce(
                  "route-fallback",
                  false,
                  "No `HydrateFallback` element provided to render during initial hydration"
                );
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = null;
              } else if (fallbackIndex === index) {
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = match.route.hydrateFallbackElement || null;
              }
            }
          }
          let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
          let getChildren = () => {
            let children;
            if (error) {
              children = errorElement;
            } else if (shouldRenderHydrateFallback) {
              children = hydrateFallbackElement;
            } else if (match.route.Component) {
              children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
            } else if (match.route.element) {
              children = match.route.element;
            } else {
              children = outlet;
            }
            return /* @__PURE__ */ reactExports.createElement(
              RenderedRoute,
              {
                match,
                routeContext: {
                  outlet,
                  matches: matches2,
                  isDataRoute: dataRouterState != null
                },
                children
              }
            );
          };
          return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
            RenderErrorBoundary,
            {
              location: dataRouterState.location,
              revalidation: dataRouterState.revalidation,
              component: errorElement,
              error,
              children: getChildren(),
              routeContext: { outlet: null, matches: matches2, isDataRoute: true },
              onError
            }
          ) : getChildren();
        },
        null
      );
    }
    function getDataRouterConsoleError(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError(hookName));
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      invariant(route, getDataRouterConsoleError(hookName));
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext(hookName);
      let thisRoute = route.matches[route.matches.length - 1];
      invariant(
        thisRoute.route.id,
        `${hookName} can only be used on routes that contain a unique "id"`
      );
      return thisRoute.route.id;
    }
    function useRouteId() {
      return useCurrentRouteId(
        "useRouteId"
        /* UseRouteId */
      );
    }
    function useRouteError() {
      var _a;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(
        "useRouteError"
        /* UseRouteError */
      );
      let routeId = useCurrentRouteId(
        "useRouteError"
        /* UseRouteError */
      );
      if (error !== void 0) {
        return error;
      }
      return (_a = state.errors) == null ? void 0 : _a[routeId];
    }
    function useNavigateStable() {
      let { router } = useDataRouterContext(
        "useNavigate"
        /* UseNavigateStable */
      );
      let id = useCurrentRouteId(
        "useNavigate"
        /* UseNavigateStable */
      );
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (to, options = {}) {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            router.navigate(to);
          } else {
            yield router.navigate(to, __spreadValues({ fromRouteId: id }, options));
          }
        }),
        [router, id]
      );
      return navigate;
    }
    var alreadyWarned = {};
    function warningOnce(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
        warning(false, message);
      }
    }
    reactExports.memo(DataRoutes);
    function DataRoutes({
      routes,
      future,
      state,
      unstable_onError
    }) {
      return useRoutesImpl(routes, void 0, state, unstable_onError, future);
    }
    function Route(props) {
      invariant(
        false,
        `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
      );
    }
    function Router({
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = "POP",
      navigator: navigator2,
      static: staticProp = false
    }) {
      invariant(
        !useInRouterContext(),
        `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
      );
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(
        () => ({
          basename,
          navigator: navigator2,
          static: staticProp,
          future: {}
        }),
        [basename, navigator2, staticProp]
      );
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      warning(
        locationContext != null,
        `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
      );
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
    }
    function Routes({
      children,
      location
    }) {
      return useRoutes(createRoutesFromChildren(children), location);
    }
    function createRoutesFromChildren(children, parentPath = []) {
      let routes = [];
      reactExports.Children.forEach(children, (element, index) => {
        if (!reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(
            routes,
            createRoutesFromChildren(element.props.children, treePath)
          );
          return;
        }
        invariant(
          element.type === Route,
          `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
        );
        invariant(
          !element.props.index || !element.props.children,
          "An index route cannot have child routes."
        );
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          middleware: element.props.middleware,
          loader: element.props.loader,
          action: element.props.action,
          hydrateFallbackElement: element.props.hydrateFallbackElement,
          HydrateFallback: element.props.HydrateFallback,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(
            element.props.children,
            treePath
          );
        }
        routes.push(route);
      });
      return routes;
    }
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object) {
      return object != null && typeof object.tagName === "string";
    }
    function isButtonElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
    }
    function isFormElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
    }
    function isInputElement(object) {
      return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
      if (_formDataSupportsSubmitter === null) {
        try {
          new FormData(
            document.createElement("form"),
            // @ts-expect-error if FormData supports the submitter parameter, this will throw
            0
          );
          _formDataSupportsSubmitter = false;
        } catch (e) {
          _formDataSupportsSubmitter = true;
        }
      }
      return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = /* @__PURE__ */ new Set([
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ]);
    function getFormEncType(encType) {
      if (encType != null && !supportedFormEncTypes.has(encType)) {
        warning(
          false,
          `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
        );
        return null;
      }
      return encType;
    }
    function getFormSubmissionInfo(target, basename) {
      let method;
      let action;
      let encType;
      let formData;
      let body;
      if (isFormElement(target)) {
        let attr = target.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(target);
      } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
        let form = target.form;
        if (form == null) {
          throw new Error(
            `Cannot submit a <button> or <input type="submit"> without a <form>`
          );
        }
        let attr = target.getAttribute("formaction") || form.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(form, target);
        if (!isFormDataSubmitterSupported()) {
          let { name, type, value } = target;
          if (type === "image") {
            let prefix = name ? `${name}.` : "";
            formData.append(`${prefix}x`, "0");
            formData.append(`${prefix}y`, "0");
          } else if (name) {
            formData.append(name, value);
          }
        }
      } else if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      } else {
        method = defaultMethod;
        action = null;
        encType = defaultEncType;
        body = target;
      }
      if (formData && encType === "text/plain") {
        body = formData;
        formData = void 0;
      }
      return { action, method: method.toLowerCase(), encType, formData, body };
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function invariant2(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function singleFetchUrl(reqUrl, basename, extension) {
      let url = typeof reqUrl === "string" ? new URL(
        reqUrl,
        // This can be called during the SSR flow via PrefetchPageLinksImpl so
        // don't assume window is available
        typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
      ) : reqUrl;
      if (url.pathname === "/") {
        url.pathname = `_root.${extension}`;
      } else if (basename && stripBasename(url.pathname, basename) === "/") {
        url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
      } else {
        url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
      }
      return url;
    }
    function loadRouteModule(route, routeModulesCache) {
      return __async(this, null, function* () {
        if (route.id in routeModulesCache) {
          return routeModulesCache[route.id];
        }
        try {
          let routeModule = yield import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            route.module
          );
          routeModulesCache[route.id] = routeModule;
          return routeModule;
        } catch (error) {
          console.error(
            `Error loading route module \`${route.module}\`, reloading page...`
          );
          console.error(error);
          if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
          void 0) ;
          window.location.reload();
          return new Promise(() => {
          });
        }
      });
    }
    function isHtmlLinkDescriptor(object) {
      if (object == null) {
        return false;
      }
      if (object.href == null) {
        return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
      }
      return typeof object.rel === "string" && typeof object.href === "string";
    }
    function getKeyedPrefetchLinks(matches, manifest, routeModules) {
      return __async(this, null, function* () {
        let links = yield Promise.all(
          matches.map((match) => __async(null, null, function* () {
            let route = manifest.routes[match.route.id];
            if (route) {
              let mod = yield loadRouteModule(route, routeModules);
              return mod.links ? mod.links() : [];
            }
            return [];
          }))
        );
        return dedupeLinkDescriptors(
          links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
            (link) => link.rel === "stylesheet" ? __spreadProps(__spreadValues({}, link), { rel: "prefetch", as: "style" }) : __spreadProps(__spreadValues({}, link), { rel: "prefetch" })
          )
        );
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let isNew = (match, index) => {
        if (!currentMatches[index]) return true;
        return match.route.id !== currentMatches[index].route.id;
      };
      let matchPathChanged = (match, index) => {
        var _a;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_a = currentMatches[index].route.path) == null ? void 0 : _a.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      if (mode === "assets") {
        return nextMatches.filter(
          (match, index) => isNew(match, index) || matchPathChanged(match, index)
        );
      }
      if (mode === "data") {
        return nextMatches.filter((match, index) => {
          var _a;
          let manifestRoute = manifest.routes[match.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldRevalidate) {
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(
                location.pathname + location.search + location.hash,
                window.origin
              ),
              currentParams: ((_a = currentMatches[0]) == null ? void 0 : _a.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: true
            });
            if (typeof routeChoice === "boolean") {
              return routeChoice;
            }
          }
          return true;
        });
      }
      return [];
    }
    function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
      return dedupeHrefs(
        matches.map((match) => {
          let route = manifest.routes[match.route.id];
          if (!route) return [];
          let hrefs = [route.module];
          if (route.clientActionModule) {
            hrefs = hrefs.concat(route.clientActionModule);
          }
          if (route.clientLoaderModule) {
            hrefs = hrefs.concat(route.clientLoaderModule);
          }
          if (includeHydrateFallback && route.hydrateFallbackModule) {
            hrefs = hrefs.concat(route.hydrateFallbackModule);
          }
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1)
      );
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function sortKeys(obj) {
      let sorted = {};
      let keys = Object.keys(obj).sort();
      for (let key of keys) {
        sorted[key] = obj[key];
      }
      return sorted;
    }
    function dedupeLinkDescriptors(descriptors, preloads) {
      let set = /* @__PURE__ */ new Set();
      new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        let key = JSON.stringify(sortKeys(descriptor));
        if (!set.has(key)) {
          set.add(key);
          deduped.push({ key, link: descriptor });
        }
        return deduped;
      }, []);
    }
    function useDataRouterContext2() {
      let context = reactExports.useContext(DataRouterContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterContext.Provider> element"
      );
      return context;
    }
    function useDataRouterStateContext() {
      let context = reactExports.useContext(DataRouterStateContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterStateContext.Provider> element"
      );
      return context;
    }
    var FrameworkContext = reactExports.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
      let context = reactExports.useContext(FrameworkContext);
      invariant2(
        context,
        "You must render this element inside a <HydratedRouter> element"
      );
      return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let frameworkContext = reactExports.useContext(FrameworkContext);
      let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
      let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
      let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
      let ref = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (prefetch === "render") {
          setShouldPrefetch(true);
        }
        if (prefetch === "viewport") {
          let callback = (entries) => {
            entries.forEach((entry) => {
              setShouldPrefetch(entry.isIntersecting);
            });
          };
          let observer = new IntersectionObserver(callback, { threshold: 0.5 });
          if (ref.current) observer.observe(ref.current);
          return () => {
            observer.disconnect();
          };
        }
      }, [prefetch]);
      reactExports.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(true);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]);
      let setIntent = () => {
        setMaybePrefetch(true);
      };
      let cancelIntent = () => {
        setMaybePrefetch(false);
        setShouldPrefetch(false);
      };
      if (!frameworkContext) {
        return [false, ref, {}];
      }
      if (prefetch !== "intent") {
        return [shouldPrefetch, ref, {}];
      }
      return [
        shouldPrefetch,
        ref,
        {
          onFocus: composeEventHandlers(onFocus, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }
      ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event);
        if (!event.defaultPrevented) {
          ourHandler(event);
        }
      };
    }
    function PrefetchPageLinks(_a) {
      var _b = _a, { page } = _b, linkProps = __objRest(_b, ["page"]);
      let { router } = useDataRouterContext2();
      let matches = reactExports.useMemo(
        () => matchRoutes(router.routes, page, router.basename),
        [router.routes, page, router.basename]
      );
      if (!matches) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, __spreadValues({ page, matches }, linkProps));
    }
    function useKeyedPrefetchLinks(matches) {
      let { manifest, routeModules } = useFrameworkContext();
      let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
      reactExports.useEffect(() => {
        let interrupted = false;
        void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
          (links) => {
            if (!interrupted) {
              setKeyedPrefetchLinks(links);
            }
          }
        );
        return () => {
          interrupted = true;
        };
      }, [matches, manifest, routeModules]);
      return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl(_c) {
      var _d = _c, {
        page,
        matches: nextMatches
      } = _d, linkProps = __objRest(_d, [
        "page",
        "matches"
      ]);
      let location = useLocation();
      let { manifest, routeModules } = useFrameworkContext();
      let { basename } = useDataRouterContext2();
      let { loaderData, matches } = useDataRouterStateContext();
      let newMatchesForData = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "data"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let newMatchesForAssets = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches,
          manifest,
          location,
          "assets"
        ),
        [page, nextMatches, matches, manifest, location]
      );
      let dataHrefs = reactExports.useMemo(() => {
        if (page === location.pathname + location.search + location.hash) {
          return [];
        }
        let routesParams = /* @__PURE__ */ new Set();
        let foundOptOutRoute = false;
        nextMatches.forEach((m) => {
          var _a;
          let manifestRoute = manifest.routes[m.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return;
          }
          if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a = routeModules[m.route.id]) == null ? void 0 : _a.shouldRevalidate)) {
            foundOptOutRoute = true;
          } else if (manifestRoute.hasClientLoader) {
            foundOptOutRoute = true;
          } else {
            routesParams.add(m.route.id);
          }
        });
        if (routesParams.size === 0) {
          return [];
        }
        let url = singleFetchUrl(page, basename, "data");
        if (foundOptOutRoute && routesParams.size > 0) {
          url.searchParams.set(
            "_routes",
            nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
          );
        }
        return [url.pathname + url.search];
      }, [
        basename,
        loaderData,
        location,
        manifest,
        newMatchesForData,
        nextMatches,
        page,
        routeModules
      ]);
      let moduleHrefs = reactExports.useMemo(
        () => getModuleLinkHrefs(newMatchesForAssets, manifest),
        [newMatchesForAssets, manifest]
      );
      let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "prefetch", as: "fetch", href }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "modulepreload", href }, linkProps))), keyedPrefetchLinks.map(({ key, link }) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key, nonce: linkProps.nonce }, link))
      )));
    }
    function mergeRefs(...refs) {
      return (value) => {
        refs.forEach((ref) => {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref != null) {
            ref.current = value;
          }
        });
      };
    }
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
      if (isBrowser) {
        window.__reactRouterVersion = // @ts-expect-error
        "7.9.6";
      }
    } catch (e) {
    }
    function HashRouter({ basename, children, window: window2 }) {
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({ window: window2, v5Compat: true });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let setState = reactExports.useCallback(
        (newState) => {
          reactExports.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = reactExports.forwardRef(
      function LinkWithRef(_e, forwardedRef) {
        var _f = _e, {
          onClick,
          discover = "render",
          prefetch = "none",
          relative,
          reloadDocument,
          replace: replace2,
          state,
          target,
          to,
          preventScrollReset,
          viewTransition
        } = _f, rest = __objRest(_f, [
          "onClick",
          "discover",
          "prefetch",
          "relative",
          "reloadDocument",
          "replace",
          "state",
          "target",
          "to",
          "preventScrollReset",
          "viewTransition"
        ]);
        let { basename } = reactExports.useContext(NavigationContext);
        let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && isAbsolute) {
          absoluteHref = to;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(
                false,
                `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
              );
            }
          }
        }
        let href = useHref(to, { relative });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
          prefetch,
          rest
        );
        let internalOnClick = useLinkClickHandler(to, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition
        });
        function handleClick(event) {
          if (onClick) onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        let link = (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */ reactExports.createElement(
            "a",
            __spreadProps(__spreadValues(__spreadValues({}, rest), prefetchHandlers), {
              href: absoluteHref || href,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: mergeRefs(forwardedRef, prefetchRef),
              target,
              "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            })
          )
        );
        return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
      }
    );
    Link.displayName = "Link";
    var NavLink = reactExports.forwardRef(
      function NavLinkWithRef(_g, ref) {
        var _h = _g, {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = false,
          className: classNameProp = "",
          end = false,
          style: styleProp,
          to,
          viewTransition,
          children
        } = _h, rest = __objRest(_h, [
          "aria-current",
          "caseSensitive",
          "className",
          "end",
          "style",
          "to",
          "viewTransition",
          "children"
        ]);
        let path = useResolvedPath(to, { relative: rest.relative });
        let location = useLocation();
        let routerState = reactExports.useContext(DataRouterStateContext);
        let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
        let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useViewTransitionState(path) && viewTransition === true;
        let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
          nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
          isActive,
          isPending,
          isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp(renderProps);
        } else {
          className = [
            classNameProp,
            isActive ? "active" : null,
            isPending ? "pending" : null,
            isTransitioning ? "transitioning" : null
          ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return /* @__PURE__ */ reactExports.createElement(
          Link,
          __spreadProps(__spreadValues({}, rest), {
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to,
            viewTransition
          }),
          typeof children === "function" ? children(renderProps) : children
        );
      }
    );
    NavLink.displayName = "NavLink";
    var Form = reactExports.forwardRef(
      (_i, forwardedRef) => {
        var _j = _i, {
          discover = "render",
          fetcherKey,
          navigate,
          reloadDocument,
          replace: replace2,
          state,
          method = defaultMethod,
          action,
          onSubmit,
          relative,
          preventScrollReset,
          viewTransition
        } = _j, props = __objRest(_j, [
          "discover",
          "fetcherKey",
          "navigate",
          "reloadDocument",
          "replace",
          "state",
          "method",
          "action",
          "onSubmit",
          "relative",
          "preventScrollReset",
          "viewTransition"
        ]);
        let submit = useSubmit();
        let formAction = useFormAction(action, { relative });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented) return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace2,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
        };
        return /* @__PURE__ */ reactExports.createElement(
          "form",
          __spreadProps(__spreadValues({
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler
          }, props), {
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          })
        );
      }
    );
    Form.displayName = "Form";
    function getDataRouterConsoleError2(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError2(hookName));
      return ctx;
    }
    function useLinkClickHandler(to, {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = {}) {
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to, { relative });
      return reactExports.useCallback(
        (event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
            navigate(to, {
              replace: replace2,
              state,
              preventScrollReset,
              relative,
              viewTransition
            });
          }
        },
        [
          location,
          navigate,
          path,
          replaceProp,
          state,
          target,
          to,
          preventScrollReset,
          relative,
          viewTransition
        ]
      );
    }
    var fetcherId = 0;
    var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
    function useSubmit() {
      let { router } = useDataRouterContext3(
        "useSubmit"
        /* UseSubmit */
      );
      let { basename } = reactExports.useContext(NavigationContext);
      let currentRouteId = useRouteId();
      return reactExports.useCallback(
        (_0, ..._1) => __async(null, [_0, ..._1], function* (target, options = {}) {
          let { action, method, encType, formData, body } = getFormSubmissionInfo(
            target,
            basename
          );
          if (options.navigate === false) {
            let key = options.fetcherKey || getUniqueFetcherId();
            yield router.fetch(key, currentRouteId, options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              flushSync: options.flushSync
            });
          } else {
            yield router.navigate(options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              replace: options.replace,
              state: options.state,
              fromRouteId: currentRouteId,
              flushSync: options.flushSync,
              viewTransition: options.viewTransition
            });
          }
        }),
        [router, basename, currentRouteId]
      );
    }
    function useFormAction(action, { relative } = {}) {
      let { basename } = reactExports.useContext(NavigationContext);
      let routeContext = reactExports.useContext(RouteContext);
      invariant(routeContext, "useFormAction must be used inside a RouteContext");
      let [match] = routeContext.matches.slice(-1);
      let path = __spreadValues({}, useResolvedPath(action ? action : ".", { relative }));
      let location = useLocation();
      if (action == null) {
        path.search = location.search;
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        let hasNakedIndexParam = indexValues.some((v) => v === "");
        if (hasNakedIndexParam) {
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? `?${qs}` : "";
        }
      }
      if ((!action || action === ".") && match.route.index) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      }
      if (basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function useViewTransitionState(to, { relative } = {}) {
      let vtContext = reactExports.useContext(ViewTransitionContext);
      invariant(
        vtContext != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
      );
      let { basename } = useDataRouterContext3(
        "useViewTransitionState"
        /* useViewTransitionState */
      );
      let path = useResolvedPath(to, { relative });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    const toCamelCase = (string) => string.replace(
      /^([A-Z])|[\s-_]+(\w)/g,
      (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
    );
    const toPascalCase = (string) => {
      const camelCase = toCamelCase(string);
      return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
    };
    const mergeClasses = (...classes) => classes.filter((className, index, array) => {
      return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
    }).join(" ").trim();
    const hasA11yProp = (props) => {
      for (const prop in props) {
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
          return true;
        }
      }
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    var defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Icon = reactExports.forwardRef(
      (_k, ref) => {
        var _l = _k, {
          color = "currentColor",
          size = 24,
          strokeWidth = 2,
          absoluteStrokeWidth,
          className = "",
          children,
          iconNode
        } = _l, rest = __objRest(_l, [
          "color",
          "size",
          "strokeWidth",
          "absoluteStrokeWidth",
          "className",
          "children",
          "iconNode"
        ]);
        return reactExports.createElement(
          "svg",
          __spreadValues(__spreadValues(__spreadProps(__spreadValues({
            ref
          }, defaultAttributes), {
            width: size,
            height: size,
            stroke: color,
            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
            className: mergeClasses("lucide", className)
          }), !children && !hasA11yProp(rest) && { "aria-hidden": "true" }), rest),
          [
            ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
            ...Array.isArray(children) ? children : [children]
          ]
        );
      }
    );
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const createLucideIcon = (iconName, iconNode) => {
      const Component = reactExports.forwardRef(
        (_a, ref) => {
          var _b = _a, { className } = _b, props = __objRest(_b, ["className"]);
          return reactExports.createElement(Icon, __spreadValues({
            ref,
            iconNode,
            className: mergeClasses(
              `lucide-${toKebabCase(toPascalCase(iconName))}`,
              `lucide-${iconName}`,
              className
            )
          }, props));
        }
      );
      Component.displayName = toPascalCase(iconName);
      return Component;
    };
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$w = [
      [
        "path",
        {
          d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
          key: "169zse"
        }
      ]
    ];
    const Activity = createLucideIcon("activity", __iconNode$w);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$v = [
      ["path", { d: "M5 12h14", key: "1ays0h" }],
      ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
    ];
    const ArrowRight = createLucideIcon("arrow-right", __iconNode$v);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$u = [
      ["path", { d: "M12 7v14", key: "1akyts" }],
      [
        "path",
        {
          d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",
          key: "ruj8y"
        }
      ]
    ];
    const BookOpen = createLucideIcon("book-open", __iconNode$u);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$t = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]];
    const ChevronRight = createLucideIcon("chevron-right", __iconNode$t);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$s = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
      ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
    ];
    const CircleAlert = createLucideIcon("circle-alert", __iconNode$s);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$r = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "m16 12-4-4-4 4", key: "177agl" }],
      ["path", { d: "M12 16V8", key: "1sbj14" }]
    ];
    const CircleArrowUp = createLucideIcon("circle-arrow-up", __iconNode$r);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$q = [
      ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
      ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
    ];
    const CircleCheckBig = createLucideIcon("circle-check-big", __iconNode$q);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$p = [
      ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
      ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
    ];
    const CircleCheck = createLucideIcon("circle-check", __iconNode$p);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$o = [
      ["path", { d: "M12 20v2", key: "1lh1kg" }],
      ["path", { d: "M12 2v2", key: "tus03m" }],
      ["path", { d: "M17 20v2", key: "1rnc9c" }],
      ["path", { d: "M17 2v2", key: "11trls" }],
      ["path", { d: "M2 12h2", key: "1t8f8n" }],
      ["path", { d: "M2 17h2", key: "7oei6x" }],
      ["path", { d: "M2 7h2", key: "asdhe0" }],
      ["path", { d: "M20 12h2", key: "1q8mjw" }],
      ["path", { d: "M20 17h2", key: "1fpfkl" }],
      ["path", { d: "M20 7h2", key: "1o8tra" }],
      ["path", { d: "M7 20v2", key: "4gnj0m" }],
      ["path", { d: "M7 2v2", key: "1i4yhu" }],
      ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", key: "1vbyd7" }],
      ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1", key: "z9xiuo" }]
    ];
    const Cpu = createLucideIcon("cpu", __iconNode$o);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$n = [
      ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
      ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
      ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
    ];
    const History = createLucideIcon("history", __iconNode$n);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$m = [
      ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4", key: "g0fldk" }],
      ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
      ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }]
    ];
    const Key = createLucideIcon("key", __iconNode$m);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$l = [
      ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
      ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
      ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
      ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]
    ];
    const LayoutDashboard = createLucideIcon("layout-dashboard", __iconNode$l);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$k = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]];
    const LoaderCircle = createLucideIcon("loader-circle", __iconNode$k);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$j = [
      ["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }],
      ["path", { d: "M21 12H9", key: "dn1m92" }],
      ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }]
    ];
    const LogOut = createLucideIcon("log-out", __iconNode$j);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$i = [
      ["path", { d: "M12 19v3", key: "npa21l" }],
      ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
      ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
    ];
    const Mic = createLucideIcon("mic", __iconNode$i);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$h = [
      [
        "path",
        {
          d: "M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401",
          key: "kfwtm"
        }
      ]
    ];
    const Moon = createLucideIcon("moon", __iconNode$h);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$g = [
      [
        "path",
        {
          d: "M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z",
          key: "nt11vn"
        }
      ],
      [
        "path",
        {
          d: "m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18",
          key: "15qc1e"
        }
      ],
      ["path", { d: "m2.3 2.3 7.286 7.286", key: "1wuzzi" }],
      ["circle", { cx: "11", cy: "11", r: "2", key: "xmgehs" }]
    ];
    const PenTool = createLucideIcon("pen-tool", __iconNode$g);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$f = [
      [
        "path",
        {
          d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
          key: "10ikf1"
        }
      ]
    ];
    const Play = createLucideIcon("play", __iconNode$f);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$e = [
      ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
      ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
      ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
      ["path", { d: "M8 16H3v5", key: "1cv678" }]
    ];
    const RefreshCw = createLucideIcon("refresh-cw", __iconNode$e);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$d = [
      ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
      ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
    ];
    const RotateCcw = createLucideIcon("rotate-ccw", __iconNode$d);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$c = [
      [
        "path",
        {
          d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
          key: "1ffxy3"
        }
      ],
      ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
    ];
    const Send = createLucideIcon("send", __iconNode$c);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$b = [
      [
        "path",
        {
          d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
          key: "1s2grr"
        }
      ],
      ["path", { d: "M20 2v4", key: "1rf3ol" }],
      ["path", { d: "M22 4h-4", key: "gwowj6" }],
      ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
    ];
    const Sparkles = createLucideIcon("sparkles", __iconNode$b);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$a = [
      ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
      ["path", { d: "M12 2v2", key: "tus03m" }],
      ["path", { d: "M12 20v2", key: "1lh1kg" }],
      ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
      ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
      ["path", { d: "M2 12h2", key: "1t8f8n" }],
      ["path", { d: "M20 12h2", key: "1q8mjw" }],
      ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
      ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
    ];
    const Sun = createLucideIcon("sun", __iconNode$a);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$9 = [
      ["line", { x1: "10", x2: "14", y1: "2", y2: "2", key: "14vaq8" }],
      ["line", { x1: "12", x2: "15", y1: "14", y2: "11", key: "17fdiu" }],
      ["circle", { cx: "12", cy: "14", r: "8", key: "1e1u0o" }]
    ];
    const Timer = createLucideIcon("timer", __iconNode$9);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$8 = [
      ["path", { d: "M10 11v6", key: "nco0om" }],
      ["path", { d: "M14 11v6", key: "outv1u" }],
      ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
      ["path", { d: "M3 6h18", key: "d0wm0j" }],
      ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
    ];
    const Trash2 = createLucideIcon("trash-2", __iconNode$8);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$7 = [
      [
        "path",
        {
          d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
          key: "wmoenq"
        }
      ],
      ["path", { d: "M12 9v4", key: "juzpu7" }],
      ["path", { d: "M12 17h.01", key: "p32p05" }]
    ];
    const TriangleAlert = createLucideIcon("triangle-alert", __iconNode$7);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$6 = [
      ["path", { d: "M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978", key: "1n3hpd" }],
      ["path", { d: "M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978", key: "rfe1zi" }],
      ["path", { d: "M18 9h1.5a1 1 0 0 0 0-5H18", key: "7xy6bh" }],
      ["path", { d: "M4 22h16", key: "57wxv0" }],
      ["path", { d: "M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z", key: "1mhfuq" }],
      ["path", { d: "M6 9H4.5a1 1 0 0 1 0-5H6", key: "tex48p" }]
    ];
    const Trophy = createLucideIcon("trophy", __iconNode$6);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$5 = [
      ["path", { d: "M12 3v12", key: "1x0j5s" }],
      ["path", { d: "m17 8-5-5-5 5", key: "7q97r8" }],
      ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }]
    ];
    const Upload = createLucideIcon("upload", __iconNode$5);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$4 = [
      ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
      ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
    ];
    const User = createLucideIcon("user", __iconNode$4);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$3 = [
      [
        "path",
        {
          d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
          key: "ftymec"
        }
      ],
      ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
    ];
    const Video = createLucideIcon("video", __iconNode$3);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$2 = [
      [
        "path",
        {
          d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
          key: "uqj9uw"
        }
      ],
      ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
      ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
    ];
    const Volume2 = createLucideIcon("volume-2", __iconNode$2);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode$1 = [
      [
        "path",
        {
          d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72",
          key: "ul74o6"
        }
      ],
      ["path", { d: "m14 7 3 3", key: "1r5n42" }],
      ["path", { d: "M5 6v4", key: "ilb8ba" }],
      ["path", { d: "M19 14v4", key: "blhpug" }],
      ["path", { d: "M10 2v2", key: "7u0qdc" }],
      ["path", { d: "M7 8H3", key: "zfb6yr" }],
      ["path", { d: "M21 16h-4", key: "1cnmox" }],
      ["path", { d: "M11 3H9", key: "1obp7u" }]
    ];
    const WandSparkles = createLucideIcon("wand-sparkles", __iconNode$1);
    /**
     * @license lucide-react v0.554.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const __iconNode = [
      [
        "path",
        {
          d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
          key: "1xq2db"
        }
      ]
    ];
    const Zap = createLucideIcon("zap", __iconNode);
    const logo = "data:image/png;base64,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";
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    let _defaultBaseGeminiUrl = void 0;
    let _defaultBaseVertexUrl = void 0;
    function getDefaultBaseUrls() {
      return {
        geminiUrl: _defaultBaseGeminiUrl,
        vertexUrl: _defaultBaseVertexUrl
      };
    }
    function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
      var _a, _b;
      if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
        const defaultBaseUrls = getDefaultBaseUrls();
        if (vertexai) {
          return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;
        } else {
          return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
        }
      }
      return httpOptions.baseUrl;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BaseModule {
    }
    function formatMap(templateString, valueMap) {
      const regex = /\{([^}]+)\}/g;
      return templateString.replace(regex, (match, key) => {
        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
          const value = valueMap[key];
          return value !== void 0 && value !== null ? String(value) : "";
        } else {
          throw new Error(`Key '${key}' not found in valueMap.`);
        }
      });
    }
    function setValueByPath(data, keys, value) {
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (!(keyName in data)) {
            if (Array.isArray(value)) {
              data[keyName] = Array.from({ length: value.length }, () => ({}));
            } else {
              throw new Error(`Value must be a list given an array path ${key}`);
            }
          }
          if (Array.isArray(data[keyName])) {
            const arrayData = data[keyName];
            if (Array.isArray(value)) {
              for (let j = 0; j < arrayData.length; j++) {
                const entry = arrayData[j];
                setValueByPath(entry, keys.slice(i + 1), value[j]);
              }
            } else {
              for (const d of arrayData) {
                setValueByPath(d, keys.slice(i + 1), value);
              }
            }
          }
          return;
        } else if (key.endsWith("[0]")) {
          const keyName = key.slice(0, -3);
          if (!(keyName in data)) {
            data[keyName] = [{}];
          }
          const arrayData = data[keyName];
          setValueByPath(arrayData[0], keys.slice(i + 1), value);
          return;
        }
        if (!data[key] || typeof data[key] !== "object") {
          data[key] = {};
        }
        data = data[key];
      }
      const keyToSet = keys[keys.length - 1];
      const existingData = data[keyToSet];
      if (existingData !== void 0) {
        if (!value || typeof value === "object" && Object.keys(value).length === 0) {
          return;
        }
        if (value === existingData) {
          return;
        }
        if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
          Object.assign(existingData, value);
        } else {
          throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
        }
      } else {
        if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
          const valueAsRecord = value;
          Object.assign(data, valueAsRecord);
        } else {
          data[keyToSet] = value;
        }
      }
    }
    function getValueByPath(data, keys, defaultValue = void 0) {
      try {
        if (keys.length === 1 && keys[0] === "_self") {
          return data;
        }
        for (let i = 0; i < keys.length; i++) {
          if (typeof data !== "object" || data === null) {
            return defaultValue;
          }
          const key = keys[i];
          if (key.endsWith("[]")) {
            const keyName = key.slice(0, -2);
            if (keyName in data) {
              const arrayData = data[keyName];
              if (!Array.isArray(arrayData)) {
                return defaultValue;
              }
              return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));
            } else {
              return defaultValue;
            }
          } else {
            data = data[key];
          }
        }
        return data;
      } catch (error) {
        if (error instanceof TypeError) {
          return defaultValue;
        }
        throw error;
      }
    }
    function moveValueByPath(data, paths) {
      for (const [sourcePath, destPath] of Object.entries(paths)) {
        const sourceKeys = sourcePath.split(".");
        const destKeys = destPath.split(".");
        const excludeKeys = /* @__PURE__ */ new Set();
        let wildcardIdx = -1;
        for (let i = 0; i < sourceKeys.length; i++) {
          if (sourceKeys[i] === "*") {
            wildcardIdx = i;
            break;
          }
        }
        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
          for (let i = wildcardIdx; i < destKeys.length; i++) {
            const key = destKeys[i];
            if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
              excludeKeys.add(key);
            }
          }
        }
        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
      }
    }
    function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
      if (keyIdx >= sourceKeys.length) {
        return;
      }
      if (typeof data !== "object" || data === null) {
        return;
      }
      const key = sourceKeys[keyIdx];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        const dataRecord = data;
        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
          for (const item of dataRecord[keyName]) {
            _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
          }
        }
      } else if (key === "*") {
        if (typeof data === "object" && data !== null && !Array.isArray(data)) {
          const dataRecord = data;
          const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
          const valuesToMove = {};
          for (const k of keysToMove) {
            valuesToMove[k] = dataRecord[k];
          }
          for (const [k, v] of Object.entries(valuesToMove)) {
            const newDestKeys = [];
            for (const dk of destKeys.slice(keyIdx)) {
              if (dk === "*") {
                newDestKeys.push(k);
              } else {
                newDestKeys.push(dk);
              }
            }
            setValueByPath(dataRecord, newDestKeys, v);
          }
          for (const k of keysToMove) {
            delete dataRecord[k];
          }
        }
      } else {
        const dataRecord = data;
        if (key in dataRecord) {
          _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
        }
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function tBytes$1(fromBytes) {
      if (typeof fromBytes !== "string") {
        throw new Error("fromImageBytes must be a string");
      }
      return fromBytes;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function fetchPredictOperationParametersToVertex(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["operationName"], fromOperationName);
      }
      const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
      if (fromResourceName != null) {
        setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
      }
      return toObject;
    }
    function generateVideosOperationFromMldev$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, [
        "response",
        "generateVideoResponse"
      ]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
      }
      return toObject;
    }
    function generateVideosOperationFromVertex$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
      }
      return toObject;
    }
    function generateVideosResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, [
        "generatedSamples"
      ]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromMldev$1(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosResponseFromVertex$1(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromVertex$1(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generatedVideoFromMldev$1(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
      }
      return toObject;
    }
    function generatedVideoFromVertex$1(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["_self"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
      }
      return toObject;
    }
    function getOperationParametersToMldev(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
      }
      return toObject;
    }
    function getOperationParametersToVertex(fromObject) {
      const toObject = {};
      const fromOperationName = getValueByPath(fromObject, [
        "operationName"
      ]);
      if (fromOperationName != null) {
        setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
      }
      return toObject;
    }
    function importFileOperationFromMldev$1(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
      }
      return toObject;
    }
    function importFileResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function uploadToFileSearchStoreOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function uploadToFileSearchStoreResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function videoFromMldev$1(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["encoding"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoFromVertex$1(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    var Outcome;
    (function(Outcome2) {
      Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
      Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
      Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
      Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
    })(Outcome || (Outcome = {}));
    var Language;
    (function(Language2) {
      Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
      Language2["PYTHON"] = "PYTHON";
    })(Language || (Language = {}));
    var FunctionResponseScheduling;
    (function(FunctionResponseScheduling2) {
      FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
      FunctionResponseScheduling2["SILENT"] = "SILENT";
      FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
      FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
    })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
    var Type;
    (function(Type2) {
      Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
      Type2["STRING"] = "STRING";
      Type2["NUMBER"] = "NUMBER";
      Type2["INTEGER"] = "INTEGER";
      Type2["BOOLEAN"] = "BOOLEAN";
      Type2["ARRAY"] = "ARRAY";
      Type2["OBJECT"] = "OBJECT";
      Type2["NULL"] = "NULL";
    })(Type || (Type = {}));
    var Mode;
    (function(Mode2) {
      Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(Mode || (Mode = {}));
    var ApiSpec;
    (function(ApiSpec2) {
      ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
      ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
      ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
    })(ApiSpec || (ApiSpec = {}));
    var AuthType;
    (function(AuthType2) {
      AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
      AuthType2["NO_AUTH"] = "NO_AUTH";
      AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
      AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
      AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
      AuthType2["OAUTH"] = "OAUTH";
      AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
    })(AuthType || (AuthType = {}));
    var HttpElementLocation;
    (function(HttpElementLocation2) {
      HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
      HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
      HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
      HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
      HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
      HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
    })(HttpElementLocation || (HttpElementLocation = {}));
    var PhishBlockThreshold;
    (function(PhishBlockThreshold2) {
      PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
      PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
      PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
    })(PhishBlockThreshold || (PhishBlockThreshold = {}));
    var ThinkingLevel;
    (function(ThinkingLevel2) {
      ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
      ThinkingLevel2["LOW"] = "LOW";
      ThinkingLevel2["HIGH"] = "HIGH";
    })(ThinkingLevel || (ThinkingLevel = {}));
    var HarmCategory;
    (function(HarmCategory2) {
      HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
      HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
      HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
    })(HarmCategory || (HarmCategory = {}));
    var HarmBlockMethod;
    (function(HarmBlockMethod2) {
      HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
      HarmBlockMethod2["SEVERITY"] = "SEVERITY";
      HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
    })(HarmBlockMethod || (HarmBlockMethod = {}));
    var HarmBlockThreshold;
    (function(HarmBlockThreshold2) {
      HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
      HarmBlockThreshold2["OFF"] = "OFF";
    })(HarmBlockThreshold || (HarmBlockThreshold = {}));
    var FinishReason;
    (function(FinishReason2) {
      FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason2["STOP"] = "STOP";
      FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason2["SAFETY"] = "SAFETY";
      FinishReason2["RECITATION"] = "RECITATION";
      FinishReason2["LANGUAGE"] = "LANGUAGE";
      FinishReason2["OTHER"] = "OTHER";
      FinishReason2["BLOCKLIST"] = "BLOCKLIST";
      FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      FinishReason2["SPII"] = "SPII";
      FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
      FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
      FinishReason2["NO_IMAGE"] = "NO_IMAGE";
    })(FinishReason || (FinishReason = {}));
    var HarmProbability;
    (function(HarmProbability2) {
      HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability2["LOW"] = "LOW";
      HarmProbability2["MEDIUM"] = "MEDIUM";
      HarmProbability2["HIGH"] = "HIGH";
    })(HarmProbability || (HarmProbability = {}));
    var HarmSeverity;
    (function(HarmSeverity2) {
      HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
      HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
      HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
      HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
      HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
    })(HarmSeverity || (HarmSeverity = {}));
    var UrlRetrievalStatus;
    (function(UrlRetrievalStatus2) {
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
      UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
    })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
    var BlockedReason;
    (function(BlockedReason2) {
      BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockedReason2["SAFETY"] = "SAFETY";
      BlockedReason2["OTHER"] = "OTHER";
      BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
      BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
      BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
      BlockedReason2["JAILBREAK"] = "JAILBREAK";
    })(BlockedReason || (BlockedReason = {}));
    var TrafficType;
    (function(TrafficType2) {
      TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
      TrafficType2["ON_DEMAND"] = "ON_DEMAND";
      TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
    })(TrafficType || (TrafficType = {}));
    var Modality;
    (function(Modality2) {
      Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      Modality2["TEXT"] = "TEXT";
      Modality2["IMAGE"] = "IMAGE";
      Modality2["AUDIO"] = "AUDIO";
    })(Modality || (Modality = {}));
    var MediaResolution;
    (function(MediaResolution2) {
      MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
    })(MediaResolution || (MediaResolution = {}));
    var TuningMode;
    (function(TuningMode2) {
      TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
      TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
      TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
    })(TuningMode || (TuningMode = {}));
    var AdapterSize;
    (function(AdapterSize2) {
      AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
      AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
      AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
      AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
      AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
      AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
      AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
    })(AdapterSize || (AdapterSize = {}));
    var JobState;
    (function(JobState2) {
      JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
      JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
      JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
      JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
      JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
      JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
      JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
      JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
      JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
      JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
      JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
      JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
    })(JobState || (JobState = {}));
    var TuningTask;
    (function(TuningTask2) {
      TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
      TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
      TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
      TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
    })(TuningTask || (TuningTask = {}));
    var PartMediaResolutionLevel;
    (function(PartMediaResolutionLevel2) {
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
      PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
    })(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
    var FeatureSelectionPreference;
    (function(FeatureSelectionPreference2) {
      FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
      FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
      FeatureSelectionPreference2["BALANCED"] = "BALANCED";
      FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
    })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
    var Behavior;
    (function(Behavior2) {
      Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
      Behavior2["BLOCKING"] = "BLOCKING";
      Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
    })(Behavior || (Behavior = {}));
    var DynamicRetrievalConfigMode;
    (function(DynamicRetrievalConfigMode2) {
      DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
    var Environment;
    (function(Environment2) {
      Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
      Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
    })(Environment || (Environment = {}));
    var FunctionCallingConfigMode;
    (function(FunctionCallingConfigMode2) {
      FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingConfigMode2["AUTO"] = "AUTO";
      FunctionCallingConfigMode2["ANY"] = "ANY";
      FunctionCallingConfigMode2["NONE"] = "NONE";
      FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
    })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
    var SafetyFilterLevel;
    (function(SafetyFilterLevel2) {
      SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
    })(SafetyFilterLevel || (SafetyFilterLevel = {}));
    var PersonGeneration;
    (function(PersonGeneration2) {
      PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
      PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
      PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
    })(PersonGeneration || (PersonGeneration = {}));
    var ImagePromptLanguage;
    (function(ImagePromptLanguage2) {
      ImagePromptLanguage2["auto"] = "auto";
      ImagePromptLanguage2["en"] = "en";
      ImagePromptLanguage2["ja"] = "ja";
      ImagePromptLanguage2["ko"] = "ko";
      ImagePromptLanguage2["hi"] = "hi";
      ImagePromptLanguage2["zh"] = "zh";
      ImagePromptLanguage2["pt"] = "pt";
      ImagePromptLanguage2["es"] = "es";
    })(ImagePromptLanguage || (ImagePromptLanguage = {}));
    var MaskReferenceMode;
    (function(MaskReferenceMode2) {
      MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
      MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
      MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
      MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
      MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
    })(MaskReferenceMode || (MaskReferenceMode = {}));
    var ControlReferenceType;
    (function(ControlReferenceType2) {
      ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
      ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
      ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
      ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
    })(ControlReferenceType || (ControlReferenceType = {}));
    var SubjectReferenceType;
    (function(SubjectReferenceType2) {
      SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
      SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
      SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
      SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
    })(SubjectReferenceType || (SubjectReferenceType = {}));
    var EditMode;
    (function(EditMode2) {
      EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
      EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
      EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
      EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
      EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
      EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
      EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
      EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
    })(EditMode || (EditMode = {}));
    var SegmentMode;
    (function(SegmentMode2) {
      SegmentMode2["FOREGROUND"] = "FOREGROUND";
      SegmentMode2["BACKGROUND"] = "BACKGROUND";
      SegmentMode2["PROMPT"] = "PROMPT";
      SegmentMode2["SEMANTIC"] = "SEMANTIC";
      SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
    })(SegmentMode || (SegmentMode = {}));
    var VideoGenerationReferenceType;
    (function(VideoGenerationReferenceType2) {
      VideoGenerationReferenceType2["ASSET"] = "ASSET";
      VideoGenerationReferenceType2["STYLE"] = "STYLE";
    })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
    var VideoGenerationMaskMode;
    (function(VideoGenerationMaskMode2) {
      VideoGenerationMaskMode2["INSERT"] = "INSERT";
      VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
      VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
      VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
    })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
    var VideoCompressionQuality;
    (function(VideoCompressionQuality2) {
      VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
      VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
    })(VideoCompressionQuality || (VideoCompressionQuality = {}));
    var TuningMethod;
    (function(TuningMethod2) {
      TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
      TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
    })(TuningMethod || (TuningMethod = {}));
    var DocumentState;
    (function(DocumentState2) {
      DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      DocumentState2["STATE_PENDING"] = "STATE_PENDING";
      DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
      DocumentState2["STATE_FAILED"] = "STATE_FAILED";
    })(DocumentState || (DocumentState = {}));
    var FileState;
    (function(FileState2) {
      FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      FileState2["PROCESSING"] = "PROCESSING";
      FileState2["ACTIVE"] = "ACTIVE";
      FileState2["FAILED"] = "FAILED";
    })(FileState || (FileState = {}));
    var FileSource;
    (function(FileSource2) {
      FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
      FileSource2["UPLOADED"] = "UPLOADED";
      FileSource2["GENERATED"] = "GENERATED";
    })(FileSource || (FileSource = {}));
    var TurnCompleteReason;
    (function(TurnCompleteReason2) {
      TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
      TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
      TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
    })(TurnCompleteReason || (TurnCompleteReason = {}));
    var MediaModality;
    (function(MediaModality2) {
      MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
      MediaModality2["TEXT"] = "TEXT";
      MediaModality2["IMAGE"] = "IMAGE";
      MediaModality2["VIDEO"] = "VIDEO";
      MediaModality2["AUDIO"] = "AUDIO";
      MediaModality2["DOCUMENT"] = "DOCUMENT";
    })(MediaModality || (MediaModality = {}));
    var StartSensitivity;
    (function(StartSensitivity2) {
      StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
      StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
      StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
    })(StartSensitivity || (StartSensitivity = {}));
    var EndSensitivity;
    (function(EndSensitivity2) {
      EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
      EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
      EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
    })(EndSensitivity || (EndSensitivity = {}));
    var ActivityHandling;
    (function(ActivityHandling2) {
      ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
      ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
      ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
    })(ActivityHandling || (ActivityHandling = {}));
    var TurnCoverage;
    (function(TurnCoverage2) {
      TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
      TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
      TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
    })(TurnCoverage || (TurnCoverage = {}));
    var Scale;
    (function(Scale2) {
      Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
      Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
      Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
      Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
      Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
      Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
      Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
      Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
      Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
      Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
      Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
      Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
      Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
    })(Scale || (Scale = {}));
    var MusicGenerationMode;
    (function(MusicGenerationMode2) {
      MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
      MusicGenerationMode2["QUALITY"] = "QUALITY";
      MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
      MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
    })(MusicGenerationMode || (MusicGenerationMode = {}));
    var LiveMusicPlaybackControl;
    (function(LiveMusicPlaybackControl2) {
      LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
      LiveMusicPlaybackControl2["PLAY"] = "PLAY";
      LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
      LiveMusicPlaybackControl2["STOP"] = "STOP";
      LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
    })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
    class HttpResponse {
      constructor(response) {
        const headers = {};
        for (const pair of response.headers.entries()) {
          headers[pair[0]] = pair[1];
        }
        this.headers = headers;
        this.responseInternal = response;
      }
      json() {
        return this.responseInternal.json();
      }
    }
    class GenerateContentResponse {
      /**
       * Returns the concatenation of all text parts from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the text from the first
       * one will be returned.
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       * If there are thought parts in the response, the concatenation of all text
       * parts excluding the thought parts will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'Why is the sky blue?',
       * });
       *
       * console.debug(response.text);
       * ```
       */
      get text() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning text from the first one.");
        }
        let text = "";
        let anyTextPartText = false;
        const nonTextParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartText = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartText ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the first candidate
       * in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the inline data from the
       * first one will be returned. If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning data from the first one.");
        }
        let data = "";
        const nonDataParts = [];
        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
      /**
       * Returns the function calls from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the function calls from
       * the first one will be returned.
       * If there are no function calls in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const controlLightFunctionDeclaration: FunctionDeclaration = {
       *   name: 'controlLight',
       *   parameters: {
       *   type: Type.OBJECT,
       *   description: 'Set the brightness and color temperature of a room light.',
       *   properties: {
       *     brightness: {
       *       type: Type.NUMBER,
       *       description:
       *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
       *     },
       *     colorTemperature: {
       *       type: Type.STRING,
       *       description:
       *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
       *     },
       *   },
       *   required: ['brightness', 'colorTemperature'],
       *  };
       *  const response = await ai.models.generateContent({
       *     model: 'gemini-2.0-flash',
       *     contents: 'Dim the lights so the room feels cozy and warm.',
       *     config: {
       *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
       *       toolConfig: {
       *         functionCallingConfig: {
       *           mode: FunctionCallingConfigMode.ANY,
       *           allowedFunctionNames: ['controlLight'],
       *         },
       *       },
       *     },
       *   });
       *  console.debug(JSON.stringify(response.functionCalls));
       * ```
       */
      get functionCalls() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning function calls from the first one.");
        }
        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
          return void 0;
        }
        return functionCalls;
      }
      /**
       * Returns the first executable code from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the executable code from
       * the first one will be returned.
       * If there are no executable code in the response, undefined will be
       * returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.executableCode);
       * ```
       */
      get executableCode() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning executable code from the first one.");
        }
        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
          return void 0;
        }
        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
      }
      /**
       * Returns the first code execution result from the first candidate in the response.
       *
       * @remarks
       * If there are multiple candidates in the response, the code execution result from
       * the first one will be returned.
       * If there are no code execution result in the response, undefined will be returned.
       *
       * @example
       * ```ts
       * const response = await ai.models.generateContent({
       *   model: 'gemini-2.0-flash',
       *   contents:
       *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
       *   config: {
       *     tools: [{codeExecution: {}}],
       *   },
       * });
       *
       * console.debug(response.codeExecutionResult);
       * ```
       */
      get codeExecutionResult() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
          return void 0;
        }
        if (this.candidates && this.candidates.length > 1) {
          console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
        }
        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
          return void 0;
        }
        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
      }
    }
    class EmbedContentResponse {
    }
    class GenerateImagesResponse {
    }
    class EditImageResponse {
    }
    class UpscaleImageResponse {
    }
    class RecontextImageResponse {
    }
    class SegmentImageResponse {
    }
    class ListModelsResponse {
    }
    class DeleteModelResponse {
    }
    class CountTokensResponse {
    }
    class ComputeTokensResponse {
    }
    class GenerateVideosOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new GenerateVideosOperation();
        let response;
        const op = apiResponse;
        if (_isVertexAI) {
          response = generateVideosOperationFromVertex$1(op);
        } else {
          response = generateVideosOperationFromMldev$1(op);
        }
        Object.assign(operation, response);
        return operation;
      }
    }
    class ListTuningJobsResponse {
    }
    class DeleteCachedContentResponse {
    }
    class ListCachedContentsResponse {
    }
    class ListDocumentsResponse {
    }
    class ListFileSearchStoresResponse {
    }
    class UploadToFileSearchStoreResumableResponse {
    }
    class ImportFileOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new ImportFileOperation();
        const op = apiResponse;
        const response = importFileOperationFromMldev$1(op);
        Object.assign(operation, response);
        return operation;
      }
    }
    class ListFilesResponse {
    }
    class CreateFileResponse {
    }
    class DeleteFileResponse {
    }
    class ListBatchJobsResponse {
    }
    class LiveServerMessage {
      /**
       * Returns the concatenation of all text parts from the server content if present.
       *
       * @remarks
       * If there are non-text parts in the response, the concatenation of all text
       * parts will be returned, and a warning will be logged.
       */
      get text() {
        var _a, _b, _c;
        let text = "";
        let anyTextPartFound = false;
        const nonTextParts = [];
        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
              nonTextParts.push(fieldName);
            }
          }
          if (typeof part.text === "string") {
            if (typeof part.thought === "boolean" && part.thought) {
              continue;
            }
            anyTextPartFound = true;
            text += part.text;
          }
        }
        if (nonTextParts.length > 0) {
          console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
        }
        return anyTextPartFound ? text : void 0;
      }
      /**
       * Returns the concatenation of all inline data parts from the server content if present.
       *
       * @remarks
       * If there are non-inline data parts in the
       * response, the concatenation of all inline data parts will be returned, and
       * a warning will be logged.
       */
      get data() {
        var _a, _b, _c;
        let data = "";
        const nonDataParts = [];
        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
          for (const [fieldName, fieldValue] of Object.entries(part)) {
            if (fieldName !== "inlineData" && fieldValue !== null) {
              nonDataParts.push(fieldName);
            }
          }
          if (part.inlineData && typeof part.inlineData.data === "string") {
            data += atob(part.inlineData.data);
          }
        }
        if (nonDataParts.length > 0) {
          console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
        }
        return data.length > 0 ? btoa(data) : void 0;
      }
    }
    class LiveMusicServerMessage {
      /**
       * Returns the first audio chunk from the server content, if present.
       *
       * @remarks
       * If there are no audio chunks in the response, undefined will be returned.
       */
      get audioChunk() {
        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
          return this.serverContent.audioChunks[0];
        }
        return void 0;
      }
    }
    class UploadToFileSearchStoreOperation {
      /**
       * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
       * @internal
       */
      _fromAPIResponse({ apiResponse, _isVertexAI }) {
        const operation = new UploadToFileSearchStoreOperation();
        const op = apiResponse;
        const response = uploadToFileSearchStoreOperationFromMldev(op);
        Object.assign(operation, response);
        return operation;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function tModel(apiClient, model) {
      if (!model || typeof model !== "string") {
        throw new Error("model is required and must be a string");
      }
      if (model.includes("..") || model.includes("?") || model.includes("&")) {
        throw new Error("invalid model parameter");
      }
      if (apiClient.isVertexAI()) {
        if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
          return model;
        } else if (model.indexOf("/") >= 0) {
          const parts = model.split("/", 2);
          return `publishers/${parts[0]}/models/${parts[1]}`;
        } else {
          return `publishers/google/models/${model}`;
        }
      } else {
        if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
          return model;
        } else {
          return `models/${model}`;
        }
      }
    }
    function tCachesModel(apiClient, model) {
      const transformedModel = tModel(apiClient, model);
      if (!transformedModel) {
        return "";
      }
      if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
      } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
      } else {
        return transformedModel;
      }
    }
    function tBlobs(blobs) {
      if (Array.isArray(blobs)) {
        return blobs.map((blob) => tBlob(blob));
      } else {
        return [tBlob(blobs)];
      }
    }
    function tBlob(blob) {
      if (typeof blob === "object" && blob !== null) {
        return blob;
      }
      throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
    }
    function tImageBlob(blob) {
      const transformedBlob = tBlob(blob);
      if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
        return transformedBlob;
      }
      throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
    }
    function tAudioBlob(blob) {
      const transformedBlob = tBlob(blob);
      if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
        return transformedBlob;
      }
      throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
    }
    function tPart(origin) {
      if (origin === null || origin === void 0) {
        throw new Error("PartUnion is required");
      }
      if (typeof origin === "object") {
        return origin;
      }
      if (typeof origin === "string") {
        return { text: origin };
      }
      throw new Error(`Unsupported part type: ${typeof origin}`);
    }
    function tParts(origin) {
      if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
        throw new Error("PartListUnion is required");
      }
      if (Array.isArray(origin)) {
        return origin.map((item) => tPart(item));
      }
      return [tPart(origin)];
    }
    function _isContent(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
    }
    function _isFunctionCallPart(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
    }
    function _isFunctionResponsePart(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
    }
    function tContent(origin) {
      if (origin === null || origin === void 0) {
        throw new Error("ContentUnion is required");
      }
      if (_isContent(origin)) {
        return origin;
      }
      return {
        role: "user",
        parts: tParts(origin)
      };
    }
    function tContentsForEmbed(apiClient, origin) {
      if (!origin) {
        return [];
      }
      if (apiClient.isVertexAI() && Array.isArray(origin)) {
        return origin.flatMap((item) => {
          const content = tContent(item);
          if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
            return [content.parts[0].text];
          }
          return [];
        });
      } else if (apiClient.isVertexAI()) {
        const content = tContent(origin);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      }
      if (Array.isArray(origin)) {
        return origin.map((item) => tContent(item));
      }
      return [tContent(origin)];
    }
    function tContents(origin) {
      if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
        throw new Error("contents are required");
      }
      if (!Array.isArray(origin)) {
        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
          throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
        }
        return [tContent(origin)];
      }
      const result = [];
      const accumulatedParts = [];
      const isContentArray = _isContent(origin[0]);
      for (const item of origin) {
        const isContent = _isContent(item);
        if (isContent != isContentArray) {
          throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
        }
        if (isContent) {
          result.push(item);
        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
          throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
        } else {
          accumulatedParts.push(item);
        }
      }
      if (!isContentArray) {
        result.push({ role: "user", parts: tParts(accumulatedParts) });
      }
      return result;
    }
    function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
      if (typeList.includes("null")) {
        resultingSchema["nullable"] = true;
      }
      const listWithoutNull = typeList.filter((type) => type !== "null");
      if (listWithoutNull.length === 1) {
        resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else {
        resultingSchema["anyOf"] = [];
        for (const i of listWithoutNull) {
          resultingSchema["anyOf"].push({
            "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
          });
        }
      }
    }
    function processJsonSchema(_jsonSchema) {
      const genAISchema = {};
      const schemaFieldNames = ["items"];
      const listSchemaFieldNames = ["anyOf"];
      const dictSchemaFieldNames = ["properties"];
      if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
        throw new Error("type and anyOf cannot be both populated.");
      }
      const incomingAnyOf = _jsonSchema["anyOf"];
      if (incomingAnyOf != null && incomingAnyOf.length == 2) {
        if (incomingAnyOf[0]["type"] === "null") {
          genAISchema["nullable"] = true;
          _jsonSchema = incomingAnyOf[1];
        } else if (incomingAnyOf[1]["type"] === "null") {
          genAISchema["nullable"] = true;
          _jsonSchema = incomingAnyOf[0];
        }
      }
      if (_jsonSchema["type"] instanceof Array) {
        flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
      }
      for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
        if (fieldValue == null) {
          continue;
        }
        if (fieldName == "type") {
          if (fieldValue === "null") {
            throw new Error("type: null can not be the only possible type for the field.");
          }
          if (fieldValue instanceof Array) {
            continue;
          }
          genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
        } else if (schemaFieldNames.includes(fieldName)) {
          genAISchema[fieldName] = processJsonSchema(fieldValue);
        } else if (listSchemaFieldNames.includes(fieldName)) {
          const listSchemaFieldValue = [];
          for (const item of fieldValue) {
            if (item["type"] == "null") {
              genAISchema["nullable"] = true;
              continue;
            }
            listSchemaFieldValue.push(processJsonSchema(item));
          }
          genAISchema[fieldName] = listSchemaFieldValue;
        } else if (dictSchemaFieldNames.includes(fieldName)) {
          const dictSchemaFieldValue = {};
          for (const [key, value] of Object.entries(fieldValue)) {
            dictSchemaFieldValue[key] = processJsonSchema(value);
          }
          genAISchema[fieldName] = dictSchemaFieldValue;
        } else {
          if (fieldName === "additionalProperties") {
            continue;
          }
          genAISchema[fieldName] = fieldValue;
        }
      }
      return genAISchema;
    }
    function tSchema(schema) {
      return processJsonSchema(schema);
    }
    function tSpeechConfig(speechConfig) {
      if (typeof speechConfig === "object") {
        return speechConfig;
      } else if (typeof speechConfig === "string") {
        return {
          voiceConfig: {
            prebuiltVoiceConfig: {
              voiceName: speechConfig
            }
          }
        };
      } else {
        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
      }
    }
    function tLiveSpeechConfig(speechConfig) {
      if ("multiSpeakerVoiceConfig" in speechConfig) {
        throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
      }
      return speechConfig;
    }
    function tTool(tool) {
      if (tool.functionDeclarations) {
        for (const functionDeclaration of tool.functionDeclarations) {
          if (functionDeclaration.parameters) {
            if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
              functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
            } else {
              if (!functionDeclaration.parametersJsonSchema) {
                functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
                delete functionDeclaration.parameters;
              }
            }
          }
          if (functionDeclaration.response) {
            if (!Object.keys(functionDeclaration.response).includes("$schema")) {
              functionDeclaration.response = processJsonSchema(functionDeclaration.response);
            } else {
              if (!functionDeclaration.responseJsonSchema) {
                functionDeclaration.responseJsonSchema = functionDeclaration.response;
                delete functionDeclaration.response;
              }
            }
          }
        }
      }
      return tool;
    }
    function tTools(tools) {
      if (tools === void 0 || tools === null) {
        throw new Error("tools is required");
      }
      if (!Array.isArray(tools)) {
        throw new Error("tools is required and must be an array of Tools");
      }
      const result = [];
      for (const tool of tools) {
        result.push(tool);
      }
      return result;
    }
    function resourceName(client2, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
      const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
      if (client2.isVertexAI()) {
        if (resourceName2.startsWith("projects/")) {
          return resourceName2;
        } else if (resourceName2.startsWith("locations/")) {
          return `projects/${client2.getProject()}/${resourceName2}`;
        } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
          return `projects/${client2.getProject()}/locations/${client2.getLocation()}/${resourceName2}`;
        } else if (shouldAppendPrefix) {
          return `projects/${client2.getProject()}/locations/${client2.getLocation()}/${resourcePrefix}/${resourceName2}`;
        } else {
          return resourceName2;
        }
      }
      if (shouldAppendPrefix) {
        return `${resourcePrefix}/${resourceName2}`;
      }
      return resourceName2;
    }
    function tCachedContentName(apiClient, name) {
      if (typeof name !== "string") {
        throw new Error("name must be a string");
      }
      return resourceName(apiClient, name, "cachedContents");
    }
    function tTuningJobStatus(status) {
      switch (status) {
        case "STATE_UNSPECIFIED":
          return "JOB_STATE_UNSPECIFIED";
        case "CREATING":
          return "JOB_STATE_RUNNING";
        case "ACTIVE":
          return "JOB_STATE_SUCCEEDED";
        case "FAILED":
          return "JOB_STATE_FAILED";
        default:
          return status;
      }
    }
    function tBytes(fromImageBytes) {
      return tBytes$1(fromImageBytes);
    }
    function _isFile(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
    }
    function isGeneratedVideo(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
    }
    function isVideo(origin) {
      return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
    }
    function tFileName(fromName) {
      var _a;
      let name;
      if (_isFile(fromName)) {
        name = fromName.name;
      }
      if (isVideo(fromName)) {
        name = fromName.uri;
        if (name === void 0) {
          return void 0;
        }
      }
      if (isGeneratedVideo(fromName)) {
        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
        if (name === void 0) {
          return void 0;
        }
      }
      if (typeof fromName === "string") {
        name = fromName;
      }
      if (name === void 0) {
        throw new Error("Could not extract file name from the provided input.");
      }
      if (name.startsWith("https://")) {
        const suffix = name.split("files/")[1];
        const match = suffix.match(/[a-z0-9]+/);
        if (match === null) {
          throw new Error(`Could not extract file name from URI ${name}`);
        }
        name = match[0];
      } else if (name.startsWith("files/")) {
        name = name.split("files/")[1];
      }
      return name;
    }
    function tModelsUrl(apiClient, baseModels) {
      let res;
      if (apiClient.isVertexAI()) {
        res = baseModels ? "publishers/google/models" : "models";
      } else {
        res = baseModels ? "models" : "tunedModels";
      }
      return res;
    }
    function tExtractModels(response) {
      for (const key of ["models", "tunedModels", "publisherModels"]) {
        if (hasField(response, key)) {
          return response[key];
        }
      }
      return [];
    }
    function hasField(data, fieldName) {
      return data !== null && typeof data === "object" && fieldName in data;
    }
    function mcpToGeminiTool(mcpTool, config = {}) {
      const mcpToolSchema = mcpTool;
      const functionDeclaration = {
        name: mcpToolSchema["name"],
        description: mcpToolSchema["description"],
        parametersJsonSchema: mcpToolSchema["inputSchema"]
      };
      if (mcpToolSchema["outputSchema"]) {
        functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
      }
      if (config.behavior) {
        functionDeclaration["behavior"] = config.behavior;
      }
      const geminiTool = {
        functionDeclarations: [
          functionDeclaration
        ]
      };
      return geminiTool;
    }
    function mcpToolsToGeminiTool(mcpTools, config = {}) {
      const functionDeclarations = [];
      const toolNames = /* @__PURE__ */ new Set();
      for (const mcpTool of mcpTools) {
        const mcpToolName = mcpTool.name;
        if (toolNames.has(mcpToolName)) {
          throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
        }
        toolNames.add(mcpToolName);
        const geminiTool = mcpToGeminiTool(mcpTool, config);
        if (geminiTool.functionDeclarations) {
          functionDeclarations.push(...geminiTool.functionDeclarations);
        }
      }
      return { functionDeclarations };
    }
    function tBatchJobSource(client2, src) {
      let sourceObj;
      if (typeof src === "string") {
        if (client2.isVertexAI()) {
          if (src.startsWith("gs://")) {
            sourceObj = { format: "jsonl", gcsUri: [src] };
          } else if (src.startsWith("bq://")) {
            sourceObj = { format: "bigquery", bigqueryUri: src };
          } else {
            throw new Error(`Unsupported string source for Vertex AI: ${src}`);
          }
        } else {
          if (src.startsWith("files/")) {
            sourceObj = { fileName: src };
          } else {
            throw new Error(`Unsupported string source for Gemini API: ${src}`);
          }
        }
      } else if (Array.isArray(src)) {
        if (client2.isVertexAI()) {
          throw new Error("InlinedRequest[] is not supported in Vertex AI.");
        }
        sourceObj = { inlinedRequests: src };
      } else {
        sourceObj = src;
      }
      const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
      const mldevSourcesCount = [
        sourceObj.inlinedRequests,
        sourceObj.fileName
      ].filter(Boolean).length;
      if (client2.isVertexAI()) {
        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
          throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
        }
      } else {
        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
          throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
        }
      }
      return sourceObj;
    }
    function tBatchJobDestination(dest) {
      if (typeof dest !== "string") {
        return dest;
      }
      const destString = dest;
      if (destString.startsWith("gs://")) {
        return {
          format: "jsonl",
          gcsUri: destString
        };
      } else if (destString.startsWith("bq://")) {
        return {
          format: "bigquery",
          bigqueryUri: destString
        };
      } else {
        throw new Error(`Unsupported destination: ${destString}`);
      }
    }
    function tRecvBatchJobDestination(dest) {
      if (typeof dest !== "object" || dest === null) {
        return {};
      }
      const obj = dest;
      const inlineResponsesVal = obj["inlinedResponses"];
      if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
        return dest;
      }
      const inlineResponsesObj = inlineResponsesVal;
      const responsesArray = inlineResponsesObj["inlinedResponses"];
      if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
        return dest;
      }
      let hasEmbedding = false;
      for (const responseItem of responsesArray) {
        if (typeof responseItem !== "object" || responseItem === null) {
          continue;
        }
        const responseItemObj = responseItem;
        const responseVal = responseItemObj["response"];
        if (typeof responseVal !== "object" || responseVal === null) {
          continue;
        }
        const responseObj = responseVal;
        if (responseObj["embedding"] !== void 0) {
          hasEmbedding = true;
          break;
        }
      }
      if (hasEmbedding) {
        obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
        delete obj["inlinedResponses"];
      }
      return dest;
    }
    function tBatchJobName(apiClient, name) {
      const nameString = name;
      if (!apiClient.isVertexAI()) {
        const mldevPattern = /batches\/[^/]+$/;
        if (mldevPattern.test(nameString)) {
          return nameString.split("/").pop();
        } else {
          throw new Error(`Invalid batch job name: ${nameString}.`);
        }
      }
      const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
      if (vertexPattern.test(nameString)) {
        return nameString.split("/").pop();
      } else if (/^\d+$/.test(nameString)) {
        return nameString;
      } else {
        throw new Error(`Invalid batch job name: ${nameString}.`);
      }
    }
    function tJobState(state) {
      const stateString = state;
      if (stateString === "BATCH_STATE_UNSPECIFIED") {
        return "JOB_STATE_UNSPECIFIED";
      } else if (stateString === "BATCH_STATE_PENDING") {
        return "JOB_STATE_PENDING";
      } else if (stateString === "BATCH_STATE_RUNNING") {
        return "JOB_STATE_RUNNING";
      } else if (stateString === "BATCH_STATE_SUCCEEDED") {
        return "JOB_STATE_SUCCEEDED";
      } else if (stateString === "BATCH_STATE_FAILED") {
        return "JOB_STATE_FAILED";
      } else if (stateString === "BATCH_STATE_CANCELLED") {
        return "JOB_STATE_CANCELLED";
      } else if (stateString === "BATCH_STATE_EXPIRED") {
        return "JOB_STATE_EXPIRED";
      } else {
        return stateString;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function batchJobDestinationFromMldev(fromObject) {
      const toObject = {};
      const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromInlinedResponses = getValueByPath(fromObject, [
        "inlinedResponses",
        "inlinedResponses"
      ]);
      if (fromInlinedResponses != null) {
        let transformedList = fromInlinedResponses;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return inlinedResponseFromMldev(item);
          });
        }
        setValueByPath(toObject, ["inlinedResponses"], transformedList);
      }
      const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
        "inlinedEmbedContentResponses",
        "inlinedResponses"
      ]);
      if (fromInlinedEmbedContentResponses != null) {
        let transformedList = fromInlinedEmbedContentResponses;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
      }
      return toObject;
    }
    function batchJobDestinationFromVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["format"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, [
        "gcsDestination",
        "outputUriPrefix"
      ]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, [
        "bigqueryDestination",
        "outputUri"
      ]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
      }
      return toObject;
    }
    function batchJobDestinationToVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["format"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["predictionsFormat"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
      }
      if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
        throw new Error("fileName parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
        throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
        throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function batchJobFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, [
        "metadata",
        "displayName"
      ]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromState = getValueByPath(fromObject, ["metadata", "state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tJobState(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, [
        "metadata",
        "createTime"
      ]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromEndTime = getValueByPath(fromObject, [
        "metadata",
        "endTime"
      ]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, [
        "metadata",
        "updateTime"
      ]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
      if (fromDest != null) {
        setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
      }
      return toObject;
    }
    function batchJobFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tJobState(fromState));
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, ["startTime"]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, ["endTime"]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
      }
      const fromDest = getValueByPath(fromObject, ["outputConfig"]);
      if (fromDest != null) {
        setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
      }
      const fromCompletionStats = getValueByPath(fromObject, [
        "completionStats"
      ]);
      if (fromCompletionStats != null) {
        setValueByPath(toObject, ["completionStats"], fromCompletionStats);
      }
      return toObject;
    }
    function batchJobSourceFromVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["format"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, [
        "bigquerySource",
        "inputUri"
      ]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
      }
      return toObject;
    }
    function batchJobSourceToMldev(apiClient, fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["format"]) !== void 0) {
        throw new Error("format parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
        throw new Error("bigqueryUri parameter is not supported in Gemini API.");
      }
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromInlinedRequests = getValueByPath(fromObject, [
        "inlinedRequests"
      ]);
      if (fromInlinedRequests != null) {
        let transformedList = fromInlinedRequests;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return inlinedRequestToMldev(apiClient, item);
          });
        }
        setValueByPath(toObject, ["requests", "requests"], transformedList);
      }
      return toObject;
    }
    function batchJobSourceToVertex(fromObject) {
      const toObject = {};
      const fromFormat = getValueByPath(fromObject, ["format"]);
      if (fromFormat != null) {
        setValueByPath(toObject, ["instancesFormat"], fromFormat);
      }
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
      }
      const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
      if (fromBigqueryUri != null) {
        setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
      }
      if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
        throw new Error("fileName parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
        throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function blobToMldev$4(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function cancelBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function cancelBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function candidateFromMldev$1(fromObject) {
      const toObject = {};
      const fromContent = getValueByPath(fromObject, ["content"]);
      if (fromContent != null) {
        setValueByPath(toObject, ["content"], fromContent);
      }
      const fromCitationMetadata = getValueByPath(fromObject, [
        "citationMetadata"
      ]);
      if (fromCitationMetadata != null) {
        setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
      }
      const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
      if (fromFinishReason != null) {
        setValueByPath(toObject, ["finishReason"], fromFinishReason);
      }
      const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
      if (fromAvgLogprobs != null) {
        setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
      }
      const fromGroundingMetadata = getValueByPath(fromObject, [
        "groundingMetadata"
      ]);
      if (fromGroundingMetadata != null) {
        setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
      }
      const fromIndex = getValueByPath(fromObject, ["index"]);
      if (fromIndex != null) {
        setValueByPath(toObject, ["index"], fromIndex);
      }
      const fromLogprobsResult = getValueByPath(fromObject, [
        "logprobsResult"
      ]);
      if (fromLogprobsResult != null) {
        setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
      }
      const fromSafetyRatings = getValueByPath(fromObject, [
        "safetyRatings"
      ]);
      if (fromSafetyRatings != null) {
        let transformedList = fromSafetyRatings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["safetyRatings"], transformedList);
      }
      const fromUrlContextMetadata = getValueByPath(fromObject, [
        "urlContextMetadata"
      ]);
      if (fromUrlContextMetadata != null) {
        setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
      }
      return toObject;
    }
    function citationMetadataFromMldev$1(fromObject) {
      const toObject = {};
      const fromCitations = getValueByPath(fromObject, ["citationSources"]);
      if (fromCitations != null) {
        let transformedList = fromCitations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["citations"], transformedList);
      }
      return toObject;
    }
    function contentToMldev$4(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$4(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createBatchJobConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
      }
      if (getValueByPath(fromObject, ["dest"]) !== void 0) {
        throw new Error("dest parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createBatchJobConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDest = getValueByPath(fromObject, ["dest"]);
      if (parentObject !== void 0 && fromDest != null) {
        setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
      }
      return toObject;
    }
    function createBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createBatchJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createBatchJobConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
      }
      return toObject;
    }
    function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSrc = getValueByPath(fromObject, ["src"]);
      if (fromSrc != null) {
        setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteResourceJobFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function deleteResourceJobFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function embedContentBatchToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
        moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
      }
      return toObject;
    }
    function embedContentConfigToMldev$1(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
      }
      if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
        throw new Error("mimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
        throw new Error("autoTruncate parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["file_name"], fromFileName);
      }
      const fromInlinedRequests = getValueByPath(fromObject, [
        "inlinedRequests"
      ]);
      if (fromInlinedRequests != null) {
        setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
      }
      return toObject;
    }
    function fileDataToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$4(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev$2(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
        throw new Error("routingConfig parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
        throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return safetySettingToMldev$1(item);
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$4(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
      }
      if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
        throw new Error("audioTimestamp parameter is not supported in Gemini API.");
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
      }
      return toObject;
    }
    function generateContentResponseFromMldev$1(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return candidateFromMldev$1(item);
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function getBatchJobParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function getBatchJobParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
      }
      return toObject;
    }
    function googleMapsToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$4(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function imageConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
        throw new Error("outputMimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
        throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function inlinedRequestToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$4(item);
          });
        }
        setValueByPath(toObject, ["request", "contents"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
      }
      return toObject;
    }
    function inlinedResponseFromMldev(fromObject) {
      const toObject = {};
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function listBatchJobsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      if (getValueByPath(fromObject, ["filter"]) !== void 0) {
        throw new Error("filter parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function listBatchJobsConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listBatchJobsParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listBatchJobsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listBatchJobsParametersToVertex(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listBatchJobsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listBatchJobsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
      if (fromBatchJobs != null) {
        let transformedList = fromBatchJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return batchJobFromMldev(item);
          });
        }
        setValueByPath(toObject, ["batchJobs"], transformedList);
      }
      return toObject;
    }
    function listBatchJobsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromBatchJobs = getValueByPath(fromObject, [
        "batchPredictionJobs"
      ]);
      if (fromBatchJobs != null) {
        let transformedList = fromBatchJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return batchJobFromVertex(item);
          });
        }
        setValueByPath(toObject, ["batchJobs"], transformedList);
      }
      return toObject;
    }
    function partToMldev$4(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function safetySettingToMldev$1(fromObject) {
      const toObject = {};
      const fromCategory = getValueByPath(fromObject, ["category"]);
      if (fromCategory != null) {
        setValueByPath(toObject, ["category"], fromCategory);
      }
      if (getValueByPath(fromObject, ["method"]) !== void 0) {
        throw new Error("method parameter is not supported in Gemini API.");
      }
      const fromThreshold = getValueByPath(fromObject, ["threshold"]);
      if (fromThreshold != null) {
        setValueByPath(toObject, ["threshold"], fromThreshold);
      }
      return toObject;
    }
    function toolConfigToMldev$2(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$4(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    var PagedItem;
    (function(PagedItem2) {
      PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
      PagedItem2["PAGED_ITEM_MODELS"] = "models";
      PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
      PagedItem2["PAGED_ITEM_FILES"] = "files";
      PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
      PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
      PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
    })(PagedItem || (PagedItem = {}));
    class Pager {
      constructor(name, request, response, params) {
        this.pageInternal = [];
        this.paramsInternal = {};
        this.requestInternal = request;
        this.init(name, response, params);
      }
      init(name, response, params) {
        var _a, _b;
        this.nameInternal = name;
        this.pageInternal = response[this.nameInternal] || [];
        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
        this.idxInternal = 0;
        let requestParams = { config: {} };
        if (!params || Object.keys(params).length === 0) {
          requestParams = { config: {} };
        } else if (typeof params === "object") {
          requestParams = Object.assign({}, params);
        } else {
          requestParams = params;
        }
        if (requestParams["config"]) {
          requestParams["config"]["pageToken"] = response["nextPageToken"];
        }
        this.paramsInternal = requestParams;
        this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
      }
      initNextPage(response) {
        this.init(this.nameInternal, response, this.paramsInternal);
      }
      /**
       * Returns the current page, which is a list of items.
       *
       * @remarks
       * The first page is retrieved when the pager is created. The returned list of
       * items could be a subset of the entire list.
       */
      get page() {
        return this.pageInternal;
      }
      /**
       * Returns the type of paged item (for example, ``batch_jobs``).
       */
      get name() {
        return this.nameInternal;
      }
      /**
       * Returns the length of the page fetched each time by this pager.
       *
       * @remarks
       * The number of items in the page is less than or equal to the page length.
       */
      get pageSize() {
        return this.pageInternalSize;
      }
      /**
       * Returns the headers of the API response.
       */
      get sdkHttpResponse() {
        return this.sdkHttpResponseInternal;
      }
      /**
       * Returns the parameters when making the API request for the next page.
       *
       * @remarks
       * Parameters contain a set of optional configs that can be
       * used to customize the API request. For example, the `pageToken` parameter
       * contains the token to request the next page.
       */
      get params() {
        return this.paramsInternal;
      }
      /**
       * Returns the total number of items in the current page.
       */
      get pageLength() {
        return this.pageInternal.length;
      }
      /**
       * Returns the item at the given index.
       */
      getItem(index) {
        return this.pageInternal[index];
      }
      /**
       * Returns an async iterator that support iterating through all items
       * retrieved from the API.
       *
       * @remarks
       * The iterator will automatically fetch the next page if there are more items
       * to fetch from the API.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * for await (const file of pager) {
       *   console.log(file.name);
       * }
       * ```
       */
      [Symbol.asyncIterator]() {
        return {
          next: () => __async(this, null, function* () {
            if (this.idxInternal >= this.pageLength) {
              if (this.hasNextPage()) {
                yield this.nextPage();
              } else {
                return { value: void 0, done: true };
              }
            }
            const item = this.getItem(this.idxInternal);
            this.idxInternal += 1;
            return { value: item, done: false };
          }),
          return: () => __async(this, null, function* () {
            return { value: void 0, done: true };
          })
        };
      }
      /**
       * Fetches the next page of items. This makes a new API request.
       *
       * @throws {Error} If there are no more pages to fetch.
       *
       * @example
       *
       * ```ts
       * const pager = await ai.files.list({config: {pageSize: 10}});
       * let page = pager.page;
       * while (true) {
       *   for (const file of page) {
       *     console.log(file.name);
       *   }
       *   if (!pager.hasNextPage()) {
       *     break;
       *   }
       *   page = await pager.nextPage();
       * }
       * ```
       */
      nextPage() {
        return __async(this, null, function* () {
          if (!this.hasNextPage()) {
            throw new Error("No more pages to fetch.");
          }
          const response = yield this.requestInternal(this.params);
          this.initNextPage(response);
          return this.page;
        });
      }
      /**
       * Returns true if there are more pages to fetch from the API.
       */
      hasNextPage() {
        var _a;
        if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
          return true;
        }
        return false;
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Batches extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.create = (params) => __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            params.config = this.formatDestination(params.src, params.config);
          }
          return this.createInternal(params);
        });
        this.createEmbeddings = (params) => __async(this, null, function* () {
          console.warn("batches.createEmbeddings() is experimental and may change without notice.");
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support batches.createEmbeddings.");
          }
          return this.createEmbeddingsInternal(params);
        });
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      // Helper function to handle inlined generate content requests
      createInlinedGenerateContentRequest(params) {
        const body = createBatchJobParametersToMldev(
          this.apiClient,
          // Use instance apiClient
          params
        );
        const urlParams = body["_url"];
        const path = formatMap("{model}:batchGenerateContent", urlParams);
        const batch = body["batch"];
        const inputConfig = batch["inputConfig"];
        const requestsWrapper = inputConfig["requests"];
        const requests = requestsWrapper["requests"];
        const newRequests = [];
        for (const request of requests) {
          const requestDict = Object.assign({}, request);
          if (requestDict["systemInstruction"]) {
            const systemInstructionValue = requestDict["systemInstruction"];
            delete requestDict["systemInstruction"];
            const requestContent = requestDict["request"];
            requestContent["systemInstruction"] = systemInstructionValue;
            requestDict["request"] = requestContent;
          }
          newRequests.push(requestDict);
        }
        requestsWrapper["requests"] = newRequests;
        delete body["config"];
        delete body["_url"];
        delete body["_query"];
        return { path, body };
      }
      // Helper function to get the first GCS URI
      getGcsUri(src) {
        if (typeof src === "string") {
          return src.startsWith("gs://") ? src : void 0;
        }
        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
          return src.gcsUri[0];
        }
        return void 0;
      }
      // Helper function to get the BigQuery URI
      getBigqueryUri(src) {
        if (typeof src === "string") {
          return src.startsWith("bq://") ? src : void 0;
        }
        if (!Array.isArray(src)) {
          return src.bigqueryUri;
        }
        return void 0;
      }
      // Function to format the destination configuration for Vertex AI
      formatDestination(src, config) {
        const newConfig = config ? Object.assign({}, config) : {};
        const timestampStr = Date.now().toString();
        if (!newConfig.displayName) {
          newConfig.displayName = `genaiBatchJob_${timestampStr}`;
        }
        if (newConfig.dest === void 0) {
          const gcsUri = this.getGcsUri(src);
          const bigqueryUri = this.getBigqueryUri(src);
          if (gcsUri) {
            if (gcsUri.endsWith(".jsonl")) {
              newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
            } else {
              newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
            }
          } else if (bigqueryUri) {
            newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
          } else {
            throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
          }
        }
        return newConfig;
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      createInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = createBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchGenerateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Internal method to create batch job.
       *
       * @param params - The parameters for create batch job request.
       * @return The created batch job.
       *
       */
      createEmbeddingsInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Gets batch job configurations.
       *
       * @param params - The parameters for the get request.
       * @return The batch job.
       *
       * @example
       * ```ts
       * await ai.batches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Cancels a batch job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      cancel(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listBatchJobsParametersToVertex(params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromVertex(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listBatchJobsParametersToMldev(params);
            path = formatMap("batches", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromMldev(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Deletes a batch job.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.batches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = deleteBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$3(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev$3(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$3(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createCachedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (parentObject !== void 0 && fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$3(item);
          });
        }
        setValueByPath(parentObject, ["contents"], transformedList);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$3(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
        throw new Error("kmsKeyName parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createCachedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (parentObject !== void 0 && fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["contents"], transformedList);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex$2(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
      }
      const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
      if (parentObject !== void 0 && fromKmsKeyName != null) {
        setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
      }
      return toObject;
    }
    function createCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createCachedContentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createCachedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function deleteCachedContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteCachedContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function fileDataToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$3(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function getCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function getCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      return toObject;
    }
    function googleMapsToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$3(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function listCachedContentsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listCachedContentsConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listCachedContentsParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listCachedContentsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listCachedContentsParametersToVertex(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listCachedContentsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listCachedContentsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromCachedContents = getValueByPath(fromObject, [
        "cachedContents"
      ]);
      if (fromCachedContents != null) {
        let transformedList = fromCachedContents;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cachedContents"], transformedList);
      }
      return toObject;
    }
    function listCachedContentsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromCachedContents = getValueByPath(fromObject, [
        "cachedContents"
      ]);
      if (fromCachedContents != null) {
        let transformedList = fromCachedContents;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cachedContents"], transformedList);
      }
      return toObject;
    }
    function partToMldev$3(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function toolConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$3(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex$2(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex$2(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function updateCachedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      return toObject;
    }
    function updateCachedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTtl = getValueByPath(fromObject, ["ttl"]);
      if (parentObject !== void 0 && fromTtl != null) {
        setValueByPath(parentObject, ["ttl"], fromTtl);
      }
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      return toObject;
    }
    function updateCachedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateCachedContentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function updateCachedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateCachedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Caches extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Creates a cached contents resource.
       *
       * @remarks
       * Context caching is only supported for specific models. See [Gemini
       * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
       * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
       * for more information.
       *
       * @param params - The parameters for the create request.
       * @return The created cached content.
       *
       * @example
       * ```ts
       * const contents = ...; // Initialize the content to cache.
       * const response = await ai.caches.create({
       *   model: 'gemini-2.0-flash-001',
       *   config: {
       *    'contents': contents,
       *    'displayName': 'test cache',
       *    'systemInstruction': 'What is the sum of the two pdfs?',
       *    'ttl': '86400s',
       *  }
       * });
       * ```
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = createCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Gets cached content configurations.
       *
       * @param params - The parameters for the get request.
       * @return The cached content.
       *
       * @example
       * ```ts
       * await ai.caches.get({name: '...'}); // The server-generated resource name.
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = getCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes cached content.
       *
       * @param params - The parameters for the delete request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.caches.delete({name: '...'}); // The server-generated resource name.
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromVertex(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromMldev(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Updates cached content configurations.
       *
       * @param params - The parameters for the update request.
       * @return The updated cached content.
       *
       * @example
       * ```ts
       * const response = await ai.caches.update({
       *   name: '...',  // The server-generated resource name.
       *   config: {'ttl': '7600s'}
       * });
       * ```
       */
      update(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = updateCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listCachedContentsParametersToVertex(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromVertex(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listCachedContentsParametersToMldev(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromMldev(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }
    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }
    typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function isValidResponse(response) {
      var _a;
      if (response.candidates == void 0 || response.candidates.length === 0) {
        return false;
      }
      const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
      if (content === void 0) {
        return false;
      }
      return isValidContent(content);
    }
    function isValidContent(content) {
      if (content.parts === void 0 || content.parts.length === 0) {
        return false;
      }
      for (const part of content.parts) {
        if (part === void 0 || Object.keys(part).length === 0) {
          return false;
        }
      }
      return true;
    }
    function validateHistory(history) {
      if (history.length === 0) {
        return;
      }
      for (const content of history) {
        if (content.role !== "user" && content.role !== "model") {
          throw new Error(`Role must be user or model, but got ${content.role}.`);
        }
      }
    }
    function extractCuratedHistory(comprehensiveHistory) {
      if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
        return [];
      }
      const curatedHistory = [];
      const length = comprehensiveHistory.length;
      let i = 0;
      while (i < length) {
        if (comprehensiveHistory[i].role === "user") {
          curatedHistory.push(comprehensiveHistory[i]);
          i++;
        } else {
          const modelOutput = [];
          let isValid = true;
          while (i < length && comprehensiveHistory[i].role === "model") {
            modelOutput.push(comprehensiveHistory[i]);
            if (isValid && !isValidContent(comprehensiveHistory[i])) {
              isValid = false;
            }
            i++;
          }
          if (isValid) {
            curatedHistory.push(...modelOutput);
          } else {
            curatedHistory.pop();
          }
        }
      }
      return curatedHistory;
    }
    class Chats {
      constructor(modelsModule, apiClient) {
        this.modelsModule = modelsModule;
        this.apiClient = apiClient;
      }
      /**
       * Creates a new chat session.
       *
       * @remarks
       * The config in the params will be used for all requests within the chat
       * session unless overridden by a per-request `config` in
       * @see {@link types.SendMessageParameters#config}.
       *
       * @param params - Parameters for creating a chat session.
       * @returns A new chat session.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({
       *   model: 'gemini-2.0-flash'
       *   config: {
       *     temperature: 0.5,
       *     maxOutputTokens: 1024,
       *   }
       * });
       * ```
       */
      create(params) {
        return new Chat(
          this.apiClient,
          this.modelsModule,
          params.model,
          params.config,
          // Deep copy the history to avoid mutating the history outside of the
          // chat session.
          structuredClone(params.history)
        );
      }
    }
    class Chat {
      constructor(apiClient, modelsModule, model, config = {}, history = []) {
        this.apiClient = apiClient;
        this.modelsModule = modelsModule;
        this.model = model;
        this.config = config;
        this.history = history;
        this.sendPromise = Promise.resolve();
        validateHistory(history);
      }
      /**
       * Sends a message to the model and returns the response.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessageStream} for streaming method.
       * @param params - parameters for sending messages within a chat session.
       * @returns The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessage({
       *   message: 'Why is the sky blue?'
       * });
       * console.log(response.text);
       * ```
       */
      sendMessage(params) {
        return __async(this, null, function* () {
          var _a;
          yield this.sendPromise;
          const inputContent = tContent(params.message);
          const responsePromise = this.modelsModule.generateContent({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = (() => __async(this, null, function* () {
            var _a2, _b, _c;
            const response = yield responsePromise;
            const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
            const index = this.getHistory(true).length;
            let automaticFunctionCallingHistory = [];
            if (fullAutomaticFunctionCallingHistory != null) {
              automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
            }
            const modelOutput = outputContent ? [outputContent] : [];
            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
            return;
          }))();
          yield this.sendPromise.catch(() => {
            this.sendPromise = Promise.resolve();
          });
          return responsePromise;
        });
      }
      /**
       * Sends a message to the model and returns the response in chunks.
       *
       * @remarks
       * This method will wait for the previous message to be processed before
       * sending the next message.
       *
       * @see {@link Chat#sendMessage} for non-streaming method.
       * @param params - parameters for sending the message.
       * @return The model's response.
       *
       * @example
       * ```ts
       * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
       * const response = await chat.sendMessageStream({
       *   message: 'Why is the sky blue?'
       * });
       * for await (const chunk of response) {
       *   console.log(chunk.text);
       * }
       * ```
       */
      sendMessageStream(params) {
        return __async(this, null, function* () {
          var _a;
          yield this.sendPromise;
          const inputContent = tContent(params.message);
          const streamResponse = this.modelsModule.generateContentStream({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
          const response = yield streamResponse;
          const result = this.processStreamResponse(response, inputContent);
          return result;
        });
      }
      /**
       * Returns the chat history.
       *
       * @remarks
       * The history is a list of contents alternating between user and model.
       *
       * There are two types of history:
       * - The `curated history` contains only the valid turns between user and
       * model, which will be included in the subsequent requests sent to the model.
       * - The `comprehensive history` contains all turns, including invalid or
       *   empty model outputs, providing a complete record of the history.
       *
       * The history is updated after receiving the response from the model,
       * for streaming response, it means receiving the last chunk of the response.
       *
       * The `comprehensive history` is returned by default. To get the `curated
       * history`, set the `curated` parameter to `true`.
       *
       * @param curated - whether to return the curated history or the comprehensive
       *     history.
       * @return History contents alternating between user and model for the entire
       *     chat session.
       */
      getHistory(curated = false) {
        const history = curated ? extractCuratedHistory(this.history) : this.history;
        return structuredClone(history);
      }
      processStreamResponse(streamResponse, inputContent) {
        var _a, _b;
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          var _c, e_1, _d, _e;
          const outputContent = [];
          try {
            for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
              _e = streamResponse_1_1.value;
              _f = false;
              const chunk = _e;
              if (isValidResponse(chunk)) {
                const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
                if (content !== void 0) {
                  outputContent.push(content);
                }
              }
              yield yield __await(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          this.recordHistory(inputContent, outputContent);
        });
      }
      recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
        let outputContents = [];
        if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
          outputContents = modelOutput;
        } else {
          outputContents.push({
            role: "model",
            parts: []
          });
        }
        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
          this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
        } else {
          this.history.push(userInput);
        }
        this.history.push(...outputContents);
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class ApiError extends Error {
      constructor(options) {
        super(options.message);
        this.name = "ApiError";
        this.status = options.status;
        Object.setPrototypeOf(this, ApiError.prototype);
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function createFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromFile = getValueByPath(fromObject, ["file"]);
      if (fromFile != null) {
        setValueByPath(toObject, ["file"], fromFile);
      }
      return toObject;
    }
    function createFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
      }
      return toObject;
    }
    function deleteFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function getFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
      }
      return toObject;
    }
    function listFilesConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listFilesParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listFilesConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listFilesResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromFiles = getValueByPath(fromObject, ["files"]);
      if (fromFiles != null) {
        let transformedList = fromFiles;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["files"], transformedList);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Files extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Uploads a file asynchronously to the Gemini API.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       * Somex eamples for file extension to mimeType mapping:
       * .txt -> text/plain
       * .json -> application/json
       * .jpg  -> image/jpeg
       * .png -> image/png
       * .mp3 -> audio/mpeg
       * .mp4 -> video/mp4
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadFileParameters` interface.
       *         @see {@link types.UploadFileParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a `types.File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to Gemini API.
       *
       * ```ts
       * const file = await ai.files.upload({file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(file.name);
       * ```
       */
      upload(params) {
        return __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
          }
          return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
            return resp;
          });
        });
      }
      /**
       * Downloads a remotely stored file asynchronously to a location specified in
       * the `params` object. This method only works on Node environment, to
       * download files in the browser, use a browser compliant method like an <a>
       * tag.
       *
       * @param params - The parameters for the download request.
       *
       * @example
       * The following code downloads an example file named "files/mehozpxf877d" as
       * "file.txt".
       *
       * ```ts
       * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
       * ```
       */
      download(params) {
        return __async(this, null, function* () {
          yield this.apiClient.downloadFile(params);
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFilesParametersToMldev(params);
            path = formatMap("files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listFilesResponseFromMldev(apiResponse);
              const typedResp = new ListFilesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      createInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileParametersToMldev(params);
            path = formatMap("upload/v1beta/files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = createFileResponseFromMldev(apiResponse);
              const typedResp = new CreateFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Retrieves the file information from the service.
       *
       * @param params - The parameters for the get request
       * @return The Promise that resolves to the types.File object requested.
       *
       * @example
       * ```ts
       * const config: GetFileParameters = {
       *   name: fileName,
       * };
       * file = await ai.files.get(config);
       * console.log(file.name);
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a remotely stored file.
       *
       * @param params - The parameters for the delete request.
       * @return The DeleteFileResponse, the response for the delete method.
       *
       * @example
       * The following code deletes an example file named "files/mehozpxf877d".
       *
       * ```ts
       * await ai.files.delete({name: file.name});
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteFileResponseFromMldev(apiResponse);
              const typedResp = new DeleteFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$2(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev$2(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$2(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function fileDataToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$2(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function generationConfigToVertex$1(fromObject) {
      const toObject = {};
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (fromEnableAffectiveDialog != null) {
        setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex$1(fromSpeechConfig));
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
        throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function googleMapsToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$2(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function liveConnectConfigToMldev$1(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$2(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex$1(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
      }
      return toObject;
    }
    function liveConnectParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
      }
      return toObject;
    }
    function liveMusicSetConfigParametersToMldev(fromObject) {
      const toObject = {};
      const fromMusicGenerationConfig = getValueByPath(fromObject, [
        "musicGenerationConfig"
      ]);
      if (fromMusicGenerationConfig != null) {
        setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
      }
      return toObject;
    }
    function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
      const toObject = {};
      const fromWeightedPrompts = getValueByPath(fromObject, [
        "weightedPrompts"
      ]);
      if (fromWeightedPrompts != null) {
        let transformedList = fromWeightedPrompts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["weightedPrompts"], transformedList);
      }
      return toObject;
    }
    function liveSendRealtimeInputParametersToMldev(fromObject) {
      const toObject = {};
      const fromMedia = getValueByPath(fromObject, ["media"]);
      if (fromMedia != null) {
        let transformedList = tBlobs(fromMedia);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return blobToMldev$2(item);
          });
        }
        setValueByPath(toObject, ["mediaChunks"], transformedList);
      }
      const fromAudio = getValueByPath(fromObject, ["audio"]);
      if (fromAudio != null) {
        setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
      }
      const fromAudioStreamEnd = getValueByPath(fromObject, [
        "audioStreamEnd"
      ]);
      if (fromAudioStreamEnd != null) {
        setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromActivityStart = getValueByPath(fromObject, [
        "activityStart"
      ]);
      if (fromActivityStart != null) {
        setValueByPath(toObject, ["activityStart"], fromActivityStart);
      }
      const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
      if (fromActivityEnd != null) {
        setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
      }
      return toObject;
    }
    function liveSendRealtimeInputParametersToVertex(fromObject) {
      const toObject = {};
      const fromMedia = getValueByPath(fromObject, ["media"]);
      if (fromMedia != null) {
        let transformedList = tBlobs(fromMedia);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["mediaChunks"], transformedList);
      }
      const fromAudio = getValueByPath(fromObject, ["audio"]);
      if (fromAudio != null) {
        setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
      }
      const fromAudioStreamEnd = getValueByPath(fromObject, [
        "audioStreamEnd"
      ]);
      if (fromAudioStreamEnd != null) {
        setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromActivityStart = getValueByPath(fromObject, [
        "activityStart"
      ]);
      if (fromActivityStart != null) {
        setValueByPath(toObject, ["activityStart"], fromActivityStart);
      }
      const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
      if (fromActivityEnd != null) {
        setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
      }
      return toObject;
    }
    function liveServerMessageFromVertex(fromObject) {
      const toObject = {};
      const fromSetupComplete = getValueByPath(fromObject, [
        "setupComplete"
      ]);
      if (fromSetupComplete != null) {
        setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
      }
      const fromServerContent = getValueByPath(fromObject, [
        "serverContent"
      ]);
      if (fromServerContent != null) {
        setValueByPath(toObject, ["serverContent"], fromServerContent);
      }
      const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
      if (fromToolCall != null) {
        setValueByPath(toObject, ["toolCall"], fromToolCall);
      }
      const fromToolCallCancellation = getValueByPath(fromObject, [
        "toolCallCancellation"
      ]);
      if (fromToolCallCancellation != null) {
        setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
      }
      const fromGoAway = getValueByPath(fromObject, ["goAway"]);
      if (fromGoAway != null) {
        setValueByPath(toObject, ["goAway"], fromGoAway);
      }
      const fromSessionResumptionUpdate = getValueByPath(fromObject, [
        "sessionResumptionUpdate"
      ]);
      if (fromSessionResumptionUpdate != null) {
        setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
      }
      return toObject;
    }
    function partToMldev$2(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function sessionResumptionConfigToMldev$1(fromObject) {
      const toObject = {};
      const fromHandle = getValueByPath(fromObject, ["handle"]);
      if (fromHandle != null) {
        setValueByPath(toObject, ["handle"], fromHandle);
      }
      if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
        throw new Error("transparent parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function speechConfigToVertex$1(fromObject) {
      const toObject = {};
      const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
      if (fromLanguageCode != null) {
        setValueByPath(toObject, ["languageCode"], fromLanguageCode);
      }
      const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
      if (fromVoiceConfig != null) {
        setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
      }
      if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
        throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function toolToMldev$2(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex$1(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex$1(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function usageMetadataFromVertex(fromObject) {
      const toObject = {};
      const fromPromptTokenCount = getValueByPath(fromObject, [
        "promptTokenCount"
      ]);
      if (fromPromptTokenCount != null) {
        setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
      }
      const fromCachedContentTokenCount = getValueByPath(fromObject, [
        "cachedContentTokenCount"
      ]);
      if (fromCachedContentTokenCount != null) {
        setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
      }
      const fromResponseTokenCount = getValueByPath(fromObject, [
        "candidatesTokenCount"
      ]);
      if (fromResponseTokenCount != null) {
        setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
      }
      const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
        "toolUsePromptTokenCount"
      ]);
      if (fromToolUsePromptTokenCount != null) {
        setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
      }
      const fromThoughtsTokenCount = getValueByPath(fromObject, [
        "thoughtsTokenCount"
      ]);
      if (fromThoughtsTokenCount != null) {
        setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
      }
      const fromTotalTokenCount = getValueByPath(fromObject, [
        "totalTokenCount"
      ]);
      if (fromTotalTokenCount != null) {
        setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
      }
      const fromPromptTokensDetails = getValueByPath(fromObject, [
        "promptTokensDetails"
      ]);
      if (fromPromptTokensDetails != null) {
        let transformedList = fromPromptTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["promptTokensDetails"], transformedList);
      }
      const fromCacheTokensDetails = getValueByPath(fromObject, [
        "cacheTokensDetails"
      ]);
      if (fromCacheTokensDetails != null) {
        let transformedList = fromCacheTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
      }
      const fromResponseTokensDetails = getValueByPath(fromObject, [
        "candidatesTokensDetails"
      ]);
      if (fromResponseTokensDetails != null) {
        let transformedList = fromResponseTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["responseTokensDetails"], transformedList);
      }
      const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
        "toolUsePromptTokensDetails"
      ]);
      if (fromToolUsePromptTokensDetails != null) {
        let transformedList = fromToolUsePromptTokensDetails;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
      }
      const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
      if (fromTrafficType != null) {
        setValueByPath(toObject, ["trafficType"], fromTrafficType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev$1(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function candidateFromMldev(fromObject) {
      const toObject = {};
      const fromContent = getValueByPath(fromObject, ["content"]);
      if (fromContent != null) {
        setValueByPath(toObject, ["content"], fromContent);
      }
      const fromCitationMetadata = getValueByPath(fromObject, [
        "citationMetadata"
      ]);
      if (fromCitationMetadata != null) {
        setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
      }
      const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
      if (fromFinishReason != null) {
        setValueByPath(toObject, ["finishReason"], fromFinishReason);
      }
      const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
      if (fromAvgLogprobs != null) {
        setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
      }
      const fromGroundingMetadata = getValueByPath(fromObject, [
        "groundingMetadata"
      ]);
      if (fromGroundingMetadata != null) {
        setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
      }
      const fromIndex = getValueByPath(fromObject, ["index"]);
      if (fromIndex != null) {
        setValueByPath(toObject, ["index"], fromIndex);
      }
      const fromLogprobsResult = getValueByPath(fromObject, [
        "logprobsResult"
      ]);
      if (fromLogprobsResult != null) {
        setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
      }
      const fromSafetyRatings = getValueByPath(fromObject, [
        "safetyRatings"
      ]);
      if (fromSafetyRatings != null) {
        let transformedList = fromSafetyRatings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["safetyRatings"], transformedList);
      }
      const fromUrlContextMetadata = getValueByPath(fromObject, [
        "urlContextMetadata"
      ]);
      if (fromUrlContextMetadata != null) {
        setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
      }
      return toObject;
    }
    function citationMetadataFromMldev(fromObject) {
      const toObject = {};
      const fromCitations = getValueByPath(fromObject, ["citationSources"]);
      if (fromCitations != null) {
        let transformedList = fromCitations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["citations"], transformedList);
      }
      return toObject;
    }
    function computeTokensParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      return toObject;
    }
    function computeTokensResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
      if (fromTokensInfo != null) {
        let transformedList = fromTokensInfo;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["tokensInfo"], transformedList);
      }
      return toObject;
    }
    function contentEmbeddingFromVertex(fromObject) {
      const toObject = {};
      const fromValues = getValueByPath(fromObject, ["values"]);
      if (fromValues != null) {
        setValueByPath(toObject, ["values"], fromValues);
      }
      const fromStatistics = getValueByPath(fromObject, ["statistics"]);
      if (fromStatistics != null) {
        setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
      }
      return toObject;
    }
    function contentEmbeddingStatisticsFromVertex(fromObject) {
      const toObject = {};
      const fromTruncated = getValueByPath(fromObject, ["truncated"]);
      if (fromTruncated != null) {
        setValueByPath(toObject, ["truncated"], fromTruncated);
      }
      const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
      if (fromTokenCount != null) {
        setValueByPath(toObject, ["tokenCount"], fromTokenCount);
      }
      return toObject;
    }
    function contentToMldev$1(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function controlReferenceConfigToVertex(fromObject) {
      const toObject = {};
      const fromControlType = getValueByPath(fromObject, ["controlType"]);
      if (fromControlType != null) {
        setValueByPath(toObject, ["controlType"], fromControlType);
      }
      const fromEnableControlImageComputation = getValueByPath(fromObject, [
        "enableControlImageComputation"
      ]);
      if (fromEnableControlImageComputation != null) {
        setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
      }
      return toObject;
    }
    function countTokensConfigToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
        throw new Error("systemInstruction parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["tools"]) !== void 0) {
        throw new Error("tools parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
        throw new Error("generationConfig parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function countTokensConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = fromTools;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex(item);
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
      }
      return toObject;
    }
    function countTokensParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        countTokensConfigToMldev(fromConfig);
      }
      return toObject;
    }
    function countTokensParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        countTokensConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function countTokensResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
      if (fromTotalTokens != null) {
        setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
      }
      const fromCachedContentTokenCount = getValueByPath(fromObject, [
        "cachedContentTokenCount"
      ]);
      if (fromCachedContentTokenCount != null) {
        setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
      }
      return toObject;
    }
    function countTokensResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
      if (fromTotalTokens != null) {
        setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
      }
      return toObject;
    }
    function deleteModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function deleteModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function deleteModelResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function deleteModelResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    function editImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromEditMode = getValueByPath(fromObject, ["editMode"]);
      if (parentObject !== void 0 && fromEditMode != null) {
        setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
      }
      const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
      if (parentObject !== void 0 && fromBaseSteps != null) {
        setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
      }
      return toObject;
    }
    function editImageParametersInternalToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return referenceImageAPIInternalToVertex(item);
          });
        }
        setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        editImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function editImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function embedContentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
      }
      if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
        throw new Error("mimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
        throw new Error("autoTruncate parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function embedContentConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromTaskType = getValueByPath(fromObject, ["taskType"]);
      if (parentObject !== void 0 && fromTaskType != null) {
        setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
      }
      const fromTitle = getValueByPath(fromObject, ["title"]);
      if (parentObject !== void 0 && fromTitle != null) {
        setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
      }
      const fromOutputDimensionality = getValueByPath(fromObject, [
        "outputDimensionality"
      ]);
      if (parentObject !== void 0 && fromOutputDimensionality != null) {
        setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (parentObject !== void 0 && fromMimeType != null) {
        setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
      }
      const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
      if (parentObject !== void 0 && fromAutoTruncate != null) {
        setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
      }
      return toObject;
    }
    function embedContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["requests[]", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        embedContentConfigToMldev(fromConfig, toObject);
      }
      const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
      if (fromModelForEmbedContent !== void 0) {
        setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
      }
      return toObject;
    }
    function embedContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContentsForEmbed(apiClient, fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["instances[]", "content"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        embedContentConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function embedContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
      if (fromEmbeddings != null) {
        let transformedList = fromEmbeddings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["embeddings"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      return toObject;
    }
    function embedContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromEmbeddings = getValueByPath(fromObject, [
        "predictions[]",
        "embeddings"
      ]);
      if (fromEmbeddings != null) {
        let transformedList = fromEmbeddings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentEmbeddingFromVertex(item);
          });
        }
        setValueByPath(toObject, ["embeddings"], transformedList);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      return toObject;
    }
    function endpointFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["endpoint"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDeployedModelId = getValueByPath(fromObject, [
        "deployedModelId"
      ]);
      if (fromDeployedModelId != null) {
        setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
      }
      return toObject;
    }
    function fileDataToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev$1(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionCallingConfigToMldev(fromObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (fromMode != null) {
        setValueByPath(toObject, ["mode"], fromMode);
      }
      const fromAllowedFunctionNames = getValueByPath(fromObject, [
        "allowedFunctionNames"
      ]);
      if (fromAllowedFunctionNames != null) {
        setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
      }
      if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
        throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function functionDeclarationToVertex(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
        throw new Error("behavior parameter is not supported in Vertex AI.");
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromParameters = getValueByPath(fromObject, ["parameters"]);
      if (fromParameters != null) {
        setValueByPath(toObject, ["parameters"], fromParameters);
      }
      const fromParametersJsonSchema = getValueByPath(fromObject, [
        "parametersJsonSchema"
      ]);
      if (fromParametersJsonSchema != null) {
        setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], fromResponse);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      return toObject;
    }
    function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
        throw new Error("routingConfig parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
        throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return safetySettingToMldev(item);
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev$1(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
      }
      if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
        throw new Error("audioTimestamp parameter is not supported in Gemini API.");
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
      }
      return toObject;
    }
    function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromSafetySettings = getValueByPath(fromObject, [
        "safetySettings"
      ]);
      if (parentObject !== void 0 && fromSafetySettings != null) {
        let transformedList = fromSafetySettings;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["safetySettings"], transformedList);
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToVertex(tTool(item));
          });
        }
        setValueByPath(parentObject, ["tools"], transformedList);
      }
      const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
      if (parentObject !== void 0 && fromToolConfig != null) {
        setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromCachedContent = getValueByPath(fromObject, [
        "cachedContent"
      ]);
      if (parentObject !== void 0 && fromCachedContent != null) {
        setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
      if (fromImageConfig != null) {
        setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
      }
      return toObject;
    }
    function generateContentParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return contentToMldev$1(item);
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function generateContentParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromContents = getValueByPath(fromObject, ["contents"]);
      if (fromContents != null) {
        let transformedList = tContents(fromContents);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["contents"], transformedList);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function generateContentResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return candidateFromMldev(item);
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function generateContentResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromCandidates = getValueByPath(fromObject, ["candidates"]);
      if (fromCandidates != null) {
        let transformedList = fromCandidates;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["candidates"], transformedList);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
      if (fromModelVersion != null) {
        setValueByPath(toObject, ["modelVersion"], fromModelVersion);
      }
      const fromPromptFeedback = getValueByPath(fromObject, [
        "promptFeedback"
      ]);
      if (fromPromptFeedback != null) {
        setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
      }
      const fromResponseId = getValueByPath(fromObject, ["responseId"]);
      if (fromResponseId != null) {
        setValueByPath(toObject, ["responseId"], fromResponseId);
      }
      const fromUsageMetadata = getValueByPath(fromObject, [
        "usageMetadata"
      ]);
      if (fromUsageMetadata != null) {
        setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
      }
      return toObject;
    }
    function generateImagesConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
        throw new Error("negativePrompt parameter is not supported in Gemini API.");
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      if (getValueByPath(fromObject, ["seed"]) !== void 0) {
        throw new Error("seed parameter is not supported in Gemini API.");
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
        throw new Error("addWatermark parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (parentObject !== void 0 && fromImageSize != null) {
        setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
        throw new Error("enhancePrompt parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateImagesConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromGuidanceScale = getValueByPath(fromObject, [
        "guidanceScale"
      ]);
      if (parentObject !== void 0 && fromGuidanceScale != null) {
        setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
        "includeSafetyAttributes"
      ]);
      if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
        setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromLanguage = getValueByPath(fromObject, ["language"]);
      if (parentObject !== void 0 && fromLanguage != null) {
        setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (parentObject !== void 0 && fromImageSize != null) {
        setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      return toObject;
    }
    function generateImagesParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateImagesConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function generateImagesParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateImagesConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function generateImagesResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromMldev(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
        "positivePromptSafetyAttributes"
      ]);
      if (fromPositivePromptSafetyAttributes != null) {
        setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
      }
      return toObject;
    }
    function generateImagesResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
        "positivePromptSafetyAttributes"
      ]);
      if (fromPositivePromptSafetyAttributes != null) {
        setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
      }
      return toObject;
    }
    function generateVideosConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfVideos = getValueByPath(fromObject, [
        "numberOfVideos"
      ]);
      if (parentObject !== void 0 && fromNumberOfVideos != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
      }
      if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["fps"]) !== void 0) {
        throw new Error("fps parameter is not supported in Gemini API.");
      }
      const fromDurationSeconds = getValueByPath(fromObject, [
        "durationSeconds"
      ]);
      if (parentObject !== void 0 && fromDurationSeconds != null) {
        setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
      }
      if (getValueByPath(fromObject, ["seed"]) !== void 0) {
        throw new Error("seed parameter is not supported in Gemini API.");
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromResolution = getValueByPath(fromObject, ["resolution"]);
      if (parentObject !== void 0 && fromResolution != null) {
        setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
        throw new Error("pubsubTopic parameter is not supported in Gemini API.");
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
        throw new Error("generateAudio parameter is not supported in Gemini API.");
      }
      const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
      if (parentObject !== void 0 && fromLastFrame != null) {
        setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (parentObject !== void 0 && fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return videoGenerationReferenceImageToMldev(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
      }
      if (getValueByPath(fromObject, ["mask"]) !== void 0) {
        throw new Error("mask parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
        throw new Error("compressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function generateVideosConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfVideos = getValueByPath(fromObject, [
        "numberOfVideos"
      ]);
      if (parentObject !== void 0 && fromNumberOfVideos != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
      }
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromFps = getValueByPath(fromObject, ["fps"]);
      if (parentObject !== void 0 && fromFps != null) {
        setValueByPath(parentObject, ["parameters", "fps"], fromFps);
      }
      const fromDurationSeconds = getValueByPath(fromObject, [
        "durationSeconds"
      ]);
      if (parentObject !== void 0 && fromDurationSeconds != null) {
        setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (parentObject !== void 0 && fromAspectRatio != null) {
        setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
      }
      const fromResolution = getValueByPath(fromObject, ["resolution"]);
      if (parentObject !== void 0 && fromResolution != null) {
        setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
      if (parentObject !== void 0 && fromPubsubTopic != null) {
        setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
      }
      const fromNegativePrompt = getValueByPath(fromObject, [
        "negativePrompt"
      ]);
      if (parentObject !== void 0 && fromNegativePrompt != null) {
        setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      const fromGenerateAudio = getValueByPath(fromObject, [
        "generateAudio"
      ]);
      if (parentObject !== void 0 && fromGenerateAudio != null) {
        setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
      }
      const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
      if (parentObject !== void 0 && fromLastFrame != null) {
        setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
      }
      const fromReferenceImages = getValueByPath(fromObject, [
        "referenceImages"
      ]);
      if (parentObject !== void 0 && fromReferenceImages != null) {
        let transformedList = fromReferenceImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return videoGenerationReferenceImageToVertex(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
      }
      const fromMask = getValueByPath(fromObject, ["mask"]);
      if (parentObject !== void 0 && fromMask != null) {
        setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
      }
      const fromCompressionQuality = getValueByPath(fromObject, [
        "compressionQuality"
      ]);
      if (parentObject !== void 0 && fromCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
      }
      return toObject;
    }
    function generateVideosOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, [
        "response",
        "generateVideoResponse"
      ]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function generateVideosOperationFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
      }
      return toObject;
    }
    function generateVideosParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        generateVideosSourceToMldev(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateVideosConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function generateVideosParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromPrompt != null) {
        setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        generateVideosSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        generateVideosConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function generateVideosResponseFromMldev(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, [
        "generatedSamples"
      ]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromMldev(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
      if (fromGeneratedVideos != null) {
        let transformedList = fromGeneratedVideos;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedVideoFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedVideos"], transformedList);
      }
      const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
        "raiMediaFilteredCount"
      ]);
      if (fromRaiMediaFilteredCount != null) {
        setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
      }
      const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
        "raiMediaFilteredReasons"
      ]);
      if (fromRaiMediaFilteredReasons != null) {
        setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
      }
      return toObject;
    }
    function generateVideosSourceToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (parentObject !== void 0 && fromVideo != null) {
        setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
      }
      return toObject;
    }
    function generateVideosSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (parentObject !== void 0 && fromVideo != null) {
        setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
      }
      return toObject;
    }
    function generatedImageFromMldev(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["_self"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
      }
      const fromRaiFilteredReason = getValueByPath(fromObject, [
        "raiFilteredReason"
      ]);
      if (fromRaiFilteredReason != null) {
        setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
      }
      const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
      if (fromSafetyAttributes != null) {
        setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
      }
      return toObject;
    }
    function generatedImageFromVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["_self"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
      }
      const fromRaiFilteredReason = getValueByPath(fromObject, [
        "raiFilteredReason"
      ]);
      if (fromRaiFilteredReason != null) {
        setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
      }
      const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
      if (fromSafetyAttributes != null) {
        setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
      }
      const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
      if (fromEnhancedPrompt != null) {
        setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
      }
      return toObject;
    }
    function generatedImageMaskFromVertex(fromObject) {
      const toObject = {};
      const fromMask = getValueByPath(fromObject, ["_self"]);
      if (fromMask != null) {
        setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        let transformedList = fromLabels;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["labels"], transformedList);
      }
      return toObject;
    }
    function generatedVideoFromMldev(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["video"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
      }
      return toObject;
    }
    function generatedVideoFromVertex(fromObject) {
      const toObject = {};
      const fromVideo = getValueByPath(fromObject, ["_self"]);
      if (fromVideo != null) {
        setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
      }
      return toObject;
    }
    function generationConfigToVertex(fromObject) {
      const toObject = {};
      const fromModelSelectionConfig = getValueByPath(fromObject, [
        "modelSelectionConfig"
      ]);
      if (fromModelSelectionConfig != null) {
        setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
      }
      const fromResponseJsonSchema = getValueByPath(fromObject, [
        "responseJsonSchema"
      ]);
      if (fromResponseJsonSchema != null) {
        setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
      }
      const fromAudioTimestamp = getValueByPath(fromObject, [
        "audioTimestamp"
      ]);
      if (fromAudioTimestamp != null) {
        setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
      }
      const fromCandidateCount = getValueByPath(fromObject, [
        "candidateCount"
      ]);
      if (fromCandidateCount != null) {
        setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (fromEnableAffectiveDialog != null) {
        setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromFrequencyPenalty = getValueByPath(fromObject, [
        "frequencyPenalty"
      ]);
      if (fromFrequencyPenalty != null) {
        setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
      }
      const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
      if (fromLogprobs != null) {
        setValueByPath(toObject, ["logprobs"], fromLogprobs);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (fromMaxOutputTokens != null) {
        setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromPresencePenalty = getValueByPath(fromObject, [
        "presencePenalty"
      ]);
      if (fromPresencePenalty != null) {
        setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
      }
      const fromResponseLogprobs = getValueByPath(fromObject, [
        "responseLogprobs"
      ]);
      if (fromResponseLogprobs != null) {
        setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
      }
      const fromResponseMimeType = getValueByPath(fromObject, [
        "responseMimeType"
      ]);
      if (fromResponseMimeType != null) {
        setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (fromResponseModalities != null) {
        setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
      }
      const fromResponseSchema = getValueByPath(fromObject, [
        "responseSchema"
      ]);
      if (fromResponseSchema != null) {
        setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
      }
      const fromRoutingConfig = getValueByPath(fromObject, [
        "routingConfig"
      ]);
      if (fromRoutingConfig != null) {
        setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (fromSeed != null) {
        setValueByPath(toObject, ["seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (fromSpeechConfig != null) {
        setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(fromSpeechConfig));
      }
      const fromStopSequences = getValueByPath(fromObject, [
        "stopSequences"
      ]);
      if (fromStopSequences != null) {
        setValueByPath(toObject, ["stopSequences"], fromStopSequences);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (fromThinkingConfig != null) {
        setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
        throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function getModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function getModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      return toObject;
    }
    function googleMapsToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev$1(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function imageConfigToMldev(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
        throw new Error("outputMimeType parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
        throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function imageConfigToVertex(fromObject) {
      const toObject = {};
      const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
      if (fromAspectRatio != null) {
        setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
      }
      const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
      if (fromImageSize != null) {
        setValueByPath(toObject, ["imageSize"], fromImageSize);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (fromOutputMimeType != null) {
        setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (fromOutputCompressionQuality != null) {
        setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      return toObject;
    }
    function imageFromMldev(fromObject) {
      const toObject = {};
      const fromImageBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageFromVertex(fromObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromImageBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function imageToVertex(fromObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromGcsUri);
      }
      const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
      if (fromImageBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
      if (parentObject !== void 0 && fromQueryBase != null) {
        setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
      }
      return toObject;
    }
    function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
      if (parentObject !== void 0 && fromQueryBase != null) {
        setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
      }
      return toObject;
    }
    function listModelsParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listModelsConfigToMldev(apiClient, fromConfig, toObject);
      }
      return toObject;
    }
    function listModelsParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listModelsConfigToVertex(apiClient, fromConfig, toObject);
      }
      return toObject;
    }
    function listModelsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromModels = getValueByPath(fromObject, ["_self"]);
      if (fromModels != null) {
        let transformedList = tExtractModels(fromModels);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return modelFromMldev(item);
          });
        }
        setValueByPath(toObject, ["models"], transformedList);
      }
      return toObject;
    }
    function listModelsResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromModels = getValueByPath(fromObject, ["_self"]);
      if (fromModels != null) {
        let transformedList = tExtractModels(fromModels);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return modelFromVertex(item);
          });
        }
        setValueByPath(toObject, ["models"], transformedList);
      }
      return toObject;
    }
    function maskReferenceConfigToVertex(fromObject) {
      const toObject = {};
      const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
      if (fromMaskMode != null) {
        setValueByPath(toObject, ["maskMode"], fromMaskMode);
      }
      const fromSegmentationClasses = getValueByPath(fromObject, [
        "segmentationClasses"
      ]);
      if (fromSegmentationClasses != null) {
        setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
      }
      const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
      if (fromMaskDilation != null) {
        setValueByPath(toObject, ["dilation"], fromMaskDilation);
      }
      return toObject;
    }
    function modelFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromVersion = getValueByPath(fromObject, ["version"]);
      if (fromVersion != null) {
        setValueByPath(toObject, ["version"], fromVersion);
      }
      const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModelInfo != null) {
        setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
      }
      const fromInputTokenLimit = getValueByPath(fromObject, [
        "inputTokenLimit"
      ]);
      if (fromInputTokenLimit != null) {
        setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
      }
      const fromOutputTokenLimit = getValueByPath(fromObject, [
        "outputTokenLimit"
      ]);
      if (fromOutputTokenLimit != null) {
        setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
      }
      const fromSupportedActions = getValueByPath(fromObject, [
        "supportedGenerationMethods"
      ]);
      if (fromSupportedActions != null) {
        setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (fromTemperature != null) {
        setValueByPath(toObject, ["temperature"], fromTemperature);
      }
      const fromMaxTemperature = getValueByPath(fromObject, [
        "maxTemperature"
      ]);
      if (fromMaxTemperature != null) {
        setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (fromTopP != null) {
        setValueByPath(toObject, ["topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (fromTopK != null) {
        setValueByPath(toObject, ["topK"], fromTopK);
      }
      const fromThinking = getValueByPath(fromObject, ["thinking"]);
      if (fromThinking != null) {
        setValueByPath(toObject, ["thinking"], fromThinking);
      }
      return toObject;
    }
    function modelFromVertex(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (fromDisplayName != null) {
        setValueByPath(toObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromVersion = getValueByPath(fromObject, ["versionId"]);
      if (fromVersion != null) {
        setValueByPath(toObject, ["version"], fromVersion);
      }
      const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
      if (fromEndpoints != null) {
        let transformedList = fromEndpoints;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return endpointFromVertex(item);
          });
        }
        setValueByPath(toObject, ["endpoints"], transformedList);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        setValueByPath(toObject, ["labels"], fromLabels);
      }
      const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModelInfo != null) {
        setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (fromDefaultCheckpointId != null) {
        setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
      if (fromCheckpoints != null) {
        let transformedList = fromCheckpoints;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["checkpoints"], transformedList);
      }
      return toObject;
    }
    function partToMldev$1(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function productImageToVertex(fromObject) {
      const toObject = {};
      const fromProductImage = getValueByPath(fromObject, ["productImage"]);
      if (fromProductImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
      }
      return toObject;
    }
    function recontextImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
      if (parentObject !== void 0 && fromBaseSteps != null) {
        setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
      }
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
      if (parentObject !== void 0 && fromAddWatermark != null) {
        setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromEnhancePrompt = getValueByPath(fromObject, [
        "enhancePrompt"
      ]);
      if (parentObject !== void 0 && fromEnhancePrompt != null) {
        setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      return toObject;
    }
    function recontextImageParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        recontextImageSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        recontextImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function recontextImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function recontextImageSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
      if (parentObject !== void 0 && fromPersonImage != null) {
        setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
      }
      const fromProductImages = getValueByPath(fromObject, [
        "productImages"
      ]);
      if (parentObject !== void 0 && fromProductImages != null) {
        let transformedList = fromProductImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return productImageToVertex(item);
          });
        }
        setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
      }
      return toObject;
    }
    function referenceImageAPIInternalToVertex(fromObject) {
      const toObject = {};
      const fromReferenceImage = getValueByPath(fromObject, [
        "referenceImage"
      ]);
      if (fromReferenceImage != null) {
        setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
      }
      const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
      if (fromReferenceId != null) {
        setValueByPath(toObject, ["referenceId"], fromReferenceId);
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      const fromMaskImageConfig = getValueByPath(fromObject, [
        "maskImageConfig"
      ]);
      if (fromMaskImageConfig != null) {
        setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
      }
      const fromControlImageConfig = getValueByPath(fromObject, [
        "controlImageConfig"
      ]);
      if (fromControlImageConfig != null) {
        setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
      }
      const fromStyleImageConfig = getValueByPath(fromObject, [
        "styleImageConfig"
      ]);
      if (fromStyleImageConfig != null) {
        setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
      }
      const fromSubjectImageConfig = getValueByPath(fromObject, [
        "subjectImageConfig"
      ]);
      if (fromSubjectImageConfig != null) {
        setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
      }
      return toObject;
    }
    function safetyAttributesFromMldev(fromObject) {
      const toObject = {};
      const fromCategories = getValueByPath(fromObject, [
        "safetyAttributes",
        "categories"
      ]);
      if (fromCategories != null) {
        setValueByPath(toObject, ["categories"], fromCategories);
      }
      const fromScores = getValueByPath(fromObject, [
        "safetyAttributes",
        "scores"
      ]);
      if (fromScores != null) {
        setValueByPath(toObject, ["scores"], fromScores);
      }
      const fromContentType = getValueByPath(fromObject, ["contentType"]);
      if (fromContentType != null) {
        setValueByPath(toObject, ["contentType"], fromContentType);
      }
      return toObject;
    }
    function safetyAttributesFromVertex(fromObject) {
      const toObject = {};
      const fromCategories = getValueByPath(fromObject, [
        "safetyAttributes",
        "categories"
      ]);
      if (fromCategories != null) {
        setValueByPath(toObject, ["categories"], fromCategories);
      }
      const fromScores = getValueByPath(fromObject, [
        "safetyAttributes",
        "scores"
      ]);
      if (fromScores != null) {
        setValueByPath(toObject, ["scores"], fromScores);
      }
      const fromContentType = getValueByPath(fromObject, ["contentType"]);
      if (fromContentType != null) {
        setValueByPath(toObject, ["contentType"], fromContentType);
      }
      return toObject;
    }
    function safetySettingToMldev(fromObject) {
      const toObject = {};
      const fromCategory = getValueByPath(fromObject, ["category"]);
      if (fromCategory != null) {
        setValueByPath(toObject, ["category"], fromCategory);
      }
      if (getValueByPath(fromObject, ["method"]) !== void 0) {
        throw new Error("method parameter is not supported in Gemini API.");
      }
      const fromThreshold = getValueByPath(fromObject, ["threshold"]);
      if (fromThreshold != null) {
        setValueByPath(toObject, ["threshold"], fromThreshold);
      }
      return toObject;
    }
    function scribbleImageToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromImage));
      }
      return toObject;
    }
    function segmentImageConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (parentObject !== void 0 && fromMode != null) {
        setValueByPath(parentObject, ["parameters", "mode"], fromMode);
      }
      const fromMaxPredictions = getValueByPath(fromObject, [
        "maxPredictions"
      ]);
      if (parentObject !== void 0 && fromMaxPredictions != null) {
        setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
      }
      const fromConfidenceThreshold = getValueByPath(fromObject, [
        "confidenceThreshold"
      ]);
      if (parentObject !== void 0 && fromConfidenceThreshold != null) {
        setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
      }
      const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
      if (parentObject !== void 0 && fromMaskDilation != null) {
        setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
      }
      const fromBinaryColorThreshold = getValueByPath(fromObject, [
        "binaryColorThreshold"
      ]);
      if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
        setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      return toObject;
    }
    function segmentImageParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromSource = getValueByPath(fromObject, ["source"]);
      if (fromSource != null) {
        segmentImageSourceToVertex(fromSource, toObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        segmentImageConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function segmentImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
      if (fromGeneratedMasks != null) {
        let transformedList = fromGeneratedMasks;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageMaskFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedMasks"], transformedList);
      }
      return toObject;
    }
    function segmentImageSourceToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromPrompt = getValueByPath(fromObject, ["prompt"]);
      if (parentObject !== void 0 && fromPrompt != null) {
        setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (parentObject !== void 0 && fromImage != null) {
        setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromScribbleImage = getValueByPath(fromObject, [
        "scribbleImage"
      ]);
      if (parentObject !== void 0 && fromScribbleImage != null) {
        setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
      }
      return toObject;
    }
    function speechConfigToVertex(fromObject) {
      const toObject = {};
      const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
      if (fromLanguageCode != null) {
        setValueByPath(toObject, ["languageCode"], fromLanguageCode);
      }
      const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
      if (fromVoiceConfig != null) {
        setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
      }
      if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
        throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function toolConfigToMldev(fromObject) {
      const toObject = {};
      const fromFunctionCallingConfig = getValueByPath(fromObject, [
        "functionCallingConfig"
      ]);
      if (fromFunctionCallingConfig != null) {
        setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
      }
      const fromRetrievalConfig = getValueByPath(fromObject, [
        "retrievalConfig"
      ]);
      if (fromRetrievalConfig != null) {
        setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
      }
      return toObject;
    }
    function toolToMldev$1(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function toolToVertex(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return functionDeclarationToVertex(item);
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
      if (fromRetrieval != null) {
        setValueByPath(toObject, ["retrieval"], fromRetrieval);
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
        throw new Error("fileSearch parameter is not supported in Vertex AI.");
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      const fromEnterpriseWebSearch = getValueByPath(fromObject, [
        "enterpriseWebSearch"
      ]);
      if (fromEnterpriseWebSearch != null) {
        setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    function tunedModelInfoFromMldev(fromObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      return toObject;
    }
    function tunedModelInfoFromVertex(fromObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, [
        "labels",
        "google-vertex-llm-tuning-base-model-id"
      ]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      return toObject;
    }
    function updateModelConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
        setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      return toObject;
    }
    function updateModelConfigToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      const fromDefaultCheckpointId = getValueByPath(fromObject, [
        "defaultCheckpointId"
      ]);
      if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
        setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
      }
      return toObject;
    }
    function updateModelParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateModelConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function updateModelParametersToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        updateModelConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
      const toObject = {};
      const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
      if (parentObject !== void 0 && fromOutputGcsUri != null) {
        setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
      }
      const fromSafetyFilterLevel = getValueByPath(fromObject, [
        "safetyFilterLevel"
      ]);
      if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
        setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
      }
      const fromPersonGeneration = getValueByPath(fromObject, [
        "personGeneration"
      ]);
      if (parentObject !== void 0 && fromPersonGeneration != null) {
        setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
      }
      const fromIncludeRaiReason = getValueByPath(fromObject, [
        "includeRaiReason"
      ]);
      if (parentObject !== void 0 && fromIncludeRaiReason != null) {
        setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
      }
      const fromOutputMimeType = getValueByPath(fromObject, [
        "outputMimeType"
      ]);
      if (parentObject !== void 0 && fromOutputMimeType != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
      }
      const fromOutputCompressionQuality = getValueByPath(fromObject, [
        "outputCompressionQuality"
      ]);
      if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
        setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
      }
      const fromEnhanceInputImage = getValueByPath(fromObject, [
        "enhanceInputImage"
      ]);
      if (parentObject !== void 0 && fromEnhanceInputImage != null) {
        setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
      }
      const fromImagePreservationFactor = getValueByPath(fromObject, [
        "imagePreservationFactor"
      ]);
      if (parentObject !== void 0 && fromImagePreservationFactor != null) {
        setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromNumberOfImages = getValueByPath(fromObject, [
        "numberOfImages"
      ]);
      if (parentObject !== void 0 && fromNumberOfImages != null) {
        setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
      }
      const fromMode = getValueByPath(fromObject, ["mode"]);
      if (parentObject !== void 0 && fromMode != null) {
        setValueByPath(parentObject, ["parameters", "mode"], fromMode);
      }
      return toObject;
    }
    function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
      }
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
      }
      const fromUpscaleFactor = getValueByPath(fromObject, [
        "upscaleFactor"
      ]);
      if (fromUpscaleFactor != null) {
        setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function upscaleImageResponseFromVertex(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromGeneratedImages = getValueByPath(fromObject, [
        "predictions"
      ]);
      if (fromGeneratedImages != null) {
        let transformedList = fromGeneratedImages;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return generatedImageFromVertex(item);
          });
        }
        setValueByPath(toObject, ["generatedImages"], transformedList);
      }
      return toObject;
    }
    function videoFromMldev(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["encoding"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoFromVertex(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, [
        "bytesBase64Encoded"
      ]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function videoGenerationMaskToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
      }
      const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
      if (fromMaskMode != null) {
        setValueByPath(toObject, ["maskMode"], fromMaskMode);
      }
      return toObject;
    }
    function videoGenerationReferenceImageToMldev(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToMldev(fromImage));
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      return toObject;
    }
    function videoGenerationReferenceImageToVertex(fromObject) {
      const toObject = {};
      const fromImage = getValueByPath(fromObject, ["image"]);
      if (fromImage != null) {
        setValueByPath(toObject, ["image"], imageToVertex(fromImage));
      }
      const fromReferenceType = getValueByPath(fromObject, [
        "referenceType"
      ]);
      if (fromReferenceType != null) {
        setValueByPath(toObject, ["referenceType"], fromReferenceType);
      }
      return toObject;
    }
    function videoToMldev(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["uri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["encoding"], fromMimeType);
      }
      return toObject;
    }
    function videoToVertex(fromObject) {
      const toObject = {};
      const fromUri = getValueByPath(fromObject, ["uri"]);
      if (fromUri != null) {
        setValueByPath(toObject, ["gcsUri"], fromUri);
      }
      const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
      if (fromVideoBytes != null) {
        setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const CONTENT_TYPE_HEADER = "Content-Type";
    const SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
    const USER_AGENT_HEADER = "User-Agent";
    const GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
    const SDK_VERSION = "1.30.0";
    const LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
    const VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
    const GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
    const responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
    class ApiClient {
      constructor(opts) {
        var _a, _b;
        this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
        const initHttpOptions = {};
        if (this.clientOptions.vertexai) {
          initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
          initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
          this.normalizeAuthParameters();
        } else {
          initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
          initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
        }
        initHttpOptions.headers = this.getDefaultHeaders();
        this.clientOptions.httpOptions = initHttpOptions;
        if (opts.httpOptions) {
          this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
        }
      }
      /**
       * Determines the base URL for Vertex AI based on project and location.
       * Uses the global endpoint if location is 'global' or if project/location
       * are not specified (implying API key usage).
       * @private
       */
      baseUrlFromProjectLocation() {
        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
          return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
        }
        return `https://aiplatform.googleapis.com/`;
      }
      /**
       * Normalizes authentication parameters for Vertex AI.
       * If project and location are provided, API key is cleared.
       * If project and location are not provided (implying API key usage),
       * project and location are cleared.
       * @private
       */
      normalizeAuthParameters() {
        if (this.clientOptions.project && this.clientOptions.location) {
          this.clientOptions.apiKey = void 0;
          return;
        }
        this.clientOptions.project = void 0;
        this.clientOptions.location = void 0;
      }
      isVertexAI() {
        var _a;
        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
      }
      getProject() {
        return this.clientOptions.project;
      }
      getLocation() {
        return this.clientOptions.location;
      }
      getApiVersion() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
          return this.clientOptions.httpOptions.apiVersion;
        }
        throw new Error("API version is not set.");
      }
      getBaseUrl() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
          return this.clientOptions.httpOptions.baseUrl;
        }
        throw new Error("Base URL is not set.");
      }
      getRequestUrl() {
        return this.getRequestUrlInternal(this.clientOptions.httpOptions);
      }
      getHeaders() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
          return this.clientOptions.httpOptions.headers;
        } else {
          throw new Error("Headers are not set.");
        }
      }
      getRequestUrlInternal(httpOptions) {
        if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
          throw new Error("HTTP options are not correctly set.");
        }
        const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
        const urlElement = [baseUrl];
        if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
          urlElement.push(httpOptions.apiVersion);
        }
        return urlElement.join("/");
      }
      getBaseResourcePath() {
        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
      }
      getApiKey() {
        return this.clientOptions.apiKey;
      }
      getWebsocketBaseUrl() {
        const baseUrl = this.getBaseUrl();
        const urlParts = new URL(baseUrl);
        urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
        return urlParts.toString();
      }
      setBaseUrl(url) {
        if (this.clientOptions.httpOptions) {
          this.clientOptions.httpOptions.baseUrl = url;
        } else {
          throw new Error("HTTP options are not correctly set.");
        }
      }
      constructUrl(path, httpOptions, prependProjectLocation) {
        const urlElement = [this.getRequestUrlInternal(httpOptions)];
        if (prependProjectLocation) {
          urlElement.push(this.getBaseResourcePath());
        }
        if (path !== "") {
          urlElement.push(path);
        }
        const url = new URL(`${urlElement.join("/")}`);
        return url;
      }
      shouldPrependVertexProjectPath(request) {
        if (this.clientOptions.apiKey) {
          return false;
        }
        if (!this.clientOptions.vertexai) {
          return false;
        }
        if (request.path.startsWith("projects/")) {
          return false;
        }
        if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
          return false;
        }
        return true;
      }
      request(request) {
        return __async(this, null, function* () {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (request.queryParams) {
            for (const [key, value] of Object.entries(request.queryParams)) {
              url.searchParams.append(key, String(value));
            }
          }
          let requestInit = {};
          if (request.httpMethod === "GET") {
            if (request.body && request.body !== "{}") {
              throw new Error("Request body should be empty for GET request, but got non empty request body");
            }
          } else {
            requestInit.body = request.body;
          }
          requestInit = yield this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.unaryApiCall(url, requestInit, request.httpMethod);
        });
      }
      patchHttpOptions(baseHttpOptions, requestHttpOptions) {
        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
        for (const [key, value] of Object.entries(requestHttpOptions)) {
          if (typeof value === "object") {
            patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
          } else if (value !== void 0) {
            patchedHttpOptions[key] = value;
          }
        }
        return patchedHttpOptions;
      }
      requestStream(request) {
        return __async(this, null, function* () {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
            url.searchParams.set("alt", "sse");
          }
          let requestInit = {};
          requestInit.body = request.body;
          requestInit = yield this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.streamApiCall(url, requestInit, request.httpMethod);
        });
      }
      includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
        return __async(this, null, function* () {
          if (httpOptions && httpOptions.timeout || abortSignal) {
            const abortController = new AbortController();
            const signal = abortController.signal;
            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
              const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
              if (timeoutHandle && typeof timeoutHandle.unref === "function") {
                timeoutHandle.unref();
              }
            }
            if (abortSignal) {
              abortSignal.addEventListener("abort", () => {
                abortController.abort();
              });
            }
            requestInit.signal = signal;
          }
          if (httpOptions && httpOptions.extraBody !== null) {
            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
          }
          requestInit.headers = yield this.getHeadersInternal(httpOptions, url);
          return requestInit;
        });
      }
      unaryApiCall(url, requestInit, httpMethod) {
        return __async(this, null, function* () {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then((response) => __async(this, null, function* () {
            yield throwErrorIfNotOK(response);
            return new HttpResponse(response);
          })).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        });
      }
      streamApiCall(url, requestInit, httpMethod) {
        return __async(this, null, function* () {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then((response) => __async(this, null, function* () {
            yield throwErrorIfNotOK(response);
            return this.processStreamResponse(response);
          })).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        });
      }
      processStreamResponse(response) {
        var _a;
        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
          const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
          const decoder = new TextDecoder("utf-8");
          if (!reader) {
            throw new Error("Response body is empty");
          }
          try {
            let buffer = "";
            while (true) {
              const { done, value } = yield __await(reader.read());
              if (done) {
                if (buffer.trim().length > 0) {
                  throw new Error("Incomplete JSON segment at the end");
                }
                break;
              }
              const chunkString = decoder.decode(value, { stream: true });
              try {
                const chunkJson = JSON.parse(chunkString);
                if ("error" in chunkJson) {
                  const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                  const status = errorJson["status"];
                  const code = errorJson["code"];
                  const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                  if (code >= 400 && code < 600) {
                    const apiError = new ApiError({
                      message: errorMessage,
                      status: code
                    });
                    throw apiError;
                  }
                }
              } catch (e) {
                const error = e;
                if (error.name === "ApiError") {
                  throw e;
                }
              }
              buffer += chunkString;
              let match = buffer.match(responseLineRE);
              while (match) {
                const processedChunkString = match[1];
                try {
                  const partialResponse = new Response(processedChunkString, {
                    headers: response === null || response === void 0 ? void 0 : response.headers,
                    status: response === null || response === void 0 ? void 0 : response.status,
                    statusText: response === null || response === void 0 ? void 0 : response.statusText
                  });
                  yield yield __await(new HttpResponse(partialResponse));
                  buffer = buffer.slice(match[0].length);
                  match = buffer.match(responseLineRE);
                } catch (e) {
                  throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
                }
              }
            }
          } finally {
            reader.releaseLock();
          }
        });
      }
      apiCall(url, requestInit) {
        return __async(this, null, function* () {
          return fetch(url, requestInit).catch((e) => {
            throw new Error(`exception ${e} sending request`);
          });
        });
      }
      getDefaultHeaders() {
        const headers = {};
        const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
        headers[USER_AGENT_HEADER] = versionHeaderValue;
        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
        headers[CONTENT_TYPE_HEADER] = "application/json";
        return headers;
      }
      getHeadersInternal(httpOptions, url) {
        return __async(this, null, function* () {
          const headers = new Headers();
          if (httpOptions && httpOptions.headers) {
            for (const [key, value] of Object.entries(httpOptions.headers)) {
              headers.append(key, value);
            }
            if (httpOptions.timeout && httpOptions.timeout > 0) {
              headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
            }
          }
          yield this.clientOptions.auth.addAuthHeaders(headers, url);
          return headers;
        });
      }
      getFileName(file) {
        var _a;
        let fileName = "";
        if (typeof file === "string") {
          fileName = file.replace(/[/\\]+$/, "");
          fileName = (_a = fileName.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : "";
        }
        return fileName;
      }
      /**
       * Uploads a file asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link types.UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      uploadFile(file, config) {
        return __async(this, null, function* () {
          var _a;
          const fileToUpload = {};
          if (config != null) {
            fileToUpload.mimeType = config.mimeType;
            fileToUpload.name = config.name;
            fileToUpload.displayName = config.displayName;
          }
          if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
            fileToUpload.name = `files/${fileToUpload.name}`;
          }
          const uploader = this.clientOptions.uploader;
          const fileStat = yield uploader.stat(file);
          fileToUpload.sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          fileToUpload.mimeType = mimeType;
          const body = {
            file: fileToUpload
          };
          const fileName = this.getFileName(file);
          const path = formatMap("upload/v1beta/files", body["_url"]);
          const uploadUrl = yield this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.upload(file, uploadUrl, this);
        });
      }
      /**
       * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
       * in Vertex AI.
       *
       * @param fileSearchStoreName The name of the file search store to upload the file to.
       * @param file The string path to the file to be uploaded or a Blob object.
       * @param config Optional parameters specified in the `UploadFileConfig`
       *     interface. @see {@link UploadFileConfig}
       * @return A promise that resolves to a `File` object.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       */
      uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
        return __async(this, null, function* () {
          var _a;
          const uploader = this.clientOptions.uploader;
          const fileStat = yield uploader.stat(file);
          const sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
          const fileName = this.getFileName(file);
          const body = {};
          if (config === null || config === void 0 ? void 0 : config.customMetadata) {
            body["customMetadata"] = config.customMetadata;
          }
          if (config === null || config === void 0 ? void 0 : config.chunkingConfig) {
            body["chunkingConfig"] = config.chunkingConfig;
          }
          const uploadUrl = yield this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.uploadToFileSearchStore(file, uploadUrl, this);
        });
      }
      /**
       * Downloads a file asynchronously to the specified path.
       *
       * @params params - The parameters for the download request, see {@link
       * types.DownloadFileParameters}
       */
      downloadFile(params) {
        return __async(this, null, function* () {
          const downloader = this.clientOptions.downloader;
          yield downloader.download(params, this);
        });
      }
      fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {
        return __async(this, null, function* () {
          var _a;
          let httpOptions = {};
          if (configHttpOptions) {
            httpOptions = configHttpOptions;
          } else {
            httpOptions = {
              apiVersion: "",
              headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
            };
          }
          const httpResponse = yield this.request({
            path,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions
          });
          if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
            throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
          }
          const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
          if (uploadUrl === void 0) {
            throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
          }
          return uploadUrl;
        });
      }
    }
    function throwErrorIfNotOK(response) {
      return __async(this, null, function* () {
        var _a;
        if (response === void 0) {
          throw new Error("response is undefined");
        }
        if (!response.ok) {
          const status = response.status;
          let errorBody;
          if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
            errorBody = yield response.json();
          } else {
            errorBody = {
              error: {
                message: yield response.text(),
                code: response.status,
                status: response.statusText
              }
            };
          }
          const errorMessage = JSON.stringify(errorBody);
          if (status >= 400 && status < 600) {
            const apiError = new ApiError({
              message: errorMessage,
              status
            });
            throw apiError;
          }
          throw new Error(errorMessage);
        }
      });
    }
    function includeExtraBodyToRequestInit(requestInit, extraBody) {
      if (!extraBody || Object.keys(extraBody).length === 0) {
        return;
      }
      if (requestInit.body instanceof Blob) {
        console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
        return;
      }
      let currentBodyObject = {};
      if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
        try {
          const parsedBody = JSON.parse(requestInit.body);
          if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
            currentBodyObject = parsedBody;
          } else {
            console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
            return;
          }
        } catch (e) {
          console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
          return;
        }
      }
      function deepMerge(target, source) {
        const output = Object.assign({}, target);
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            const sourceValue = source[key];
            const targetValue = output[key];
            if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
              output[key] = deepMerge(targetValue, sourceValue);
            } else {
              if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
                console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
              }
              output[key] = sourceValue;
            }
          }
        }
        return output;
      }
      const mergedBody = deepMerge(currentBodyObject, extraBody);
      requestInit.body = JSON.stringify(mergedBody);
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const MCP_LABEL = "mcp_used/unknown";
    let hasMcpToolUsageFromMcpToTool = false;
    function hasMcpToolUsage(tools) {
      for (const tool of tools) {
        if (isMcpCallableTool(tool)) {
          return true;
        }
        if (typeof tool === "object" && "inputSchema" in tool) {
          return true;
        }
      }
      return hasMcpToolUsageFromMcpToTool;
    }
    function setMcpUsageHeader(headers) {
      var _a;
      const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
      headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
    }
    function isMcpCallableTool(object) {
      return object !== null && typeof object === "object" && object instanceof McpCallableTool;
    }
    function listAllTools(mcpClient, maxTools = 100) {
      return __asyncGenerator(this, arguments, function* listAllTools_1() {
        let cursor = void 0;
        let numTools = 0;
        while (numTools < maxTools) {
          const t = yield __await(mcpClient.listTools({ cursor }));
          for (const tool of t.tools) {
            yield yield __await(tool);
            numTools++;
          }
          if (!t.nextCursor) {
            break;
          }
          cursor = t.nextCursor;
        }
      });
    }
    class McpCallableTool {
      constructor(mcpClients = [], config) {
        this.mcpTools = [];
        this.functionNameToMcpClient = {};
        this.mcpClients = mcpClients;
        this.config = config;
      }
      /**
       * Creates a McpCallableTool.
       */
      static create(mcpClients, config) {
        return new McpCallableTool(mcpClients, config);
      }
      /**
       * Validates the function names are not duplicate and initialize the function
       * name to MCP client mapping.
       *
       * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
       *     names.
       */
      initialize() {
        return __async(this, null, function* () {
          var _a, e_1, _b, _c;
          if (this.mcpTools.length > 0) {
            return;
          }
          const functionMap = {};
          const mcpTools = [];
          for (const mcpClient of this.mcpClients) {
            try {
              for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const mcpTool = _c;
                mcpTools.push(mcpTool);
                const mcpToolName = mcpTool.name;
                if (functionMap[mcpToolName]) {
                  throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
                }
                functionMap[mcpToolName] = mcpClient;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
          this.mcpTools = mcpTools;
          this.functionNameToMcpClient = functionMap;
        });
      }
      tool() {
        return __async(this, null, function* () {
          yield this.initialize();
          return mcpToolsToGeminiTool(this.mcpTools, this.config);
        });
      }
      callTool(functionCalls) {
        return __async(this, null, function* () {
          yield this.initialize();
          const functionCallResponseParts = [];
          for (const functionCall of functionCalls) {
            if (functionCall.name in this.functionNameToMcpClient) {
              const mcpClient = this.functionNameToMcpClient[functionCall.name];
              let requestOptions = void 0;
              if (this.config.timeout) {
                requestOptions = {
                  timeout: this.config.timeout
                };
              }
              const callToolResponse = yield mcpClient.callTool(
                {
                  name: functionCall.name,
                  arguments: functionCall.args
                },
                // Set the result schema to undefined to allow MCP to rely on the
                // default schema.
                void 0,
                requestOptions
              );
              functionCallResponseParts.push({
                functionResponse: {
                  name: functionCall.name,
                  response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
                }
              });
            }
          }
          return functionCallResponseParts;
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function handleWebSocketMessage$1(apiClient, onmessage, event) {
      return __async(this, null, function* () {
        const serverMessage = new LiveMusicServerMessage();
        let data;
        if (event.data instanceof Blob) {
          data = JSON.parse(yield event.data.text());
        } else {
          data = JSON.parse(event.data);
        }
        Object.assign(serverMessage, data);
        onmessage(serverMessage);
      });
    }
    class LiveMusic {
      constructor(apiClient, auth2, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth2;
        this.webSocketFactory = webSocketFactory;
      }
      /**
           Establishes a connection to the specified model and returns a
           LiveMusicSession object representing that connection.
      
           @experimental
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model = 'models/lyria-realtime-exp';
           const session = await ai.live.music.connect({
             model: model,
             callbacks: {
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      connect(params) {
        return __async(this, null, function* () {
          var _a, _b;
          if (this.apiClient.isVertexAI()) {
            throw new Error("Live music is not supported for Vertex AI.");
          }
          console.warn("Live music generation is experimental and may change in future versions.");
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
          const apiKey2 = this.apiClient.getApiKey();
          const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey2}`;
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
          conn.connect();
          yield onopenPromise;
          const model = tModel(this.apiClient, params.model);
          const setup = { model };
          const clientMessage = { setup };
          conn.send(JSON.stringify(clientMessage));
          return new LiveMusicSession(conn, this.apiClient);
        });
      }
    }
    class LiveMusicSession {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      /**
          Sets inputs to steer music generation. Updates the session's current
          weighted prompts.
      
          @param params - Contains one property, `weightedPrompts`.
      
            - `weightedPrompts` to send to the model; weights are normalized to
              sum to 1.0.
      
          @experimental
         */
      setWeightedPrompts(params) {
        return __async(this, null, function* () {
          if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
            throw new Error("Weighted prompts must be set and contain at least one entry.");
          }
          const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
          this.conn.send(JSON.stringify({ clientContent }));
        });
      }
      /**
          Sets a configuration to the model. Updates the session's current
          music generation config.
      
          @param params - Contains one property, `musicGenerationConfig`.
      
            - `musicGenerationConfig` to set in the model. Passing an empty or
          undefined config to the model will reset the config to defaults.
      
          @experimental
         */
      setMusicGenerationConfig(params) {
        return __async(this, null, function* () {
          if (!params.musicGenerationConfig) {
            params.musicGenerationConfig = {};
          }
          const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
          this.conn.send(JSON.stringify(setConfigParameters));
        });
      }
      sendPlaybackControl(playbackControl) {
        const clientMessage = { playbackControl };
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
       * Start the music stream.
       *
       * @experimental
       */
      play() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
      }
      /**
       * Temporarily halt the music stream. Use `play` to resume from the current
       * position.
       *
       * @experimental
       */
      pause() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
      }
      /**
       * Stop the music stream and reset the state. Retains the current prompts
       * and config.
       *
       * @experimental
       */
      stop() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
      }
      /**
       * Resets the context of the music generation without stopping it.
       * Retains the current prompts and config.
       *
       * @experimental
       */
      resetContext() {
        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
         */
      close() {
        this.conn.close();
      }
    }
    function headersToMap$1(headers) {
      const headerMap = {};
      headers.forEach((value, key) => {
        headerMap[key] = value;
      });
      return headerMap;
    }
    function mapToHeaders$1(map) {
      const headers = new Headers();
      for (const [key, value] of Object.entries(map)) {
        headers.append(key, value);
      }
      return headers;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
    function handleWebSocketMessage(apiClient, onmessage, event) {
      return __async(this, null, function* () {
        const serverMessage = new LiveServerMessage();
        let jsonData;
        if (event.data instanceof Blob) {
          jsonData = yield event.data.text();
        } else if (event.data instanceof ArrayBuffer) {
          jsonData = new TextDecoder().decode(event.data);
        } else {
          jsonData = event.data;
        }
        const data = JSON.parse(jsonData);
        if (apiClient.isVertexAI()) {
          const resp = liveServerMessageFromVertex(data);
          Object.assign(serverMessage, resp);
        } else {
          const resp = data;
          Object.assign(serverMessage, resp);
        }
        onmessage(serverMessage);
      });
    }
    class Live {
      constructor(apiClient, auth2, webSocketFactory) {
        this.apiClient = apiClient;
        this.auth = auth2;
        this.webSocketFactory = webSocketFactory;
        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
      }
      /**
           Establishes a connection to the specified model with the given
           configuration and returns a Session object representing that connection.
      
           @experimental Built-in MCP support is an experimental feature, may change in
           future versions.
      
           @remarks
      
           @param params - The parameters for establishing a connection to the model.
           @return A live session.
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             },
             callbacks: {
               onopen: () => {
                 console.log('Connected to the socket.');
               },
               onmessage: (e: MessageEvent) => {
                 console.log('Received message from the server: %s\n', debug(e.data));
               },
               onerror: (e: ErrorEvent) => {
                 console.log('Error occurred: %s\n', debug(e.error));
               },
               onclose: (e: CloseEvent) => {
                 console.log('Connection closed.');
               },
             },
           });
           ```
          */
      connect(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d, _e, _f;
          if (params.config && params.config.httpOptions) {
            throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
          }
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          let url;
          const clientHeaders = this.apiClient.getHeaders();
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            setMcpUsageHeader(clientHeaders);
          }
          const headers = mapToHeaders(clientHeaders);
          if (this.apiClient.isVertexAI()) {
            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
            yield this.auth.addAuthHeaders(headers, url);
          } else {
            const apiKey2 = this.apiClient.getApiKey();
            let method = "BidiGenerateContent";
            let keyName = "key";
            if (apiKey2 === null || apiKey2 === void 0 ? void 0 : apiKey2.startsWith("auth_tokens/")) {
              console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
              if (apiVersion !== "v1alpha") {
                console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
              }
              method = "BidiGenerateContentConstrained";
              keyName = "access_token";
            }
            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey2}`;
          }
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            var _a2;
            (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
          conn.connect();
          yield onopenPromise;
          let transformedModel = tModel(this.apiClient, params.model);
          if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
            const project = this.apiClient.getProject();
            const location = this.apiClient.getLocation();
            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
          }
          let clientMessage = {};
          if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
            if (params.config === void 0) {
              params.config = { responseModalities: [Modality.AUDIO] };
            } else {
              params.config.responseModalities = [Modality.AUDIO];
            }
          }
          if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
            console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
          }
          const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
          const convertedTools = [];
          for (const tool of inputTools) {
            if (this.isCallableTool(tool)) {
              const callableTool = tool;
              convertedTools.push(yield callableTool.tool());
            } else {
              convertedTools.push(tool);
            }
          }
          if (convertedTools.length > 0) {
            params.config.tools = convertedTools;
          }
          const liveConnectParameters = {
            model: transformedModel,
            config: params.config,
            callbacks: params.callbacks
          };
          if (this.apiClient.isVertexAI()) {
            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
          } else {
            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
          }
          delete clientMessage["config"];
          conn.send(JSON.stringify(clientMessage));
          return new Session(conn, this.apiClient);
        });
      }
      // TODO: b/416041229 - Abstract this method to a common place.
      isCallableTool(tool) {
        return "callTool" in tool && typeof tool.callTool === "function";
      }
    }
    const defaultLiveSendClientContentParamerters = {
      turnComplete: true
    };
    class Session {
      constructor(conn, apiClient) {
        this.conn = conn;
        this.apiClient = apiClient;
      }
      tLiveClientContent(apiClient, params) {
        if (params.turns !== null && params.turns !== void 0) {
          let contents = [];
          try {
            contents = tContents(params.turns);
            if (!apiClient.isVertexAI()) {
              contents = contents.map((item) => contentToMldev$1(item));
            }
          } catch (_a) {
            throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
          }
          return {
            clientContent: { turns: contents, turnComplete: params.turnComplete }
          };
        }
        return {
          clientContent: { turnComplete: params.turnComplete }
        };
      }
      tLiveClienttToolResponse(apiClient, params) {
        let functionResponses = [];
        if (params.functionResponses == null) {
          throw new Error("functionResponses is required.");
        }
        if (!Array.isArray(params.functionResponses)) {
          functionResponses = [params.functionResponses];
        } else {
          functionResponses = params.functionResponses;
        }
        if (functionResponses.length === 0) {
          throw new Error("functionResponses is required.");
        }
        for (const functionResponse of functionResponses) {
          if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
            throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
          }
          if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
            throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
          }
        }
        const clientMessage = {
          toolResponse: { functionResponses }
        };
        return clientMessage;
      }
      /**
          Send a message over the established connection.
      
          @param params - Contains two **optional** properties, `turns` and
              `turnComplete`.
      
            - `turns` will be converted to a `Content[]`
            - `turnComplete: true` [default] indicates that you are done sending
              content and expect a response. If `turnComplete: false`, the server
              will wait for additional messages before starting generation.
      
          @experimental
      
          @remarks
          There are two ways to send messages to the live API:
          `sendClientContent` and `sendRealtimeInput`.
      
          `sendClientContent` messages are added to the model context **in order**.
          Having a conversation using `sendClientContent` messages is roughly
          equivalent to using the `Chat.sendMessageStream`, except that the state of
          the `chat` history is stored on the API server instead of locally.
      
          Because of `sendClientContent`'s order guarantee, the model cannot respons
          as quickly to `sendClientContent` messages as to `sendRealtimeInput`
          messages. This makes the biggest difference when sending objects that have
          significant preprocessing time (typically images).
      
          The `sendClientContent` message sends a `Content[]`
          which has more options than the `Blob` sent by `sendRealtimeInput`.
      
          So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
      
          - Sending anything that can't be represented as a `Blob` (text,
          `sendClientContent({turns="Hello?"}`)).
          - Managing turns when not using audio input and voice activity detection.
            (`sendClientContent({turnComplete:true})` or the short form
          `sendClientContent()`)
          - Prefilling a conversation context
            ```
            sendClientContent({
                turns: [
                  Content({role:user, parts:...}),
                  Content({role:user, parts:...}),
                  ...
                ]
            })
            ```
          @experimental
         */
      sendClientContent(params) {
        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
        const clientMessage = this.tLiveClientContent(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a realtime message over the established connection.
      
          @param params - Contains one property, `media`.
      
            - `media` will be converted to a `Blob`
      
          @experimental
      
          @remarks
          Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
      
          With `sendRealtimeInput` the api will respond to audio automatically
          based on voice activity detection (VAD).
      
          `sendRealtimeInput` is optimized for responsivness at the expense of
          deterministic ordering guarantees. Audio and video tokens are to the
          context when they become available.
      
          Note: The Call signature expects a `Blob` object, but only a subset
          of audio and image mimetypes are allowed.
         */
      sendRealtimeInput(params) {
        let clientMessage = {};
        if (this.apiClient.isVertexAI()) {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
          };
        } else {
          clientMessage = {
            "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
          };
        }
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
          Send a function response message over the established connection.
      
          @param params - Contains property `functionResponses`.
      
            - `functionResponses` will be converted to a `functionResponses[]`
      
          @remarks
          Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
      
          Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
      
          @experimental
         */
      sendToolResponse(params) {
        if (params.functionResponses == null) {
          throw new Error("Tool response parameters are required.");
        }
        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
        this.conn.send(JSON.stringify(clientMessage));
      }
      /**
           Terminates the WebSocket connection.
      
           @experimental
      
           @example
           ```ts
           let model: string;
           if (GOOGLE_GENAI_USE_VERTEXAI) {
             model = 'gemini-2.0-flash-live-preview-04-09';
           } else {
             model = 'gemini-live-2.5-flash-preview';
           }
           const session = await ai.live.connect({
             model: model,
             config: {
               responseModalities: [Modality.AUDIO],
             }
           });
      
           session.close();
           ```
         */
      close() {
        this.conn.close();
      }
    }
    function headersToMap(headers) {
      const headerMap = {};
      headers.forEach((value, key) => {
        headerMap[key] = value;
      });
      return headerMap;
    }
    function mapToHeaders(map) {
      const headers = new Headers();
      for (const [key, value] of Object.entries(map)) {
        headers.append(key, value);
      }
      return headers;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const DEFAULT_MAX_REMOTE_CALLS = 10;
    function shouldDisableAfc(config) {
      var _a, _b, _c;
      if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
        return true;
      }
      let callableToolsPresent = false;
      for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
        if (isCallableTool(tool)) {
          callableToolsPresent = true;
          break;
        }
      }
      if (!callableToolsPresent) {
        return true;
      }
      const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
      if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
        console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
        return true;
      }
      return false;
    }
    function isCallableTool(tool) {
      return "callTool" in tool && typeof tool.callTool === "function";
    }
    function hasCallableTools(params) {
      var _a, _b, _c;
      return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
    }
    function findAfcIncompatibleToolIndexes(params) {
      var _a;
      const afcIncompatibleToolIndexes = [];
      if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {
        return afcIncompatibleToolIndexes;
      }
      params.config.tools.forEach((tool, index) => {
        if (isCallableTool(tool)) {
          return;
        }
        const geminiTool = tool;
        if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
          afcIncompatibleToolIndexes.push(index);
        }
      });
      return afcIncompatibleToolIndexes;
    }
    function shouldAppendAfcHistory(config) {
      var _a;
      return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Models extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.generateContent = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e;
          const transformedParams = yield this.processParamsMaybeAddMcpUsage(params);
          this.maybeMoveToResponseJsonSchem(params);
          if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
            return yield this.generateContentInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
          }
          let response;
          let functionResponseContent;
          const automaticFunctionCallingHistory = tContents(transformedParams.contents);
          const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let remoteCalls = 0;
          while (remoteCalls < maxRemoteCalls) {
            response = yield this.generateContentInternal(transformedParams);
            if (!response.functionCalls || response.functionCalls.length === 0) {
              break;
            }
            const responseContent = response.candidates[0].content;
            const functionResponseParts = [];
            for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
              if (isCallableTool(tool)) {
                const callableTool = tool;
                const parts = yield callableTool.callTool(response.functionCalls);
                functionResponseParts.push(...parts);
              }
            }
            remoteCalls++;
            functionResponseContent = {
              role: "user",
              parts: functionResponseParts
            };
            transformedParams.contents = tContents(transformedParams.contents);
            transformedParams.contents.push(responseContent);
            transformedParams.contents.push(functionResponseContent);
            if (shouldAppendAfcHistory(transformedParams.config)) {
              automaticFunctionCallingHistory.push(responseContent);
              automaticFunctionCallingHistory.push(functionResponseContent);
            }
          }
          if (shouldAppendAfcHistory(transformedParams.config)) {
            response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
          }
          return response;
        });
        this.generateContentStream = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e;
          this.maybeMoveToResponseJsonSchem(params);
          if (shouldDisableAfc(params.config)) {
            const transformedParams = yield this.processParamsMaybeAddMcpUsage(params);
            return yield this.generateContentStreamInternal(transformedParams);
          }
          const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
          if (incompatibleToolIndexes.length > 0) {
            const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
            throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
          }
          const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
          const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
          if (streamFunctionCall && !disableAfc) {
            throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
          }
          return yield this.processAfcStream(params);
        });
        this.generateImages = (params) => __async(this, null, function* () {
          return yield this.generateImagesInternal(params).then((apiResponse) => {
            var _a;
            let positivePromptSafetyAttributes;
            const generatedImages = [];
            if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
              for (const generatedImage of apiResponse.generatedImages) {
                if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                  positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
                } else {
                  generatedImages.push(generatedImage);
                }
              }
            }
            let response;
            if (positivePromptSafetyAttributes) {
              response = {
                generatedImages,
                positivePromptSafetyAttributes,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            } else {
              response = {
                generatedImages,
                sdkHttpResponse: apiResponse.sdkHttpResponse
              };
            }
            return response;
          });
        });
        this.list = (params) => __async(this, null, function* () {
          var _a;
          const defaultConfig = {
            queryBase: true
          };
          const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
          const actualParams = {
            config: actualConfig
          };
          if (this.apiClient.isVertexAI()) {
            if (!actualParams.config.queryBase) {
              if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
                throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
              } else {
                actualParams.config.filter = "labels.tune-type:*";
              }
            }
          }
          return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), yield this.listInternal(actualParams), actualParams);
        });
        this.editImage = (params) => __async(this, null, function* () {
          const paramsInternal = {
            model: params.model,
            prompt: params.prompt,
            referenceImages: [],
            config: params.config
          };
          if (params.referenceImages) {
            if (params.referenceImages) {
              paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
            }
          }
          return yield this.editImageInternal(paramsInternal);
        });
        this.upscaleImage = (params) => __async(this, null, function* () {
          let apiConfig = {
            numberOfImages: 1,
            mode: "upscale"
          };
          if (params.config) {
            apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
          }
          const apiParams = {
            model: params.model,
            image: params.image,
            upscaleFactor: params.upscaleFactor,
            config: apiConfig
          };
          return yield this.upscaleImageInternal(apiParams);
        });
        this.generateVideos = (params) => __async(this, null, function* () {
          var _a, _b, _c, _d, _e, _f;
          if ((params.prompt || params.image || params.video) && params.source) {
            throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
          }
          if (!this.apiClient.isVertexAI()) {
            if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
              params.video = {
                uri: params.video.uri,
                mimeType: params.video.mimeType
              };
            } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
              params.source.video = {
                uri: params.source.video.uri,
                mimeType: params.source.video.mimeType
              };
            }
          }
          return yield this.generateVideosInternal(params);
        });
      }
      /**
       * This logic is needed for GenerateContentConfig only.
       * Previously we made GenerateContentConfig.responseSchema field to accept
       * unknown. Since v1.9.0, we switch to use backend JSON schema support.
       * To maintain backward compatibility, we move the data that was treated as
       * JSON schema from the responseSchema field to the responseJsonSchema field.
       */
      maybeMoveToResponseJsonSchem(params) {
        if (params.config && params.config.responseSchema) {
          if (!params.config.responseJsonSchema) {
            if (Object.keys(params.config.responseSchema).includes("$schema")) {
              params.config.responseJsonSchema = params.config.responseSchema;
              delete params.config.responseSchema;
            }
          }
        }
        return;
      }
      /**
       * Transforms the CallableTools in the parameters to be simply Tools, it
       * copies the params into a new object and replaces the tools, it does not
       * modify the original params. Also sets the MCP usage header if there are
       * MCP tools in the parameters.
       */
      processParamsMaybeAddMcpUsage(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
          if (!tools) {
            return params;
          }
          const transformedTools = yield Promise.all(tools.map((tool) => __async(null, null, function* () {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              return yield callableTool.tool();
            }
            return tool;
          })));
          const newParams = {
            model: params.model,
            contents: params.contents,
            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
          };
          newParams.config.tools = transformedTools;
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
            let newHeaders = Object.assign({}, headers);
            if (Object.keys(newHeaders).length === 0) {
              newHeaders = this.apiClient.getDefaultHeaders();
            }
            setMcpUsageHeader(newHeaders);
            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
          }
          return newParams;
        });
      }
      initAfcToolsMap(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const afcTools = /* @__PURE__ */ new Map();
          for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const toolDeclaration = yield callableTool.tool();
              for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
                if (!declaration.name) {
                  throw new Error("Function declaration name is required.");
                }
                if (afcTools.has(declaration.name)) {
                  throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
                }
                afcTools.set(declaration.name, callableTool);
              }
            }
          }
          return afcTools;
        });
      }
      processAfcStream(params) {
        return __async(this, null, function* () {
          var _a, _b, _c;
          const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let wereFunctionsCalled = false;
          let remoteCallCount = 0;
          const afcToolsMap = yield this.initAfcToolsMap(params);
          return (function(models, afcTools, params2) {
            var _a2, _b2;
            return __asyncGenerator(this, arguments, function* () {
              var _c2, e_1, _d, _e;
              while (remoteCallCount < maxRemoteCalls) {
                if (wereFunctionsCalled) {
                  remoteCallCount++;
                  wereFunctionsCalled = false;
                }
                const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
                const response = yield __await(models.generateContentStreamInternal(transformedParams));
                const functionResponses = [];
                const responseContents = [];
                try {
                  for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                    _e = response_1_1.value;
                    _f = false;
                    const chunk = _e;
                    yield yield __await(chunk);
                    if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                      responseContents.push(chunk.candidates[0].content);
                      for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                        if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                          if (!part.functionCall.name) {
                            throw new Error("Function call name was not returned by the model.");
                          }
                          if (!afcTools.has(part.functionCall.name)) {
                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                          } else {
                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                            functionResponses.push(...responseParts);
                          }
                        }
                      }
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (!_f && !_c2 && (_d = response_1.return)) yield __await(_d.call(response_1));
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                if (functionResponses.length > 0) {
                  wereFunctionsCalled = true;
                  const typedResponseChunk = new GenerateContentResponse();
                  typedResponseChunk.candidates = [
                    {
                      content: {
                        role: "user",
                        parts: functionResponses
                      }
                    }
                  ];
                  yield yield __await(typedResponseChunk);
                  const newContents = [];
                  newContents.push(...responseContents);
                  newContents.push({
                    role: "user",
                    parts: functionResponses
                  });
                  const updatedContents = tContents(params2.contents).concat(newContents);
                  params2.contents = updatedContents;
                } else {
                  break;
                }
              }
            });
          })(this, afcToolsMap, params);
        });
      }
      generateContentInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromVertex(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromMldev(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      generateContentStreamInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_2, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_1_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
              });
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_3, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_2_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
                  } finally {
                    if (e_3) throw e_3.error;
                  }
                }
              });
            });
          }
        });
      }
      /**
       * Calculates embeddings for the given contents. Only text is supported.
       *
       * @param params - The parameters for embedding contents.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.embedContent({
       *  model: 'text-embedding-004',
       *  contents: [
       *    'What is your name?',
       *    'What is your favorite color?',
       *  ],
       *  config: {
       *    outputDimensionality: 64,
       *  },
       * });
       * console.log(response);
       * ```
       */
      embedContent(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = embedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromVertex(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = embedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchEmbedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromMldev(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Private method for generating images.
       */
      generateImagesInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateImagesParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromVertex(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateImagesParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromMldev(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Private method for editing an image.
       */
      editImageInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = editImageParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = editImageResponseFromVertex(apiResponse);
              const typedResp = new EditImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Private method for upscaling an image.
       */
      upscaleImageInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = upscaleImageResponseFromVertex(apiResponse);
              const typedResp = new UpscaleImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Recontextualizes an image.
       *
       * There are two types of recontextualization currently supported:
       * 1) Imagen Product Recontext - Generate images of products in new scenes
       *    and contexts.
       * 2) Virtual Try-On: Generate images of persons modeling fashion products.
       *
       * @param params - The parameters for recontextualizing an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response1 = await ai.models.recontextImage({
       *  model: 'imagen-product-recontext-preview-06-30',
       *  source: {
       *    prompt: 'In a modern kitchen setting.',
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
       *
       * const response2 = await ai.models.recontextImage({
       *  model: 'virtual-try-on-preview-08-04',
       *  source: {
       *    personImage: personImage,
       *    productImages: [productImage],
       *  },
       *  config: {
       *    numberOfImages: 1,
       *  },
       * });
       * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
       * ```
       */
      recontextImage(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = recontextImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = recontextImageResponseFromVertex(apiResponse);
              const typedResp = new RecontextImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Segments an image, creating a mask of a specified area.
       *
       * @param params - The parameters for segmenting an image.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.segmentImage({
       *  model: 'image-segmentation-001',
       *  source: {
       *    image: image,
       *  },
       *  config: {
       *    mode: 'foreground',
       *  },
       * });
       * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
       * ```
       */
      segmentImage(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = segmentImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = segmentImageResponseFromVertex(apiResponse);
              const typedResp = new SegmentImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Fetches information about a model by name.
       *
       * @example
       * ```ts
       * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
       * ```
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listModelsParametersToVertex(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromVertex(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listModelsParametersToMldev(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromMldev(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Updates a tuned model by its name.
       *
       * @param params - The parameters for updating the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.update({
       *   model: 'tuned-model-name',
       *   config: {
       *     displayName: 'New display name',
       *     description: 'New description',
       *   },
       * });
       * ```
       */
      update(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateModelParametersToVertex(this.apiClient, params);
            path = formatMap("{model}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = updateModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a tuned model by its name.
       *
       * @param params - The parameters for deleting the model.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.delete({model: 'tuned-model-name'});
       * ```
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromVertex(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromMldev(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Counts the number of tokens in the given contents. Multimodal input is
       * supported for Gemini models.
       *
       * @param params - The parameters for counting tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.countTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'The quick brown fox jumps over the lazy dog.'
       * });
       * console.log(response);
       * ```
       */
      countTokens(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = countTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromVertex(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = countTokensParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromMldev(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Given a list of contents, returns a corresponding TokensInfo containing
       * the list of tokens and list of token ids.
       *
       * This method is not supported by the Gemini Developer API.
       *
       * @param params - The parameters for computing tokens.
       * @return The response from the API.
       *
       * @example
       * ```ts
       * const response = await ai.models.computeTokens({
       *  model: 'gemini-2.0-flash',
       *  contents: 'What is your name?'
       * });
       * console.log(response);
       * ```
       */
      computeTokens(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = computeTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:computeTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = computeTokensResponseFromVertex(apiResponse);
              const typedResp = new ComputeTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      /**
       * Private method for generating videos.
       */
      generateVideosInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateVideosParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateVideosParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromMldev(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Operations extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      getVideosOperation(parameters) {
        return __async(this, null, function* () {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = yield this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = yield this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        });
      }
      /**
       * Gets the status of a long-running operation.
       *
       * @param parameters The parameters for the get operation request.
       * @return The updated Operation object, with the latest status or result.
       */
      get(parameters) {
        return __async(this, null, function* () {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = yield this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = yield this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        });
      }
      getVideosOperationInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getOperationParametersToVertex(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            const body = getOperationParametersToMldev(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          }
        });
      }
      fetchPredictVideosOperationInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = fetchPredictOperationParametersToVertex(params);
            path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function blobToMldev(fromObject) {
      const toObject = {};
      const fromData = getValueByPath(fromObject, ["data"]);
      if (fromData != null) {
        setValueByPath(toObject, ["data"], fromData);
      }
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function contentToMldev(fromObject) {
      const toObject = {};
      const fromParts = getValueByPath(fromObject, ["parts"]);
      if (fromParts != null) {
        let transformedList = fromParts;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return partToMldev(item);
          });
        }
        setValueByPath(toObject, ["parts"], transformedList);
      }
      const fromRole = getValueByPath(fromObject, ["role"]);
      if (fromRole != null) {
        setValueByPath(toObject, ["role"], fromRole);
      }
      return toObject;
    }
    function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
      const toObject = {};
      const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
      if (parentObject !== void 0 && fromExpireTime != null) {
        setValueByPath(parentObject, ["expireTime"], fromExpireTime);
      }
      const fromNewSessionExpireTime = getValueByPath(fromObject, [
        "newSessionExpireTime"
      ]);
      if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
        setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
      }
      const fromUses = getValueByPath(fromObject, ["uses"]);
      if (parentObject !== void 0 && fromUses != null) {
        setValueByPath(parentObject, ["uses"], fromUses);
      }
      const fromLiveConnectConstraints = getValueByPath(fromObject, [
        "liveConnectConstraints"
      ]);
      if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
        setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
      }
      const fromLockAdditionalFields = getValueByPath(fromObject, [
        "lockAdditionalFields"
      ]);
      if (parentObject !== void 0 && fromLockAdditionalFields != null) {
        setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
      }
      return toObject;
    }
    function createAuthTokenParametersToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
      }
      return toObject;
    }
    function fileDataToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
        throw new Error("displayName parameter is not supported in Gemini API.");
      }
      const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
      if (fromFileUri != null) {
        setValueByPath(toObject, ["fileUri"], fromFileUri);
      }
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (fromMimeType != null) {
        setValueByPath(toObject, ["mimeType"], fromMimeType);
      }
      return toObject;
    }
    function functionCallToMldev(fromObject) {
      const toObject = {};
      const fromId = getValueByPath(fromObject, ["id"]);
      if (fromId != null) {
        setValueByPath(toObject, ["id"], fromId);
      }
      const fromArgs = getValueByPath(fromObject, ["args"]);
      if (fromArgs != null) {
        setValueByPath(toObject, ["args"], fromArgs);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
        throw new Error("partialArgs parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
        throw new Error("willContinue parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function googleMapsToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
        throw new Error("authConfig parameter is not supported in Gemini API.");
      }
      const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
      if (fromEnableWidget != null) {
        setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
      }
      return toObject;
    }
    function googleSearchToMldev(fromObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
        throw new Error("excludeDomains parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
        throw new Error("blockingConfidence parameter is not supported in Gemini API.");
      }
      const fromTimeRangeFilter = getValueByPath(fromObject, [
        "timeRangeFilter"
      ]);
      if (fromTimeRangeFilter != null) {
        setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
      }
      return toObject;
    }
    function liveConnectConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromGenerationConfig = getValueByPath(fromObject, [
        "generationConfig"
      ]);
      if (parentObject !== void 0 && fromGenerationConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
      }
      const fromResponseModalities = getValueByPath(fromObject, [
        "responseModalities"
      ]);
      if (parentObject !== void 0 && fromResponseModalities != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
      }
      const fromTemperature = getValueByPath(fromObject, ["temperature"]);
      if (parentObject !== void 0 && fromTemperature != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
      }
      const fromTopP = getValueByPath(fromObject, ["topP"]);
      if (parentObject !== void 0 && fromTopP != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
      }
      const fromTopK = getValueByPath(fromObject, ["topK"]);
      if (parentObject !== void 0 && fromTopK != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
      }
      const fromMaxOutputTokens = getValueByPath(fromObject, [
        "maxOutputTokens"
      ]);
      if (parentObject !== void 0 && fromMaxOutputTokens != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
      }
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (parentObject !== void 0 && fromMediaResolution != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
      }
      const fromSeed = getValueByPath(fromObject, ["seed"]);
      if (parentObject !== void 0 && fromSeed != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
      }
      const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
      if (parentObject !== void 0 && fromSpeechConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
      }
      const fromThinkingConfig = getValueByPath(fromObject, [
        "thinkingConfig"
      ]);
      if (parentObject !== void 0 && fromThinkingConfig != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
      }
      const fromEnableAffectiveDialog = getValueByPath(fromObject, [
        "enableAffectiveDialog"
      ]);
      if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
        setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
      }
      const fromSystemInstruction = getValueByPath(fromObject, [
        "systemInstruction"
      ]);
      if (parentObject !== void 0 && fromSystemInstruction != null) {
        setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
      }
      const fromTools = getValueByPath(fromObject, ["tools"]);
      if (parentObject !== void 0 && fromTools != null) {
        let transformedList = tTools(fromTools);
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return toolToMldev(tTool(item));
          });
        }
        setValueByPath(parentObject, ["setup", "tools"], transformedList);
      }
      const fromSessionResumption = getValueByPath(fromObject, [
        "sessionResumption"
      ]);
      if (parentObject !== void 0 && fromSessionResumption != null) {
        setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
      }
      const fromInputAudioTranscription = getValueByPath(fromObject, [
        "inputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromInputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
      }
      const fromOutputAudioTranscription = getValueByPath(fromObject, [
        "outputAudioTranscription"
      ]);
      if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
        setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
      }
      const fromRealtimeInputConfig = getValueByPath(fromObject, [
        "realtimeInputConfig"
      ]);
      if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
        setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
      }
      const fromContextWindowCompression = getValueByPath(fromObject, [
        "contextWindowCompression"
      ]);
      if (parentObject !== void 0 && fromContextWindowCompression != null) {
        setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
      }
      const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
      if (parentObject !== void 0 && fromProactivity != null) {
        setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
      }
      return toObject;
    }
    function liveConnectConstraintsToMldev(apiClient, fromObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["model"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
      }
      return toObject;
    }
    function partToMldev(fromObject) {
      const toObject = {};
      const fromMediaResolution = getValueByPath(fromObject, [
        "mediaResolution"
      ]);
      if (fromMediaResolution != null) {
        setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
      }
      const fromCodeExecutionResult = getValueByPath(fromObject, [
        "codeExecutionResult"
      ]);
      if (fromCodeExecutionResult != null) {
        setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
      }
      const fromExecutableCode = getValueByPath(fromObject, [
        "executableCode"
      ]);
      if (fromExecutableCode != null) {
        setValueByPath(toObject, ["executableCode"], fromExecutableCode);
      }
      const fromFileData = getValueByPath(fromObject, ["fileData"]);
      if (fromFileData != null) {
        setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
      }
      const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
      if (fromFunctionCall != null) {
        setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
      }
      const fromFunctionResponse = getValueByPath(fromObject, [
        "functionResponse"
      ]);
      if (fromFunctionResponse != null) {
        setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
      }
      const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
      if (fromInlineData != null) {
        setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
      }
      const fromText = getValueByPath(fromObject, ["text"]);
      if (fromText != null) {
        setValueByPath(toObject, ["text"], fromText);
      }
      const fromThought = getValueByPath(fromObject, ["thought"]);
      if (fromThought != null) {
        setValueByPath(toObject, ["thought"], fromThought);
      }
      const fromThoughtSignature = getValueByPath(fromObject, [
        "thoughtSignature"
      ]);
      if (fromThoughtSignature != null) {
        setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
      }
      const fromVideoMetadata = getValueByPath(fromObject, [
        "videoMetadata"
      ]);
      if (fromVideoMetadata != null) {
        setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
      }
      return toObject;
    }
    function sessionResumptionConfigToMldev(fromObject) {
      const toObject = {};
      const fromHandle = getValueByPath(fromObject, ["handle"]);
      if (fromHandle != null) {
        setValueByPath(toObject, ["handle"], fromHandle);
      }
      if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
        throw new Error("transparent parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function toolToMldev(fromObject) {
      const toObject = {};
      const fromFunctionDeclarations = getValueByPath(fromObject, [
        "functionDeclarations"
      ]);
      if (fromFunctionDeclarations != null) {
        let transformedList = fromFunctionDeclarations;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["functionDeclarations"], transformedList);
      }
      if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
        throw new Error("retrieval parameter is not supported in Gemini API.");
      }
      const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
        "googleSearchRetrieval"
      ]);
      if (fromGoogleSearchRetrieval != null) {
        setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
      }
      const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
      if (fromComputerUse != null) {
        setValueByPath(toObject, ["computerUse"], fromComputerUse);
      }
      const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
      if (fromFileSearch != null) {
        setValueByPath(toObject, ["fileSearch"], fromFileSearch);
      }
      const fromCodeExecution = getValueByPath(fromObject, [
        "codeExecution"
      ]);
      if (fromCodeExecution != null) {
        setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
      }
      if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
        throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
      }
      const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
      if (fromGoogleMaps != null) {
        setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
      }
      const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
      if (fromGoogleSearch != null) {
        setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
      }
      const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
      if (fromUrlContext != null) {
        setValueByPath(toObject, ["urlContext"], fromUrlContext);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function getFieldMasks(setup) {
      const fields = [];
      for (const key in setup) {
        if (Object.prototype.hasOwnProperty.call(setup, key)) {
          const value = setup[key];
          if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
            const field = Object.keys(value).map((kk) => `${key}.${kk}`);
            fields.push(...field);
          } else {
            fields.push(key);
          }
        }
      }
      return fields.join(",");
    }
    function convertBidiSetupToTokenSetup(requestDict, config) {
      let setupForMaskGeneration = null;
      const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
      if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
        const innerSetup = bidiGenerateContentSetupValue.setup;
        if (typeof innerSetup === "object" && innerSetup !== null) {
          requestDict["bidiGenerateContentSetup"] = innerSetup;
          setupForMaskGeneration = innerSetup;
        } else {
          delete requestDict["bidiGenerateContentSetup"];
        }
      } else if (bidiGenerateContentSetupValue !== void 0) {
        delete requestDict["bidiGenerateContentSetup"];
      }
      const preExistingFieldMask = requestDict["fieldMask"];
      if (setupForMaskGeneration) {
        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
          if (generatedMaskFromBidi) {
            requestDict["fieldMask"] = generatedMaskFromBidi;
          } else {
            delete requestDict["fieldMask"];
          }
        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
          const generationConfigFields = [
            "temperature",
            "topK",
            "topP",
            "maxOutputTokens",
            "responseModalities",
            "seed",
            "speechConfig"
          ];
          let mappedFieldsFromPreExisting = [];
          if (preExistingFieldMask.length > 0) {
            mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
              if (generationConfigFields.includes(field)) {
                return `generationConfig.${field}`;
              }
              return field;
            });
          }
          const finalMaskParts = [];
          if (generatedMaskFromBidi) {
            finalMaskParts.push(generatedMaskFromBidi);
          }
          if (mappedFieldsFromPreExisting.length > 0) {
            finalMaskParts.push(...mappedFieldsFromPreExisting);
          }
          if (finalMaskParts.length > 0) {
            requestDict["fieldMask"] = finalMaskParts.join(",");
          } else {
            delete requestDict["fieldMask"];
          }
        } else {
          delete requestDict["fieldMask"];
        }
      } else {
        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
          requestDict["fieldMask"] = preExistingFieldMask.join(",");
        } else {
          delete requestDict["fieldMask"];
        }
      }
      return requestDict;
    }
    class Tokens extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
      }
      /**
       * Creates an ephemeral auth token resource.
       *
       * @experimental
       *
       * @remarks
       * Ephemeral auth tokens is only supported in the Gemini Developer API.
       * It can be used for the session connection to the Live constrained API.
       * Support in v1alpha only.
       *
       * @param params - The parameters for the create request.
       * @return The created auth token.
       *
       * @example
       * ```ts
       * const ai = new GoogleGenAI({
       *     apiKey: token.name,
       *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
       * });
       *
       * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
       * // when using the token in Live API sessions. Each session connection can
       * // use a different configuration.
       * const config: CreateAuthTokenConfig = {
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 2: If LiveEphemeralParameters is set, lock all fields in
       * // LiveConnectConfig when using the token in Live API sessions. For
       * // example, changing `outputAudioTranscription` in the Live API
       * // connection will be ignored by the API.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     }
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // set, lock LiveConnectConfig with set and additional fields (e.g.
       * // responseModalities, systemInstruction, temperature in this example) when
       * // using the token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: ['temperature'],
       * }
       * const token = await ai.tokens.create(config);
       *
       * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
       * // empty array, lock LiveConnectConfig with set fields (e.g.
       * // responseModalities, systemInstruction in this example) when using the
       * // token in Live API sessions.
       * const config: CreateAuthTokenConfig =
       *     uses: 3,
       *     expireTime: '2025-05-01T00:00:00Z',
       *     LiveEphemeralParameters: {
       *        model: 'gemini-2.0-flash-001',
       *        config: {
       *           'responseModalities': ['AUDIO'],
       *           'systemInstruction': 'Always answer in English.',
       *        }
       *     },
       *     lockAdditionalFields: [],
       * }
       * const token = await ai.tokens.create(config);
       * ```
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
          } else {
            const body = createAuthTokenParametersToMldev(this.apiClient, params);
            path = formatMap("auth_tokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(transformedBody),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      return toObject;
    }
    function createFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromForce = getValueByPath(fromObject, ["force"]);
      if (parentObject !== void 0 && fromForce != null) {
        setValueByPath(parentObject, ["_query", "force"], fromForce);
      }
      return toObject;
    }
    function deleteFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function getFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function importFileConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromCustomMetadata = getValueByPath(fromObject, [
        "customMetadata"
      ]);
      if (parentObject !== void 0 && fromCustomMetadata != null) {
        let transformedList = fromCustomMetadata;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["customMetadata"], transformedList);
      }
      const fromChunkingConfig = getValueByPath(fromObject, [
        "chunkingConfig"
      ]);
      if (parentObject !== void 0 && fromChunkingConfig != null) {
        setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
      }
      return toObject;
    }
    function importFileOperationFromMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromResponse = getValueByPath(fromObject, ["response"]);
      if (fromResponse != null) {
        setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
      }
      return toObject;
    }
    function importFileParametersToMldev(fromObject) {
      const toObject = {};
      const fromFileSearchStoreName = getValueByPath(fromObject, [
        "fileSearchStoreName"
      ]);
      if (fromFileSearchStoreName != null) {
        setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
      }
      const fromFileName = getValueByPath(fromObject, ["fileName"]);
      if (fromFileName != null) {
        setValueByPath(toObject, ["fileName"], fromFileName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        importFileConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function importFileResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["parent"], fromParent);
      }
      const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
      if (fromDocumentName != null) {
        setValueByPath(toObject, ["documentName"], fromDocumentName);
      }
      return toObject;
    }
    function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listFileSearchStoresParametersToMldev(fromObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listFileSearchStoresConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listFileSearchStoresResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromFileSearchStores = getValueByPath(fromObject, [
        "fileSearchStores"
      ]);
      if (fromFileSearchStores != null) {
        let transformedList = fromFileSearchStores;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["fileSearchStores"], transformedList);
      }
      return toObject;
    }
    function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
      if (parentObject !== void 0 && fromMimeType != null) {
        setValueByPath(parentObject, ["mimeType"], fromMimeType);
      }
      const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
      if (parentObject !== void 0 && fromDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromDisplayName);
      }
      const fromCustomMetadata = getValueByPath(fromObject, [
        "customMetadata"
      ]);
      if (parentObject !== void 0 && fromCustomMetadata != null) {
        let transformedList = fromCustomMetadata;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(parentObject, ["customMetadata"], transformedList);
      }
      const fromChunkingConfig = getValueByPath(fromObject, [
        "chunkingConfig"
      ]);
      if (parentObject !== void 0 && fromChunkingConfig != null) {
        setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
      }
      return toObject;
    }
    function uploadToFileSearchStoreParametersToMldev(fromObject) {
      const toObject = {};
      const fromFileSearchStoreName = getValueByPath(fromObject, [
        "fileSearchStoreName"
      ]);
      if (fromFileSearchStoreName != null) {
        setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function deleteDocumentConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromForce = getValueByPath(fromObject, ["force"]);
      if (parentObject !== void 0 && fromForce != null) {
        setValueByPath(parentObject, ["_query", "force"], fromForce);
      }
      return toObject;
    }
    function deleteDocumentParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        deleteDocumentConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function getDocumentParametersToMldev(fromObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function listDocumentsConfigToMldev(fromObject, parentObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      return toObject;
    }
    function listDocumentsParametersToMldev(fromObject) {
      const toObject = {};
      const fromParent = getValueByPath(fromObject, ["parent"]);
      if (fromParent != null) {
        setValueByPath(toObject, ["_url", "parent"], fromParent);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listDocumentsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listDocumentsResponseFromMldev(fromObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromDocuments = getValueByPath(fromObject, ["documents"]);
      if (fromDocuments != null) {
        let transformedList = fromDocuments;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["documents"], transformedList);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Documents extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.list = (params) => __async(this, null, function* () {
          return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({
            parent: params.parent,
            config: x.config
          }), yield this.listInternal(params), params);
        });
      }
      /**
       * Gets a Document.
       *
       * @param params - The parameters for getting a document.
       * @return Document.
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a Document.
       *
       * @param params - The parameters for deleting a document.
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        });
      }
      /**
       * Lists all Documents in a FileSearchStore.
       *
       * @param params - The parameters for listing documents.
       * @return ListDocumentsResponse.
       */
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listDocumentsParametersToMldev(params);
            path = formatMap("{parent}/documents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listDocumentsResponseFromMldev(apiResponse);
              const typedResp = new ListDocumentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class FileSearchStores extends BaseModule {
      constructor(apiClient, documents = new Documents(apiClient)) {
        super();
        this.apiClient = apiClient;
        this.documents = documents;
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
      }
      /**
       * Uploads a file asynchronously to a given File Search Store.
       * This method is not available in Vertex AI.
       * Supported upload sources:
       * - Node.js: File path (string) or Blob object.
       * - Browser: Blob object (e.g., File).
       *
       * @remarks
       * The `mimeType` can be specified in the `config` parameter. If omitted:
       *  - For file path (string) inputs, the `mimeType` will be inferred from the
       *     file extension.
       *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
       *     property.
       *
       * This section can contain multiple paragraphs and code examples.
       *
       * @param params - Optional parameters specified in the
       *        `types.UploadToFileSearchStoreParameters` interface.
       *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
       *         config in the parameters.
       * @return A promise that resolves to a long running operation.
       * @throws An error if called on a Vertex AI client.
       * @throws An error if the `mimeType` is not provided and can not be inferred,
       * the `mimeType` can be provided in the `params.config` parameter.
       * @throws An error occurs if a suitable upload location cannot be established.
       *
       * @example
       * The following code uploads a file to a given file search store.
       *
       * ```ts
       * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
       *   mimeType: 'text/plain',
       * }});
       * console.log(operation.name);
       * ```
       */
      uploadToFileSearchStore(params) {
        return __async(this, null, function* () {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files to a file search store.");
          }
          return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
        });
      }
      /**
       * Creates a File Search Store.
       *
       * @param params - The parameters for creating a File Search Store.
       * @return FileSearchStore.
       */
      create(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileSearchStoreParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Gets a File Search Store.
       *
       * @param params - The parameters for getting a File Search Store.
       * @return FileSearchStore.
       */
      get(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        });
      }
      /**
       * Deletes a File Search Store.
       *
       * @param params - The parameters for deleting a File Search Store.
       */
      delete(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        });
      }
      /**
       * Lists all FileSearchStore owned by the user.
       *
       * @param params - The parameters for listing file search stores.
       * @return ListFileSearchStoresResponse.
       */
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFileSearchStoresParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listFileSearchStoresResponseFromMldev(apiResponse);
              const typedResp = new ListFileSearchStoresResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      uploadToFileSearchStoreInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = uploadToFileSearchStoreParametersToMldev(params);
            path = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
              const typedResp = new UploadToFileSearchStoreResumableResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Imports a File from File Service to a FileSearchStore.
       *
       * This is a long-running operation, see aip.dev/151
       *
       * @param params - The parameters for importing a file to a file search store.
       * @return ImportFileOperation.
       */
      importFile(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = importFileParametersToMldev(params);
            path = formatMap("{file_search_store_name}:importFile", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = importFileOperationFromMldev(apiResponse);
              const typedResp = new ImportFileOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
        throw new Error("validationDataset parameter is not supported in Gemini API.");
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
        setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
      }
      if (getValueByPath(fromObject, ["description"]) !== void 0) {
        throw new Error("description parameter is not supported in Gemini API.");
      }
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
      }
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (fromLearningRateMultiplier != null) {
        setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
      }
      if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
        throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
        throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
        throw new Error("adapterSize parameter is not supported in Gemini API.");
      }
      const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
      if (parentObject !== void 0 && fromBatchSize != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
      }
      const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
      if (parentObject !== void 0 && fromLearningRate != null) {
        setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
      }
      if (getValueByPath(fromObject, ["labels"]) !== void 0) {
        throw new Error("labels parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["beta"]) !== void 0) {
        throw new Error("beta parameter is not supported in Gemini API.");
      }
      return toObject;
    }
    function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
      const toObject = {};
      let discriminatorValidationDataset = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorValidationDataset === void 0) {
        discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
        const fromValidationDataset = getValueByPath(fromObject, [
          "validationDataset"
        ]);
        if (parentObject !== void 0 && fromValidationDataset != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
        }
      } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
        const fromValidationDataset = getValueByPath(fromObject, [
          "validationDataset"
        ]);
        if (parentObject !== void 0 && fromValidationDataset != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
        }
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
        setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (parentObject !== void 0 && fromDescription != null) {
        setValueByPath(parentObject, ["description"], fromDescription);
      }
      let discriminatorEpochCount = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorEpochCount === void 0) {
        discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
        const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
        if (parentObject !== void 0 && fromEpochCount != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
        }
      } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
        const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
        if (parentObject !== void 0 && fromEpochCount != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
        }
      }
      let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorLearningRateMultiplier === void 0) {
        discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
        const fromLearningRateMultiplier = getValueByPath(fromObject, [
          "learningRateMultiplier"
        ]);
        if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
        }
      } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
        const fromLearningRateMultiplier = getValueByPath(fromObject, [
          "learningRateMultiplier"
        ]);
        if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
          setValueByPath(parentObject, [
            "preferenceOptimizationSpec",
            "hyperParameters",
            "learningRateMultiplier"
          ], fromLearningRateMultiplier);
        }
      }
      let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
      if (discriminatorExportLastCheckpointOnly === void 0) {
        discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
          "exportLastCheckpointOnly"
        ]);
        if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
        }
      } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
          "exportLastCheckpointOnly"
        ]);
        if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
        }
      }
      let discriminatorAdapterSize = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorAdapterSize === void 0) {
        discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
        const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
        if (parentObject !== void 0 && fromAdapterSize != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
        }
      } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
        const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
        if (parentObject !== void 0 && fromAdapterSize != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
        }
      }
      if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
        throw new Error("batchSize parameter is not supported in Vertex AI.");
      }
      if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
        throw new Error("learningRate parameter is not supported in Vertex AI.");
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (parentObject !== void 0 && fromLabels != null) {
        setValueByPath(parentObject, ["labels"], fromLabels);
      }
      const fromBeta = getValueByPath(fromObject, ["beta"]);
      if (parentObject !== void 0 && fromBeta != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
      }
      return toObject;
    }
    function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromTrainingDataset = getValueByPath(fromObject, [
        "trainingDataset"
      ]);
      if (fromTrainingDataset != null) {
        tuningDatasetToMldev(fromTrainingDataset);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createTuningJobConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
      const toObject = {};
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromTrainingDataset = getValueByPath(fromObject, [
        "trainingDataset"
      ]);
      if (fromTrainingDataset != null) {
        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
      }
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
      }
      return toObject;
    }
    function getTuningJobParametersToMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function getTuningJobParametersToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["_url", "name"], fromName);
      }
      return toObject;
    }
    function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
      const toObject = {};
      const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
      if (parentObject !== void 0 && fromPageSize != null) {
        setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
      }
      const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
      if (parentObject !== void 0 && fromPageToken != null) {
        setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
      }
      const fromFilter = getValueByPath(fromObject, ["filter"]);
      if (parentObject !== void 0 && fromFilter != null) {
        setValueByPath(parentObject, ["_query", "filter"], fromFilter);
      }
      return toObject;
    }
    function listTuningJobsParametersToMldev(fromObject, rootObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listTuningJobsConfigToMldev(fromConfig, toObject);
      }
      return toObject;
    }
    function listTuningJobsParametersToVertex(fromObject, rootObject) {
      const toObject = {};
      const fromConfig = getValueByPath(fromObject, ["config"]);
      if (fromConfig != null) {
        listTuningJobsConfigToVertex(fromConfig, toObject);
      }
      return toObject;
    }
    function listTuningJobsResponseFromMldev(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
      if (fromTuningJobs != null) {
        let transformedList = fromTuningJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return tuningJobFromMldev(item);
          });
        }
        setValueByPath(toObject, ["tuningJobs"], transformedList);
      }
      return toObject;
    }
    function listTuningJobsResponseFromVertex(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromNextPageToken = getValueByPath(fromObject, [
        "nextPageToken"
      ]);
      if (fromNextPageToken != null) {
        setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
      }
      const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
      if (fromTuningJobs != null) {
        let transformedList = fromTuningJobs;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return tuningJobFromVertex(item);
          });
        }
        setValueByPath(toObject, ["tuningJobs"], transformedList);
      }
      return toObject;
    }
    function tunedModelFromMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromModel = getValueByPath(fromObject, ["name"]);
      if (fromModel != null) {
        setValueByPath(toObject, ["model"], fromModel);
      }
      const fromEndpoint = getValueByPath(fromObject, ["name"]);
      if (fromEndpoint != null) {
        setValueByPath(toObject, ["endpoint"], fromEndpoint);
      }
      return toObject;
    }
    function tuningDatasetToMldev(fromObject, _rootObject) {
      const toObject = {};
      if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
        throw new Error("gcsUri parameter is not supported in Gemini API.");
      }
      if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
        throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
      }
      const fromExamples = getValueByPath(fromObject, ["examples"]);
      if (fromExamples != null) {
        let transformedList = fromExamples;
        if (Array.isArray(transformedList)) {
          transformedList = transformedList.map((item) => {
            return item;
          });
        }
        setValueByPath(toObject, ["examples", "examples"], transformedList);
      }
      return toObject;
    }
    function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
      const toObject = {};
      let discriminatorGcsUri = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorGcsUri === void 0) {
        discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
        const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
        if (parentObject !== void 0 && fromGcsUri != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
        }
      } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
        const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
        if (parentObject !== void 0 && fromGcsUri != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
        }
      }
      let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
        "config",
        "method"
      ]);
      if (discriminatorVertexDatasetResource === void 0) {
        discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
      }
      if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
        const fromVertexDatasetResource = getValueByPath(fromObject, [
          "vertexDatasetResource"
        ]);
        if (parentObject !== void 0 && fromVertexDatasetResource != null) {
          setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
        }
      } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
        const fromVertexDatasetResource = getValueByPath(fromObject, [
          "vertexDatasetResource"
        ]);
        if (parentObject !== void 0 && fromVertexDatasetResource != null) {
          setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
        }
      }
      if (getValueByPath(fromObject, ["examples"]) !== void 0) {
        throw new Error("examples parameter is not supported in Vertex AI.");
      }
      return toObject;
    }
    function tuningJobFromMldev(fromObject, rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, [
        "tuningTask",
        "startTime"
      ]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, [
        "tuningTask",
        "completeTime"
      ]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromTunedModel = getValueByPath(fromObject, ["_self"]);
      if (fromTunedModel != null) {
        setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
      }
      return toObject;
    }
    function tuningJobFromVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromState = getValueByPath(fromObject, ["state"]);
      if (fromState != null) {
        setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
      }
      const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
      if (fromCreateTime != null) {
        setValueByPath(toObject, ["createTime"], fromCreateTime);
      }
      const fromStartTime = getValueByPath(fromObject, ["startTime"]);
      if (fromStartTime != null) {
        setValueByPath(toObject, ["startTime"], fromStartTime);
      }
      const fromEndTime = getValueByPath(fromObject, ["endTime"]);
      if (fromEndTime != null) {
        setValueByPath(toObject, ["endTime"], fromEndTime);
      }
      const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
      if (fromUpdateTime != null) {
        setValueByPath(toObject, ["updateTime"], fromUpdateTime);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      const fromDescription = getValueByPath(fromObject, ["description"]);
      if (fromDescription != null) {
        setValueByPath(toObject, ["description"], fromDescription);
      }
      const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
      if (fromBaseModel != null) {
        setValueByPath(toObject, ["baseModel"], fromBaseModel);
      }
      const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
      if (fromTunedModel != null) {
        setValueByPath(toObject, ["tunedModel"], fromTunedModel);
      }
      const fromPreTunedModel = getValueByPath(fromObject, [
        "preTunedModel"
      ]);
      if (fromPreTunedModel != null) {
        setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
      }
      const fromSupervisedTuningSpec = getValueByPath(fromObject, [
        "supervisedTuningSpec"
      ]);
      if (fromSupervisedTuningSpec != null) {
        setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
      }
      const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
        "preferenceOptimizationSpec"
      ]);
      if (fromPreferenceOptimizationSpec != null) {
        setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
      }
      const fromTuningDataStats = getValueByPath(fromObject, [
        "tuningDataStats"
      ]);
      if (fromTuningDataStats != null) {
        setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
      }
      const fromEncryptionSpec = getValueByPath(fromObject, [
        "encryptionSpec"
      ]);
      if (fromEncryptionSpec != null) {
        setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
      }
      const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
        "partnerModelTuningSpec"
      ]);
      if (fromPartnerModelTuningSpec != null) {
        setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
      }
      const fromCustomBaseModel = getValueByPath(fromObject, [
        "customBaseModel"
      ]);
      if (fromCustomBaseModel != null) {
        setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
      }
      const fromExperiment = getValueByPath(fromObject, ["experiment"]);
      if (fromExperiment != null) {
        setValueByPath(toObject, ["experiment"], fromExperiment);
      }
      const fromLabels = getValueByPath(fromObject, ["labels"]);
      if (fromLabels != null) {
        setValueByPath(toObject, ["labels"], fromLabels);
      }
      const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
      if (fromOutputUri != null) {
        setValueByPath(toObject, ["outputUri"], fromOutputUri);
      }
      const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
      if (fromPipelineJob != null) {
        setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
      }
      const fromServiceAccount = getValueByPath(fromObject, [
        "serviceAccount"
      ]);
      if (fromServiceAccount != null) {
        setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
      }
      const fromTunedModelDisplayName = getValueByPath(fromObject, [
        "tunedModelDisplayName"
      ]);
      if (fromTunedModelDisplayName != null) {
        setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
      }
      const fromVeoTuningSpec = getValueByPath(fromObject, [
        "veoTuningSpec"
      ]);
      if (fromVeoTuningSpec != null) {
        setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
      }
      return toObject;
    }
    function tuningOperationFromMldev(fromObject, _rootObject) {
      const toObject = {};
      const fromSdkHttpResponse = getValueByPath(fromObject, [
        "sdkHttpResponse"
      ]);
      if (fromSdkHttpResponse != null) {
        setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
      }
      const fromName = getValueByPath(fromObject, ["name"]);
      if (fromName != null) {
        setValueByPath(toObject, ["name"], fromName);
      }
      const fromMetadata = getValueByPath(fromObject, ["metadata"]);
      if (fromMetadata != null) {
        setValueByPath(toObject, ["metadata"], fromMetadata);
      }
      const fromDone = getValueByPath(fromObject, ["done"]);
      if (fromDone != null) {
        setValueByPath(toObject, ["done"], fromDone);
      }
      const fromError = getValueByPath(fromObject, ["error"]);
      if (fromError != null) {
        setValueByPath(toObject, ["error"], fromError);
      }
      return toObject;
    }
    function tuningValidationDatasetToVertex(fromObject, _rootObject) {
      const toObject = {};
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (fromGcsUri != null) {
        setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
      }
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (fromVertexDatasetResource != null) {
        setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
      }
      return toObject;
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class Tunings extends BaseModule {
      constructor(apiClient) {
        super();
        this.apiClient = apiClient;
        this.get = (params) => __async(this, null, function* () {
          return yield this.getInternal(params);
        });
        this.list = (..._0) => __async(this, [..._0], function* (params = {}) {
          return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), yield this.listInternal(params), params);
        });
        this.tune = (params) => __async(this, null, function* () {
          var _a;
          if (this.apiClient.isVertexAI()) {
            if (params.baseModel.startsWith("projects/")) {
              const preTunedModel = {
                tunedModelName: params.baseModel
              };
              if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {
                preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
              }
              const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
              paramsPrivate.baseModel = void 0;
              return yield this.tuneInternal(paramsPrivate);
            } else {
              const paramsPrivate = Object.assign({}, params);
              return yield this.tuneInternal(paramsPrivate);
            }
          } else {
            const paramsPrivate = Object.assign({}, params);
            const operation = yield this.tuneMldevInternal(paramsPrivate);
            let tunedModelName = "";
            if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
              tunedModelName = operation["metadata"]["tunedModel"];
            } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
              tunedModelName = operation["name"].split("/operations/")[0];
            }
            const tuningJob = {
              name: tunedModelName,
              state: JobState.JOB_STATE_QUEUED
            };
            return tuningJob;
          }
        });
      }
      getInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getTuningJobParametersToVertex(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getTuningJobParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
      listInternal(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listTuningJobsParametersToVertex(params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromVertex(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listTuningJobsParametersToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromMldev(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        });
      }
      /**
       * Cancels a tuning job.
       *
       * @param params - The parameters for the cancel request.
       * @return The empty response returned by the API.
       *
       * @example
       * ```ts
       * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
       * ```
       */
      cancel(params) {
        return __async(this, null, function* () {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelTuningJobParametersToVertex(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelTuningJobParametersToMldev(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            yield this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        });
      }
      tuneInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createTuningJobParametersPrivateToVertex(params, params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        });
      }
      tuneMldevInternal(params) {
        return __async(this, null, function* () {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createTuningJobParametersPrivateToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningOperationFromMldev(apiResponse);
              return resp;
            });
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BrowserDownloader {
      download(_params, _apiClient) {
        return __async(this, null, function* () {
          throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
        });
      }
    }
    const MAX_CHUNK_SIZE = 1024 * 1024 * 8;
    const MAX_RETRY_COUNT = 3;
    const INITIAL_RETRY_DELAY_MS = 1e3;
    const DELAY_MULTIPLIER = 2;
    const X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
    function uploadBlob(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a;
        const response = yield uploadBlobInternal(file, uploadUrl, apiClient);
        const responseJson = yield response === null || response === void 0 ? void 0 : response.json();
        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
          throw new Error("Failed to upload file: Upload status is not finalized.");
        }
        return responseJson["file"];
      });
    }
    function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a;
        const response = yield uploadBlobInternal(file, uploadUrl, apiClient);
        const responseJson = yield response === null || response === void 0 ? void 0 : response.json();
        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
          throw new Error("Failed to upload file: Upload status is not finalized.");
        }
        const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
        const typedResp = new UploadToFileSearchStoreOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
    function uploadBlobInternal(file, uploadUrl, apiClient) {
      return __async(this, null, function* () {
        var _a, _b;
        let fileSize = 0;
        let offset = 0;
        let response = new HttpResponse(new Response());
        let uploadCommand = "upload";
        fileSize = file.size;
        while (offset < fileSize) {
          const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
          const chunk = file.slice(offset, offset + chunkSize);
          if (offset + chunkSize >= fileSize) {
            uploadCommand += ", finalize";
          }
          let retryCount = 0;
          let currentDelayMs = INITIAL_RETRY_DELAY_MS;
          while (retryCount < MAX_RETRY_COUNT) {
            response = yield apiClient.request({
              path: "",
              body: chunk,
              httpMethod: "POST",
              httpOptions: {
                apiVersion: "",
                baseUrl: uploadUrl,
                headers: {
                  "X-Goog-Upload-Command": uploadCommand,
                  "X-Goog-Upload-Offset": String(offset),
                  "Content-Length": String(chunkSize)
                }
              }
            });
            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
              break;
            }
            retryCount++;
            yield sleep(currentDelayMs);
            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
          }
          offset += chunkSize;
          if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
            break;
          }
          if (fileSize <= offset) {
            throw new Error("All content has been uploaded, but the upload status is not finalized.");
          }
        }
        return response;
      });
    }
    function getBlobStat(file) {
      return __async(this, null, function* () {
        const fileStat = { size: file.size, type: file.type };
        return fileStat;
      });
    }
    function sleep(ms) {
      return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
    }
    class BrowserUploader {
      upload(file, uploadUrl, apiClient) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return yield uploadBlob(file, uploadUrl, apiClient);
        });
      }
      uploadToFileSearchStore(file, uploadUrl, apiClient) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return yield uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
        });
      }
      stat(file) {
        return __async(this, null, function* () {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          } else {
            return yield getBlobStat(file);
          }
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    class BrowserWebSocketFactory {
      create(url, headers, callbacks) {
        return new BrowserWebSocket(url, headers, callbacks);
      }
    }
    class BrowserWebSocket {
      constructor(url, headers, callbacks) {
        this.url = url;
        this.headers = headers;
        this.callbacks = callbacks;
      }
      connect() {
        this.ws = new WebSocket(this.url);
        this.ws.onopen = this.callbacks.onopen;
        this.ws.onerror = this.callbacks.onerror;
        this.ws.onclose = this.callbacks.onclose;
        this.ws.onmessage = this.callbacks.onmessage;
      }
      send(message) {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.send(message);
      }
      close() {
        if (this.ws === void 0) {
          throw new Error("WebSocket is not connected");
        }
        this.ws.close();
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const GOOGLE_API_KEY_HEADER = "x-goog-api-key";
    class WebAuth {
      constructor(apiKey2) {
        this.apiKey = apiKey2;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addAuthHeaders(headers, url) {
        return __async(this, null, function* () {
          if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
            return;
          }
          if (this.apiKey.startsWith("auth_tokens/")) {
            throw new Error("Ephemeral tokens are only supported by the live API.");
          }
          if (!this.apiKey) {
            throw new Error("API key is missing. Please provide a valid API key.");
          }
          headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
        });
      }
    }
    /**
     * @license
     * Copyright 2025 Google LLC
     * SPDX-License-Identifier: Apache-2.0
     */
    const LANGUAGE_LABEL_PREFIX = "gl-node/";
    class GoogleGenAI {
      constructor(options) {
        var _a;
        if (options.apiKey == null) {
          throw new Error("An API Key must be set when running in a browser");
        }
        if (options.project || options.location) {
          throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
        }
        this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
        this.apiKey = options.apiKey;
        const baseUrl = getBaseUrl(
          options.httpOptions,
          options.vertexai,
          /*vertexBaseUrlFromEnv*/
          void 0,
          /*geminiBaseUrlFromEnv*/
          void 0
        );
        if (baseUrl) {
          if (options.httpOptions) {
            options.httpOptions.baseUrl = baseUrl;
          } else {
            options.httpOptions = { baseUrl };
          }
        }
        this.apiVersion = options.apiVersion;
        const auth2 = new WebAuth(this.apiKey);
        this.apiClient = new ApiClient({
          auth: auth2,
          apiVersion: this.apiVersion,
          apiKey: this.apiKey,
          vertexai: this.vertexai,
          httpOptions: options.httpOptions,
          userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
          uploader: new BrowserUploader(),
          downloader: new BrowserDownloader()
        });
        this.models = new Models(this.apiClient);
        this.live = new Live(this.apiClient, auth2, new BrowserWebSocketFactory());
        this.batches = new Batches(this.apiClient);
        this.chats = new Chats(this.models, this.apiClient);
        this.caches = new Caches(this.apiClient);
        this.files = new Files(this.apiClient);
        this.operations = new Operations(this.apiClient);
        this.authTokens = new Tokens(this.apiClient);
        this.tunings = new Tunings(this.apiClient);
        this.fileSearchStores = new FileSearchStores(this.apiClient);
      }
    }
    let apiKey = localStorage.getItem("gemini_api_key") || "";
    const setGeminiApiKey = (key) => {
      apiKey = key;
      localStorage.setItem("gemini_api_key", key);
    };
    const getClient = () => {
      if (!apiKey) throw new Error("API Key not set");
      return new GoogleGenAI({ apiKey });
    };
    const generateJSON = (model, prompt, schema) => __async(null, null, function* () {
      const ai = getClient();
      try {
        const config = { responseMimeType: "application/json" };
        if (schema) config.responseSchema = schema;
        const response = yield ai.models.generateContent({
          model,
          contents: prompt,
          config
        });
        const text = response.text;
        if (!text) throw new Error("No text returned from model");
        return JSON.parse(text);
      } catch (error) {
        console.error("Gemini JSON Error:", error);
        throw error;
      }
    });
    const generateListeningTest = (part = 1) => __async(null, null, function* () {
      let context = "";
      let topic = "";
      switch (part) {
        case 1:
          context = "Section 1: A conversation between two people set in an everyday social context (e.g., booking accommodation, inquiring about a gym membership).";
          topic = "Everyday Social Conversation";
          break;
        case 2:
          context = "Section 2: A monologue set in an everyday social context (e.g., a speech about local facilities, a guide giving a tour).";
          topic = "Social Monologue";
          break;
        case 3:
          context = "Section 3: A conversation between up to four people set in an educational or training context (e.g., a university tutor and a student discussing an assignment).";
          topic = "Educational Conversation";
          break;
        case 4:
          context = "Section 4: A monologue on an academic subject (e.g., a university lecture).";
          topic = "Academic Monologue";
          break;
        default:
          context = "Section 1: A conversation between two people set in an everyday social context.";
          topic = "General Listening";
      }
      const seed = Math.floor(Math.random() * 1e4);
      const prompt = `Generate an IELTS Listening Test ${context}.
  Topic: ${topic}
  Random Seed: ${seed}
  
  Requirements:
  1. Generate exactly 10 questions.
  2. Mix of Gap Fill (completion) and Multiple Choice.
  3. For Gap Fill, ensure the answer is a specific word or short phrase from the script.
  4. The script must be realistic and challenging, suitable for IELTS.
  5. Script length: Approx 400-500 words (concise but complete).
  6. The script should be formatted as plain text dialogue or monologue suitable for reading aloud.
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          topic: { type: Type.STRING },
          script: { type: Type.STRING },
          questions: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                id: { type: Type.STRING },
                text: { type: Type.STRING },
                type: { type: Type.STRING, enum: ["mcq", "gap_fill"] },
                options: { type: Type.ARRAY, items: { type: Type.STRING } },
                correctAnswer: { type: Type.STRING },
                explanation: { type: Type.STRING }
              },
              required: ["id", "text", "type", "correctAnswer", "explanation"]
            }
          }
        },
        required: ["topic", "script", "questions"]
      };
      try {
        return yield generateJSON("gemini-2.0-flash", prompt, schema);
      } catch (error) {
        console.warn("Gemini 2.0 Flash failed, falling back to 1.5 Flash...", error);
        try {
          return yield generateJSON("gemini-1.5-flash", prompt, schema);
        } catch (fallbackError) {
          console.error("Listening Gen Fallback Error:", fallbackError);
          return null;
        }
      }
    });
    const concatenateAudioBuffers = (buffers) => {
      let totalLength = 0;
      for (const buffer of buffers) {
        totalLength += buffer.length;
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        result.set(buffer, offset);
        offset += buffer.length;
      }
      return result;
    };
    const uint8ArrayToBase64 = (bytes) => {
      let binary = "";
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    };
    const generateTTS = (text) => __async(null, null, function* () {
      try {
        console.log("Generating TTS via Railway Backend with Chunking...");
        const TTS_API = "https://tts-backend-production-9d09.up.railway.app/tts";
        const MAX_CHUNK_SIZE2 = 800;
        const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];
        const chunks = [];
        let currentChunk = "";
        for (const sentence of sentences) {
          if ((currentChunk + sentence).length > MAX_CHUNK_SIZE2) {
            chunks.push(currentChunk);
            currentChunk = sentence;
          } else {
            currentChunk += sentence;
          }
        }
        if (currentChunk) chunks.push(currentChunk);
        console.log(`Split text into ${chunks.length} chunks for TTS.`);
        const audioBuffers = [];
        for (const chunk of chunks) {
          if (!chunk.trim()) continue;
          const response = yield fetch(TTS_API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: chunk })
          });
          if (!response.ok) {
            const errorText = yield response.text();
            console.error("TTS Backend Error for chunk:", errorText);
            throw new Error(`TTS Error: ${errorText}`);
          }
          const arrayBuffer = yield response.arrayBuffer();
          audioBuffers.push(new Uint8Array(arrayBuffer));
        }
        if (audioBuffers.length === 0) {
          return { audio: null, error: "No audio generated" };
        }
        const combinedAudio = concatenateAudioBuffers(audioBuffers);
        const base64Audio = uint8ArrayToBase64(combinedAudio);
        return { audio: base64Audio };
      } catch (e) {
        console.error("TTS Generation Error", e);
        return { audio: null, error: e.message || "Unknown TTS error" };
      }
    });
    const generateReadingTest = (passageNum = 1) => __async(null, null, function* () {
      let topic = "";
      let difficulty = "";
      switch (passageNum) {
        case 1:
          topic = "Social Survival / General Interest";
          difficulty = "Moderate";
          break;
        case 2:
          topic = "Workplace / Training Context";
          difficulty = "Hard";
          break;
        case 3:
          topic = "General Academic / Complex Argument";
          difficulty = "Very Hard";
          break;
        default:
          topic = "General Interest";
          difficulty = "Moderate";
      }
      const prompt = `Generate an IELTS Reading Passage (Passage ${passageNum} of 3).
  Topic: ${topic}
  Difficulty: ${difficulty}
  
  Requirements:
  1. Passage Length: 700-900 words.
  2. Generate exactly 15 questions.
  3. Question Types: Mix of Multiple Choice, True/False/Not Given, and Matching Headings.
  4. The text must be academic and challenging, suitable for IELTS.
  5. IMPORTANT: The JSON key for the passage text must be "text", NOT "passage".
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING },
          text: { type: Type.STRING },
          questions: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                id: { type: Type.STRING },
                text: { type: Type.STRING },
                type: { type: Type.STRING, enum: ["mcq", "true_false", "matching"] },
                options: { type: Type.ARRAY, items: { type: Type.STRING } },
                correctAnswer: { type: Type.STRING },
                explanation: { type: Type.STRING }
              },
              required: ["id", "text", "type", "correctAnswer", "explanation"]
            }
          }
        },
        required: ["title", "text", "questions"]
      };
      return yield generateJSON("gemini-2.0-flash", prompt, schema);
    });
    const generateWritingTask = (taskType) => __async(null, null, function* () {
      const prompt = `Generate an IELTS Writing ${taskType === "task1" ? "Task 1" : "Task 2"} prompt.
  
  Requirements:
  1. Return a JSON object.
  2. For Task 1: Include 'chartData' for a bar or line chart.
  3. For Task 2: 'chartData' should be null.
  4. 'promptText': The text description/question.
  
  Output JSON Schema:
  {
    "promptText": "string",
    "chartData": {
      "type": "bar" | "line",
      "title": "string",
      "labels": ["string"],
      "datasets": [
        { "label": "string", "data": [number] }
      ]
    } | null
  }
  `;
      const schema = {
        type: Type.OBJECT,
        properties: {
          promptText: { type: Type.STRING },
          chartData: {
            type: Type.OBJECT,
            properties: {
              type: { type: Type.STRING, enum: ["bar", "line"] },
              title: { type: Type.STRING },
              labels: { type: Type.ARRAY, items: { type: Type.STRING } },
              datasets: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    label: { type: Type.STRING },
                    data: { type: Type.ARRAY, items: { type: Type.NUMBER } }
                  },
                  required: ["label", "data"]
                }
              }
            },
            required: ["type", "title", "labels", "datasets"],
            nullable: true
          }
        },
        required: ["promptText"]
      };
      return yield generateJSON("gemini-2.0-flash", prompt, schema);
    });
    const evaluateWriting = (essay, taskType, promptText) => __async(null, null, function* () {
      const prompt = `
  Act as a Senior IELTS Examiner. Evaluate the following ${taskType} essay based on the prompt: "${promptText}".
  Strictly follow IELTS band descriptors.
  
  CRITICAL INSTRUCTIONS:
  1. WORD COUNT CHECK:
     - If Task 1 < 50 words OR Task 2 < 50 words: FORCE BAND 1.0.
     - If Task 1 < 100 words OR Task 2 < 150 words: MAX BAND 4.0.
     - If Task 1 < 150 words OR Task 2 < 250 words: MAX BAND 5.5 for Task Response.
  
  2. RELEVANCE CHECK:
     - If the essay is gibberish, random characters, or completely irrelevant to the prompt: FORCE BAND 0.
     - If the essay is copied from the prompt: FORCE BAND 0.
  
  3. STRICT GRADING:
     - Do NOT be generous. 
     - Band 7.0+ requires sophisticated vocabulary and perfect structure.
     - Band 8.0+ is near-native.
  
  Essay: "${essay}"
  
  Return JSON with:
  - band (0-9, 0.5 increments)
  - taskResponse (0-9)
  - coherence (0-9)
  - lexicalResource (0-9)
  - grammar (0-9)
  - feedback (string, max 100 words)
  - improvedVersion (string): A full rewrite of the user's essay to make it a perfect Band 9 answer.
  - strengths: string[]
  - weaknesses: string[]
  `;
      return generateJSON("gemini-2.0-flash", prompt, {
        type: Type.OBJECT,
        properties: {
          band: { type: Type.NUMBER },
          taskResponse: { type: Type.NUMBER },
          coherence: { type: Type.NUMBER },
          lexicalResource: { type: Type.NUMBER },
          grammar: { type: Type.NUMBER },
          feedback: { type: Type.STRING },
          improvedVersion: { type: Type.STRING },
          strengths: { type: Type.ARRAY, items: { type: Type.STRING } },
          weaknesses: { type: Type.ARRAY, items: { type: Type.STRING } }
        },
        required: ["band", "taskResponse", "coherence", "lexicalResource", "grammar", "feedback", "improvedVersion", "strengths", "weaknesses"]
      });
    });
    const generateSpeakingCues = () => __async(null, null, function* () {
      const prompt = `Generate an IELTS Speaking test set.
  Output JSON:
  {
    "part1": ["3 questions about home/work/study"],
    "part2": { "topic": "Describe a...", "bullets": ["You should say...", "...", "..."] },
    "part3": ["3 abstract follow-up questions related to part 2"]
  }`;
      return generateJSON("gemini-2.0-flash", prompt);
    });
    const evaluateSpeakingSession = (transcript) => __async(null, null, function* () {
      const prompt = `Act as an IELTS Speaking examiner. Grade this transcript of a candidate's test.
  Transcript: "${transcript}"
  
  Return JSON with:
  - band (0-9)
  - fluency (0-9)
  - lexicalResource (0-9)
  - grammar (0-9)
  - pronunciation (0-9)
  - feedback (concise actionable advice)
  - perfectResponseExample (string): Pick one question the user answered poorly and write a Band 9 model answer for it.
  `;
      return generateJSON("gemini-2.0-flash", prompt, {
        type: Type.OBJECT,
        properties: {
          band: { type: Type.NUMBER },
          fluency: { type: Type.NUMBER },
          lexicalResource: { type: Type.NUMBER },
          grammar: { type: Type.NUMBER },
          pronunciation: { type: Type.NUMBER },
          feedback: { type: Type.STRING },
          perfectResponseExample: { type: Type.STRING }
        },
        required: ["band", "fluency", "lexicalResource", "grammar", "pronunciation", "feedback", "perfectResponseExample"]
      });
    });
    const generateVisualScenario = (imageBase64, prompt) => __async(null, null, function* () {
      var _a, _b, _c, _d;
      const ai = getClient();
      let operation = yield ai.models.generateVideos({
        model: "veo-3.1-fast-generate-preview",
        // Keeping this as it might be valid for video
        prompt,
        image: {
          imageBytes: imageBase64,
          mimeType: "image/jpeg"
        },
        config: {
          numberOfVideos: 1,
          resolution: "720p",
          aspectRatio: "16:9"
        }
      });
      while (!operation.done) {
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        operation = yield ai.operations.getVideosOperation({ operation });
      }
      const videoUri = (_d = (_c = (_b = (_a = operation.response) == null ? void 0 : _a.generatedVideos) == null ? void 0 : _b[0]) == null ? void 0 : _c.video) == null ? void 0 : _d.uri;
      if (videoUri) {
        return `${videoUri}&key=${apiKey}`;
      }
      throw new Error("Video generation failed");
    });
    const generateDiagnostic = () => __async(null, null, function* () {
      const prompt = `Generate a mini IELTS diagnostic test JSON.
   Includes:
   - 3 Listening questions (provide a short script approx 100 words)
   - 3 Reading questions (provide a short passage approx 150 words)
   - 5 Grammar MCQ questions to estimate writing/speaking level
   
   Format:
   {
      "listening": { "script": "...", "questions": [{ "id": "l1", "text": "...", "options": ["..."], "correctAnswer": "..." }] },
      "reading": { "passage": "...", "questions": [{ "id": "r1", "text": "...", "options": ["..."], "correctAnswer": "..." }] },
      "grammar": { "questions": [{ "id": "g1", "text": "...", "options": ["..."], "correctAnswer": "..." }] }
   }`;
      return generateJSON("gemini-2.0-flash", prompt);
    });
    function base64ToUint8Array(base64) {
      const binaryString = atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }
    function pcmToWavBlob(pcmData, sampleRate = 24e3) {
      const numChannels = 1;
      const byteRate = sampleRate * numChannels * 2;
      const blockAlign = numChannels * 2;
      const dataSize = pcmData.byteLength;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);
      writeString(view, 0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, "WAVE");
      writeString(view, 12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, "data");
      view.setUint32(40, dataSize, true);
      const pcmView = new Uint8Array(buffer, 44);
      pcmView.set(pcmData);
      return new Blob([buffer], { type: "audio/wav" });
    }
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
    const LiveSpeaking = () => {
      var _a, _b, _c;
      const { addXP } = useXP();
      const [status, setStatus] = reactExports.useState("idle");
      const [transcript, setTranscript] = reactExports.useState([]);
      const [cues, setCues] = reactExports.useState(null);
      const [currentQIndex, setCurrentQIndex] = reactExports.useState(0);
      const [timeLeft, setTimeLeft] = reactExports.useState(0);
      const [feedback, setFeedback] = reactExports.useState(null);
      const [persona, setPersona] = reactExports.useState("neutral");
      const [isRecording, setIsRecording] = reactExports.useState(false);
      const [isPlaying, setIsPlaying] = reactExports.useState(false);
      const [audioUrl, setAudioUrl] = reactExports.useState(null);
      const mediaRecorderRef = reactExports.useRef(null);
      const audioChunksRef = reactExports.useRef([]);
      const audioRef = reactExports.useRef(new Audio());
      reactExports.useEffect(() => {
        return () => {
          if (audioUrl) URL.revokeObjectURL(audioUrl);
        };
      }, [audioUrl]);
      const startSession = () => __async(null, null, function* () {
        setStatus("generating");
        setTranscript([]);
        setFeedback(null);
        try {
          const data = yield generateSpeakingCues();
          setCues(data);
          setStatus("part1");
          setCurrentQIndex(0);
          let intro = "Good afternoon. Can you tell me your full name please?";
          if (persona === "strict") intro = "Good afternoon. I am your examiner. State your name clearly.";
          if (persona === "friendly") intro = "Hi there! Nice to meet you. Let's start with your name, shall we?";
          speak(intro);
          setTimeout(() => speak(data.part1[0]), 4e3);
        } catch (e) {
          console.error(e);
          setStatus("idle");
        }
      });
      const speak = (text) => __async(null, null, function* () {
        setTranscript((prev) => [...prev, { role: "examiner", text }]);
        setIsPlaying(true);
        try {
          const audioBase64 = yield generateTTS(text);
          if (audioBase64) {
            const pcmData = base64ToUint8Array(audioBase64);
            const wavBlob = pcmToWavBlob(pcmData, 24e3);
            const url = URL.createObjectURL(wavBlob);
            if (audioUrl) URL.revokeObjectURL(audioUrl);
            setAudioUrl(url);
            audioRef.current.src = url;
            audioRef.current.play();
            audioRef.current.onended = () => setIsPlaying(false);
          }
        } catch (e) {
          console.error(e);
          setIsPlaying(false);
        }
      });
      const startRecording = () => __async(null, null, function* () {
        try {
          const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });
          const recorder = new MediaRecorder(stream);
          mediaRecorderRef.current = recorder;
          audioChunksRef.current = [];
          recorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunksRef.current.push(e.data);
          };
          recorder.start();
          setIsRecording(true);
        } catch (e) {
          console.error("Mic error", e);
          alert("Microphone access denied.");
        }
      });
      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          mediaRecorderRef.current.stop();
          setIsRecording(false);
          mediaRecorderRef.current.onstop = () => {
            setTranscript((prev) => [...prev, { role: "candidate", text: "(Candidate Audio Response Recorded)" }]);
            handleTurnLogic();
          };
        }
      };
      const handleTurnLogic = () => {
        if (status === "part1") {
          if (currentQIndex < cues.part1.length - 1) {
            setCurrentQIndex((prev) => prev + 1);
            setTimeout(() => speak(cues.part1[currentQIndex + 1]), 1e3);
          } else {
            setStatus("part2_prep");
            setTimeLeft(60);
            speak("Now, I will give you a topic and you have one minute to prepare. Here is your topic.");
          }
        } else if (status === "part2_speak") {
          setStatus("part3");
          setCurrentQIndex(0);
          const transition = persona === "friendly" ? "Thanks! Now let's chat a bit more broadly." : "Thank you. We will now move to Part 3.";
          speak(transition + " " + cues.part3[0]);
        } else if (status === "part3") {
          if (currentQIndex < cues.part3.length - 1) {
            setCurrentQIndex((prev) => prev + 1);
            setTimeout(() => speak(cues.part3[currentQIndex + 1]), 1e3);
          } else {
            finishSession();
          }
        }
      };
      reactExports.useEffect(() => {
        let timer;
        if (status === "part2_prep" && timeLeft > 0) {
          timer = setInterval(() => setTimeLeft((t) => t - 1), 1e3);
        } else if (status === "part2_prep" && timeLeft === 0) {
          setStatus("part2_speak");
          speak("Your time is up. Please start speaking now. You have 2 minutes.");
        }
        return () => clearInterval(timer);
      }, [status, timeLeft]);
      const finishSession = () => __async(null, null, function* () {
        setStatus("grading");
        const fullText = transcript.map((t) => `${t.role}: ${t.text}`).join("\n");
        const result = yield evaluateSpeakingSession(fullText);
        setFeedback(result);
        addXP(350);
        setStatus("completed");
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-3xl mx-auto space-y-6 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-black rounded-3xl shadow-sm border border-slate-200 dark:border-white/10 p-8 relative overflow-hidden", children: [
          status !== "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0 left-0 w-full h-1 bg-gradient-to-r ${status === "part1" ? "from-cyan-500" : status === "part2_speak" ? "from-purple-500" : "from-rose-500"} to-transparent animate-pulse` }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Mic, { className: "text-rose-500" }),
              "IELTS Speaking"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
              status === "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center bg-slate-100 dark:bg-white/5 rounded-lg p-1", children: ["neutral", "strict", "friendly"].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setPersona(p),
                  className: `px-3 py-1 rounded-md text-xs font-bold capitalize transition-all ${persona === p ? "bg-white dark:bg-white/10 shadow-sm text-slate-900 dark:text-white" : "text-slate-400 hover:text-slate-600"}`,
                  children: p
                },
                p
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-1 bg-slate-100 dark:bg-white/5 rounded-full text-xs font-bold uppercase tracking-wider text-slate-500 dark:text-slate-400 flex items-center gap-2", children: status === "idle" ? "Ready" : status.replace("_", " ") })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-[300px] flex flex-col items-center justify-center text-center space-y-8", children: [
            status === "idle" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-24 h-24 bg-gradient-to-tr from-rose-500 to-orange-400 rounded-full mx-auto mb-6 flex items-center justify-center shadow-xl shadow-rose-500/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 40, className: "text-white" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 dark:text-slate-400 mb-6 max-w-md mx-auto", children: [
                "Practice with our ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-slate-700 dark:text-slate-200 capitalize", children: persona }),
                " AI examiner. Covers all 3 parts with real-time cues."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: startSession, className: "px-8 py-4 bg-rose-600 hover:bg-rose-700 text-white rounded-full font-bold shadow-lg shadow-rose-500/30 transition-all hover:scale-105", children: "Start Interview" })
            ] }),
            status === "part2_prep" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full text-left bg-yellow-50 dark:bg-yellow-900/10 p-6 rounded-2xl border border-yellow-100 dark:border-yellow-900/30 animate-in zoom-in-95", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-bold text-slate-800 dark:text-white text-lg", children: "Cue Card" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-mono font-bold text-yellow-600", children: [
                  timeLeft,
                  "s"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4", children: (_a = cues == null ? void 0 : cues.part2) == null ? void 0 : _a.topic }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc pl-5 text-slate-600 dark:text-slate-400 space-y-1", children: (_c = (_b = cues == null ? void 0 : cues.part2) == null ? void 0 : _b.bullets) == null ? void 0 : _c.map((b, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: b }, i)) })
            ] }),
            (status === "part1" || status === "part3" || status === "part2_speak") && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isPlaying ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "animate-pulse", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-32 h-32 bg-cyan-100 dark:bg-cyan-900/20 rounded-full flex items-center justify-center text-cyan-600 mb-4 mx-auto border-4 border-cyan-200 dark:border-cyan-500/50 relative", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cpu, { size: 48 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 rounded-full border-2 border-cyan-400 animate-ping opacity-20" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-500 font-medium", children: "Examiner is speaking..." })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onMouseDown: startRecording,
                  onMouseUp: stopRecording,
                  onTouchStart: startRecording,
                  onTouchEnd: stopRecording,
                  className: `w-32 h-32 rounded-full flex items-center justify-center transition-all ${isRecording ? "bg-rose-500 scale-110 shadow-2xl shadow-rose-500/40 ring-8 ring-rose-500/20" : "bg-slate-100 dark:bg-white/10 hover:bg-slate-200 dark:hover:bg-white/20"}`,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Mic, { size: 40, className: isRecording ? "text-white" : "text-slate-400" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-6 text-sm font-bold text-slate-400 uppercase tracking-widest animate-pulse", children: isRecording ? "Recording..." : "Hold to Answer" })
            ] }) }),
            status === "completed" && feedback && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full text-left animate-in slide-in-from-bottom-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-800 dark:text-white", children: "Speaking Result" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-rose-100 dark:bg-rose-900/50 text-rose-700 dark:text-rose-300 px-4 py-2 rounded-xl text-2xl font-black", children: [
                  "Band ",
                  feedback.band
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Fluency" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.fluency })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Lexical" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.lexicalResource })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Grammar" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.grammar })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 bg-slate-50 dark:bg-white/5 rounded-lg text-center border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-slate-500 uppercase font-bold", children: "Pronunciation" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold dark:text-white", children: feedback.pronunciation })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-white/5 p-4 rounded-xl leading-relaxed border border-slate-100 dark:border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-bold text-slate-400 uppercase mb-2", children: "Feedback" }),
                  feedback.feedback
                ] }),
                feedback.perfectResponseExample && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-r from-amber-50 to-orange-50 dark:from-amber-950/30 dark:to-orange-950/30 p-4 rounded-xl border border-amber-100 dark:border-amber-900/50", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "text-sm font-bold text-amber-600 dark:text-amber-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16 }),
                    " Band 9 Model Answer (Example)"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-slate-700 dark:text-slate-300 italic", children: [
                    '"',
                    feedback.perfectResponseExample,
                    '"'
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: startSession, className: "mt-6 text-rose-600 font-bold hover:underline flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { size: 16 }),
                " Restart Test"
              ] })
            ] })
          ] })
        ] }),
        transcript.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-white/5 p-6 rounded-2xl border border-slate-100 dark:border-white/10 max-h-60 overflow-y-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-xs font-bold text-slate-400 uppercase mb-4", children: "Session Transcript" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3 text-sm", children: transcript.map((t, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex gap-3 ${t.role === "candidate" ? "flex-row-reverse" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-3 rounded-xl max-w-[80%] leading-relaxed ${t.role === "candidate" ? "bg-rose-100 dark:bg-rose-900/30 text-rose-900 dark:text-rose-200" : "bg-white dark:bg-white/10 text-slate-700 dark:text-slate-300 shadow-sm"}`, children: t.text }) }, i)) })
        ] })
      ] });
    };
    const ChartRenderer = ({ data }) => {
      if (!data) return null;
      const { type, title, labels, datasets } = data;
      const colors = ["bg-blue-500", "bg-emerald-500", "bg-amber-500", "bg-purple-500"];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 p-4 bg-slate-50 dark:bg-white/5 rounded-xl border border-slate-200 dark:border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-xs font-bold uppercase text-slate-500 mb-4 text-center", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-end justify-between h-48 gap-2 pb-6 border-b border-slate-200 dark:border-white/10 relative", children: labels.map((label, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 flex flex-col justify-end gap-1 h-full group relative", children: [
          datasets.map((ds, j) => {
            const maxVal = Math.max(...datasets.flatMap((d) => d.data));
            const height = ds.data[i] / maxVal * 100;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `w-full rounded-t-sm transition-all hover:opacity-80 ${colors[j % colors.length]}`,
                style: { height: `${height}%` },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "opacity-0 group-hover:opacity-100 absolute -top-6 left-1/2 -translate-x-1/2 text-[10px] bg-black text-white px-1 rounded", children: ds.data[i] })
              },
              j
            );
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -bottom-6 left-1/2 -translate-x-1/2 text-[10px] text-slate-500 whitespace-nowrap overflow-hidden text-ellipsis max-w-full text-center", children: label })
        ] }, i)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-4 mt-8 justify-center", children: datasets.map((ds, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-slate-600 dark:text-slate-400", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-3 h-3 rounded-full ${colors[i % colors.length]}` }),
          ds.label
        ] }, i)) })
      ] });
    };
    const WritingSection = () => {
      var _a, _b;
      const { updateScore } = useScore();
      const { writingTest, setWritingTest } = useTest();
      const [taskType, setTaskType] = reactExports.useState("task1");
      const [taskData, setTaskData] = reactExports.useState(null);
      const [response, setResponse] = reactExports.useState("");
      const [loading, setLoading] = reactExports.useState(false);
      const [evaluating, setEvaluating] = reactExports.useState(false);
      const [feedback, setFeedback] = reactExports.useState(null);
      const [timeLeft, setTimeLeft] = reactExports.useState(0);
      const [timerActive, setTimerActive] = reactExports.useState(false);
      const stateRef = React.useRef({
        taskType,
        taskData,
        response,
        feedback,
        timeLeft,
        timerActive
      });
      reactExports.useEffect(() => {
        stateRef.current = { taskType, taskData, response, feedback, timeLeft, timerActive };
      }, [taskType, taskData, response, feedback, timeLeft, timerActive]);
      reactExports.useEffect(() => {
        if (writingTest) {
          setTaskType(writingTest.taskType);
          setTaskData(writingTest.taskData);
          setResponse(writingTest.response);
          setFeedback(writingTest.feedback);
          setTimeLeft(writingTest.timeLeft);
          setTimerActive(false);
        } else {
          generatePrompt(taskType);
        }
        return () => {
          setWritingTest(stateRef.current);
        };
      }, []);
      const generatePrompt = (..._0) => __async(null, [..._0], function* (type = taskType) {
        setLoading(true);
        setFeedback(null);
        setResponse("");
        setTimerActive(false);
        setTimeLeft(type === "task1" ? 20 * 60 : 40 * 60);
        try {
          const data = yield generateWritingTask(type);
          setTaskData(data);
        } catch (error) {
          console.error("Failed to generate prompt", error);
        } finally {
          setLoading(false);
        }
      });
      const handleTaskTypeChange = (type) => {
        if (type !== taskType) {
          setTaskType(type);
          generatePrompt(type);
        }
      };
      reactExports.useEffect(() => {
        let interval;
        if (timerActive && timeLeft > 0) {
          interval = setInterval(() => {
            setTimeLeft((prev) => prev - 1);
          }, 1e3);
        }
        return () => clearInterval(interval);
      }, [timerActive, timeLeft]);
      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? "0" : ""}${s}`;
      };
      const handleEvaluate = () => __async(null, null, function* () {
        if (!response.trim() || !taskData) return;
        setEvaluating(true);
        setTimerActive(false);
        try {
          const result = yield evaluateWriting(taskType, taskData.promptText, response);
          setFeedback(result);
          const historyItem = {
            id: Date.now(),
            date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
            type: taskType,
            band: result.band,
            score: result.band
            // Normalize for dashboard
          };
          const savedHistory = localStorage.getItem("ielts_writing_history");
          const currentHistory = savedHistory ? JSON.parse(savedHistory) : [];
          const updatedHistory = [historyItem, ...currentHistory].slice(0, 10);
          localStorage.setItem("ielts_writing_history", JSON.stringify(updatedHistory));
          updateScore("writing", result.band);
        } catch (error) {
          console.error("Evaluation failed", error);
        } finally {
          setEvaluating(false);
        }
      });
      const wordCount = response.trim().split(/\s+/).filter((w) => w.length > 0).length;
      const minWords = taskType === "task1" ? 150 : 250;
      const targetWords = taskType === "task1" ? "160-190" : "270-300";
      const timeAlloc = taskType === "task1" ? "20 minutes" : "40 minutes";
      const structureGuide = taskType === "task1" ? "Introduction, Key Details, Summary/Overview (3 paragraphs)" : "Introduction, 2-3 Body Paragraphs, Conclusion (4-5 paragraphs)";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Writing" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400", children: "AI-Powered Assessment & Feedback" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex bg-slate-200 dark:bg-white/10 p-1 rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleTaskTypeChange("task1"),
                className: `px-6 py-2 rounded-lg text-sm font-bold transition-all ${taskType === "task1" ? "bg-white dark:bg-black text-violet-600 shadow-sm" : "text-slate-500 hover:text-slate-800 dark:hover:text-white"}`,
                children: "Task 1"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleTaskTypeChange("task2"),
                className: `px-6 py-2 rounded-lg text-sm font-bold transition-all ${taskType === "task2" ? "bg-white dark:bg-black text-violet-600 shadow-sm" : "text-slate-500 hover:text-slate-800 dark:hover:text-white"}`,
                children: "Task 2"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-1 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10 shadow-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-slate-800 dark:text-white flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(PenTool, { size: 18, className: "text-violet-500" }),
                  "Current Task"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => generatePrompt(taskType), disabled: loading, className: "text-slate-400 hover:text-violet-500 transition-colors", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16, className: loading ? "animate-spin" : "" }) })
              ] }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-8 text-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin mx-auto text-violet-500 mb-2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500", children: "Generating prompt..." })
              ] }) : taskData ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-600 dark:text-slate-300 leading-relaxed", children: taskData.promptText }),
                taskData.chartData && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartRenderer, { data: taskData.chartData })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 italic", children: "Failed to load task." })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 dark:bg-blue-900/10 p-6 rounded-2xl border border-blue-100 dark:border-blue-900/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-blue-700 dark:text-blue-400 mb-3 flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16 }),
                " Task Guidelines"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-3 text-xs text-blue-800 dark:text-blue-300", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Time:" }),
                  timeAlloc
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Min Words:" }),
                  minWords,
                  " words (Target: ",
                  targetWords,
                  ")"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold min-w-[80px]", children: "Structure:" }),
                  structureGuide
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "pt-2 border-t border-blue-200 dark:border-blue-800/50 italic opacity-80", children: [
                  "Writing fewer than ",
                  minWords,
                  " words results in penalties."
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lg:col-span-2 space-y-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10 shadow-sm relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-sm font-bold ${wordCount < minWords ? "text-red-500" : "text-green-500"}`, children: [
                  wordCount,
                  " words"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-2 font-mono font-bold ${timeLeft < 300 && timerActive ? "text-red-500 animate-pulse" : "text-slate-500"}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Timer, { size: 16 }),
                    " ",
                    formatTime(timeLeft)
                  ] }),
                  !timerActive && timeLeft > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setTimerActive(true), className: "text-xs bg-violet-100 dark:bg-violet-900/30 text-violet-600 dark:text-violet-300 px-3 py-1 rounded-full font-bold hover:bg-violet-200 transition-colors", children: "Start Timer" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: response,
                  onChange: (e) => setResponse(e.target.value),
                  placeholder: "Start writing your response here...",
                  className: "w-full h-96 bg-transparent border-0 focus:ring-0 p-0 text-slate-800 dark:text-slate-200 leading-relaxed resize-none"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-6 right-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: handleEvaluate,
                  disabled: evaluating || !response.trim(),
                  className: "bg-violet-600 hover:bg-violet-700 text-white px-6 py-3 rounded-xl font-bold flex items-center gap-2 shadow-lg shadow-violet-500/30 transition-all disabled:opacity-50 disabled:cursor-not-allowed",
                  children: [
                    evaluating ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { size: 18 }),
                    "Evaluate"
                  ]
                }
              ) })
            ] }),
            feedback && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-8 rounded-2xl border border-slate-200 dark:border-white/10 animate-in slide-in-from-bottom-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-black text-slate-900 dark:text-white", children: "Assessment Result" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-violet-500 text-white px-4 py-1 rounded-full font-black text-xl", children: [
                  "Band ",
                  feedback.band
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-8", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-green-50 dark:bg-green-900/10 rounded-xl border border-green-100 dark:border-green-900/30", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-green-700 dark:text-green-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 18 }),
                    " Strengths"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc list-inside text-sm text-green-800 dark:text-green-300 space-y-1", children: ((_a = feedback.strengths) == null ? void 0 : _a.map((s, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: s }, i))) || /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "No specific strengths noted." }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-amber-50 dark:bg-amber-900/10 rounded-xl border border-amber-100 dark:border-amber-900/30", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-bold text-amber-700 dark:text-amber-400 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 18 }),
                    " Improvements"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "list-disc list-inside text-sm text-amber-800 dark:text-amber-300 space-y-1", children: ((_b = feedback.weaknesses) == null ? void 0 : _b.map((w, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: w }, i))) || /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "No specific improvements noted." }) })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-black/20 p-6 rounded-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold text-slate-800 dark:text-white mb-2", children: "Detailed Feedback" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400 text-sm leading-relaxed", children: feedback.detailed_feedback || feedback.feedback })
              ] })
            ] })
          ] })
        ] })
      ] });
    };
    const Listening = () => {
      const { updateScore } = useScore();
      const { listeningTest, setListeningTest } = useTest();
      const [currentPart, setCurrentPart] = reactExports.useState(1);
      const [testData, setTestData] = reactExports.useState({});
      const [audioUrls, setAudioUrls] = reactExports.useState({});
      const [loading, setLoading] = reactExports.useState(false);
      const [audioLoading, setAudioLoading] = reactExports.useState(false);
      const [error, setError] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [submitted, setSubmitted] = reactExports.useState(false);
      const [finalScore, setFinalScore] = reactExports.useState(0);
      const [showHistory, setShowHistory] = reactExports.useState(false);
      const [history, setHistory] = reactExports.useState([]);
      const stateRef = React.useRef({
        currentPart,
        testData,
        audioUrls,
        answers,
        submitted,
        finalScore
      });
      reactExports.useEffect(() => {
        stateRef.current = { currentPart, testData, audioUrls, answers, submitted, finalScore };
      }, [currentPart, testData, audioUrls, answers, submitted, finalScore]);
      reactExports.useEffect(() => {
        const saved = localStorage.getItem("ielts_listening_history");
        if (saved) {
          try {
            setHistory(JSON.parse(saved));
          } catch (e) {
            console.error("Failed to parse history", e);
          }
        }
      }, []);
      const saveToHistory = (score, band) => {
        const newResult = {
          id: Date.now().toString(),
          date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
          score,
          band,
          answers,
          testData
        };
        const updated = [newResult, ...history].slice(0, 10);
        setHistory(updated);
        localStorage.setItem("ielts_listening_history", JSON.stringify(updated));
      };
      const clearHistory = () => {
        if (confirm("Are you sure you want to clear your test history?")) {
          setHistory([]);
          localStorage.removeItem("ielts_listening_history");
        }
      };
      const loadPart = (part) => __async(null, null, function* () {
        setLoading(true);
        setAudioLoading(false);
        setError(null);
        try {
          const result = yield generateListeningTest(part);
          const data = result;
          if (!data || !data.questions || !data.script) {
            throw new Error("Invalid test data received from AI. Please try again.");
          }
          const fixedQuestions = data.questions.map((q) => __spreadProps(__spreadValues({}, q), {
            id: `p${part}_${q.id}`
          }));
          const fixedData = __spreadProps(__spreadValues({}, data), { questions: fixedQuestions });
          setTestData((prev) => __spreadProps(__spreadValues({}, prev), { [part]: fixedData }));
          setLoading(false);
          setAudioLoading(true);
          try {
            const ttsResult = yield generateTTS(data.script);
            if (ttsResult && ttsResult.audio) {
              const byteCharacters = atob(ttsResult.audio);
              const byteNumbers = new Array(byteCharacters.length);
              for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
              }
              const byteArray = new Uint8Array(byteNumbers);
              const audioBlob = new Blob([byteArray], { type: "audio/mp3" });
              const url = URL.createObjectURL(audioBlob);
              setAudioUrls((prev) => __spreadProps(__spreadValues({}, prev), { [part]: url }));
            } else {
              console.warn("TTS returned no audio:", ttsResult == null ? void 0 : ttsResult.error);
              if (ttsResult == null ? void 0 : ttsResult.error) {
                console.error("Audio Generation Error:", ttsResult.error);
              }
            }
          } catch (audioErr) {
            console.error("Audio generation failed:", audioErr);
          } finally {
            setAudioLoading(false);
          }
        } catch (err) {
          console.error("Error loading part:", err);
          setError(err.message || "Failed to load listening test part.");
          setLoading(false);
          setAudioLoading(false);
        }
      });
      reactExports.useEffect(() => {
        if (listeningTest) {
          setCurrentPart(listeningTest.currentPart);
          setTestData(listeningTest.testData);
          setAudioUrls(listeningTest.audioUrls);
          setAnswers(listeningTest.answers);
          setSubmitted(listeningTest.submitted);
          setFinalScore(listeningTest.finalScore);
        } else {
          loadPart(1);
        }
        return () => {
          setListeningTest(stateRef.current);
        };
      }, []);
      const handleNextPart = () => {
        if (currentPart < 4) {
          const nextPart = currentPart + 1;
          setCurrentPart(nextPart);
          if (!testData[nextPart]) {
            loadPart(nextPart);
          }
        } else {
          calculateScore();
        }
      };
      const normalizeAnswer = (text) => {
        return text.toLowerCase().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "").trim();
      };
      const calculateScore = () => {
        let correct = 0;
        let totalQuestions = 0;
        Object.values(testData).forEach((part) => {
          part.questions.forEach((q) => {
            totalQuestions++;
            const userAns = normalizeAnswer(answers[q.id] || "");
            const correctAns = q.correctAnswer;
            let isCorrect = false;
            if (Array.isArray(correctAns)) {
              isCorrect = correctAns.some((a) => normalizeAnswer(a) === userAns);
            } else {
              isCorrect = normalizeAnswer(correctAns) === userAns;
            }
            if (isCorrect) correct++;
          });
        });
        setFinalScore(correct);
        setSubmitted(true);
        const accuracy = totalQuestions > 0 ? correct / totalQuestions : 0;
        let band = 0;
        if (accuracy >= 0.97) band = 9;
        else if (accuracy >= 0.92) band = 8.5;
        else if (accuracy >= 0.87) band = 8;
        else if (accuracy >= 0.8) band = 7.5;
        else if (accuracy >= 0.75) band = 7;
        else if (accuracy >= 0.65) band = 6.5;
        else if (accuracy >= 0.57) band = 6;
        else if (accuracy >= 0.45) band = 5.5;
        else if (accuracy >= 0.4) band = 5;
        else if (accuracy >= 0.32) band = 4.5;
        else if (accuracy >= 0.25) band = 4;
        else band = 3.5;
        saveToHistory(correct, band);
        updateScore("listening", band);
      };
      const resetTest = () => {
        setSubmitted(false);
        setAnswers({});
        setTestData({});
        Object.values(audioUrls).forEach((url) => URL.revokeObjectURL(url));
        setAudioUrls({});
        setCurrentPart(1);
        setFinalScore(0);
        setListeningTest(null);
        loadPart(1);
      };
      const loadHistoricalTest = (result) => {
        setTestData(result.testData);
        setAnswers(result.answers);
        setFinalScore(result.score);
        setSubmitted(true);
        setShowHistory(false);
      };
      const playBrowserTTS = (text) => {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        utterance.pitch = 1;
        const voices = window.speechSynthesis.getVoices();
        const englishVoice = voices.find((v) => v.name.includes("Google US English")) || voices.find((v) => v.lang.startsWith("en"));
        if (englishVoice) utterance.voice = englishVoice;
        window.speechSynthesis.speak(utterance);
      };
      const currentTest = testData[currentPart];
      if (showHistory) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white", children: "Test History" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowHistory(false), className: "text-cyan-600 font-bold hover:underline", children: "Back to Practice" })
          ] }),
          history.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-20 text-slate-500", children: "No tests taken yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: history.map((res) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => loadHistoricalTest(res), className: "p-6 bg-white dark:bg-white/5 rounded-2xl border border-slate-200 dark:border-white/10 hover:border-cyan-500 cursor-pointer transition-all flex items-center justify-between group", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold mb-1", children: res.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xl font-bold text-slate-800 dark:text-white", children: [
                "Band Score: ",
                res.band
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-slate-600 dark:text-slate-400", children: [
                res.score,
                " / 40 Correct"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "text-slate-300 group-hover:text-cyan-500 transition-colors" })
          ] }, res.id)) }),
          history.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearHistory, className: "flex items-center gap-2 text-red-500 font-bold hover:text-red-600 mt-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16 }),
            " Clear History"
          ] })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500 pt-16 md:pt-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Listening Practice" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-600 dark:text-slate-400", children: [
              "Part ",
              currentPart,
              " of 4  10 Questions"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowHistory(true), className: "p-2 rounded-full hover:bg-slate-100 dark:hover:bg-white/10 text-slate-600 dark:text-slate-300 transition-colors", title: "History", children: /* @__PURE__ */ jsxRuntimeExports.jsx(History, { size: 20 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 items-center", children: [1, 2, 3, 4].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-2 w-12 rounded-full transition-colors ${p <= currentPart ? "bg-cyan-500" : "bg-slate-200 dark:bg-white/10"}` }, p)) })
          ] })
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-xl border border-red-200 dark:border-red-900/30 flex items-center gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 20 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: error }),
          !testData[currentPart] && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPart(currentPart), className: "underline font-bold hover:text-red-700 ml-auto", children: "Retry" })
        ] }),
        loading && !testData[currentPart] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-20 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-cyan-500", size: 48 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 font-medium animate-pulse", children: [
            "Generating Test Content Part ",
            currentPart,
            "..."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPart(currentPart), className: "mt-4 text-xs text-slate-400 hover:text-cyan-500 underline", children: "Stuck? Refresh Questions" })
        ] }) : currentTest ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !submitted && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-0 left-0 md:left-64 right-0 z-50 bg-white/90 dark:bg-neutral-900/90 backdrop-blur-xl border-b border-slate-200 dark:border-white/10 shadow-lg animate-in slide-in-from-top-full duration-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto p-3 flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex flex-col items-center gap-1 text-[10px] font-bold uppercase text-slate-400 tracking-widest shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Audio" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: audioLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-10 bg-slate-100 dark:bg-white/5 rounded-lg flex items-center justify-center gap-2 text-xs text-slate-500 animate-pulse border border-slate-200 dark:border-white/10", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { size: 14, className: "animate-spin text-cyan-500" }),
              " Generating Audio..."
            ] }) : audioUrls[currentPart] ? /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { controls: true, src: audioUrls[currentPart], className: "w-full h-10 invert dark:invert-0" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden sm:flex items-center gap-2 text-[10px] text-red-500 bg-red-50 dark:bg-red-900/20 px-3 rounded border border-red-100 dark:border-red-900/30 whitespace-nowrap", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 12 }),
                "Generation Failed"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => playBrowserTTS(currentTest.script), className: "flex-1 flex items-center justify-center gap-2 px-3 py-2 bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-200 rounded-lg text-xs font-bold transition-colors", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { size: 14 }),
                " Play Browser TTS"
              ] })
            ] }) }),
            audioUrls[currentPart] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden sm:flex text-[10px] text-cyan-500 items-center gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(WandSparkles, { size: 12 }),
              " Gemini 2.5 Flash"
            ] })
          ] }) }),
          !submitted ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: currentTest.questions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 rounded-xl border border-slate-100 dark:border-white/10 bg-slate-50 dark:bg-white/5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4 text-lg", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-cyan-500 mr-2", children: [
                  i + 1,
                  "."
                ] }),
                q.text
              ] }),
              q.type === "mcq" && q.options ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all border ${answers[q.id] === opt ? "bg-cyan-500/20 border-cyan-400" : "border-transparent hover:bg-white/10"}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "radio",
                    name: q.id,
                    value: opt,
                    onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value })),
                    checked: answers[q.id] === opt,
                    className: "w-5 h-5 text-cyan-500 accent-cyan-500"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
              ] }, opt)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  className: "w-full p-4 rounded-xl border border-slate-300 dark:border-white/10 bg-white dark:bg-black text-slate-900 dark:text-white focus:ring-2 focus:ring-cyan-500 outline-none transition-all",
                  placeholder: "Type answer here...",
                  value: answers[q.id] || "",
                  onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value }))
                }
              )
            ] }, q.id)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleNextPart,
                className: "mt-8 w-full bg-cyan-600 hover:bg-cyan-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 shadow-lg shadow-cyan-500/30 transition-all transform active:scale-[0.98]",
                children: currentPart < 4 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  "Next Part ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Play, { size: 20 })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 20 }),
                  " Finish Test"
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: () => {
                  if (confirm("Are you sure you want to finish early? You will be scored on what you have completed so far.")) calculateScore();
                },
                className: "mt-4 w-full bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-300 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-colors",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 18 }),
                  " Finish Early & Get Score"
                ]
              }
            )
          ] }) : (
            /* Results View */
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 space-y-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-blue-50 dark:bg-white/5 rounded-2xl text-center border border-blue-100 dark:border-white/10", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase tracking-wider mb-1", children: "Overall Band Score" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl font-black text-blue-600 dark:text-cyan-400 mb-2", children: (() => {
                  let total = 0;
                  Object.values(testData).forEach((p) => total += p.questions.length);
                  const acc = total > 0 ? finalScore / total : 0;
                  let band = 0;
                  if (acc >= 0.97) band = 9;
                  else if (acc >= 0.92) band = 8.5;
                  else if (acc >= 0.87) band = 8;
                  else if (acc >= 0.8) band = 7.5;
                  else if (acc >= 0.75) band = 7;
                  else if (acc >= 0.65) band = 6.5;
                  else if (acc >= 0.57) band = 6;
                  else if (acc >= 0.45) band = 5.5;
                  else if (acc >= 0.4) band = 5;
                  else if (acc >= 0.32) band = 4.5;
                  else if (acc >= 0.25) band = 4;
                  else band = 3.5;
                  return band;
                })() }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-block bg-white dark:bg-black px-4 py-1 rounded-full text-sm font-bold shadow-sm border border-white/10", children: [
                  "Score: ",
                  finalScore,
                  " / 40"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: Object.entries(testData).map(([part, data]) => {
                const testPart = data;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-slate-200 dark:border-white/10 pt-8 first:border-0 first:pt-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-xl mb-4 text-slate-800 dark:text-white", children: [
                    "Part ",
                    part,
                    ": ",
                    testPart.topic
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-white/5 p-4 rounded-xl mb-4 text-sm text-slate-600 dark:text-slate-400 max-h-40 overflow-y-auto border border-slate-200 dark:border-white/10", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold mb-2 text-xs uppercase", children: "Audio Script" }),
                    testPart.script
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: testPart.questions.map((q, i) => {
                    const userAns = normalizeAnswer(answers[q.id] || "");
                    const correctAns = q.correctAnswer;
                    let isCorrect = false;
                    if (Array.isArray(correctAns)) {
                      isCorrect = correctAns.some((a) => normalizeAnswer(a) === userAns);
                    } else {
                      isCorrect = normalizeAnswer(correctAns) === userAns;
                    }
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 rounded-xl border ${isCorrect ? "border-green-500/30 bg-green-500/10" : "border-red-500/30 bg-red-500/10"}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-slate-700 dark:text-slate-200", children: [
                          "Q",
                          i + 1,
                          ". ",
                          q.text
                        ] }),
                        isCorrect ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, className: "text-green-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16, className: "text-red-500" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm grid grid-cols-2 gap-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Your Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: isCorrect ? "text-green-600 dark:text-green-400" : "text-red-600 dark:text-red-400", children: answers[q.id] || "(No Answer)" })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Correct Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-800 dark:text-white font-medium", children: Array.isArray(q.correctAnswer) ? q.correctAnswer.join(" / ") : q.correctAnswer })
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-xs text-slate-500 italic border-t border-black/5 dark:border-white/5 pt-2", children: q.explanation })
                    ] }, q.id);
                  }) })
                ] }, part);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: resetTest, className: "w-full py-4 text-cyan-500 font-bold hover:bg-cyan-500/10 rounded-xl transition-colors border border-transparent hover:border-cyan-500/30", children: "Start New Full Test" })
            ] })
          )
        ] }) : null
      ] });
    };
    const IELTSReading = () => {
      const { readingTest, setReadingTest } = useTest();
      const [currentPassage, setCurrentPassage] = reactExports.useState(1);
      const [testData, setTestData] = reactExports.useState({});
      const [loading, setLoading] = reactExports.useState(false);
      const [error, setError] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [submitted, setSubmitted] = reactExports.useState(false);
      const [finalScore, setFinalScore] = reactExports.useState(0);
      const [timeLeft, setTimeLeft] = reactExports.useState(60 * 60);
      const [timerActive, setTimerActive] = reactExports.useState(false);
      const [showHistory, setShowHistory] = reactExports.useState(false);
      const [history, setHistory] = reactExports.useState([]);
      const stateRef = React.useRef({
        currentPassage,
        testData,
        answers,
        submitted,
        finalScore,
        timeLeft,
        timerActive
      });
      reactExports.useEffect(() => {
        stateRef.current = { currentPassage, testData, answers, submitted, finalScore, timeLeft, timerActive };
      }, [currentPassage, testData, answers, submitted, finalScore, timeLeft, timerActive]);
      reactExports.useEffect(() => {
        const saved = localStorage.getItem("ielts_reading_history");
        if (saved) {
          try {
            setHistory(JSON.parse(saved));
          } catch (e) {
            console.error("Failed to parse history", e);
          }
        }
      }, []);
      const saveToHistory = (score, band) => {
        const newResult = {
          id: Date.now().toString(),
          date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
          score,
          band,
          answers,
          testData
        };
        const updated = [newResult, ...history].slice(0, 10);
        setHistory(updated);
        localStorage.setItem("ielts_reading_history", JSON.stringify(updated));
      };
      const clearHistory = () => {
        if (confirm("Are you sure you want to clear your test history?")) {
          setHistory([]);
          localStorage.removeItem("ielts_reading_history");
        }
      };
      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? "0" : ""}${s}`;
      };
      const loadPassage = (passageNum) => __async(null, null, function* () {
        setLoading(true);
        setError(null);
        try {
          const result = yield generateReadingTest(passageNum);
          const data = result;
          if (!data || !data.questions || !data.text) {
            throw new Error("Invalid reading data received. Please try again.");
          }
          const fixedQuestions = data.questions.map((q) => __spreadProps(__spreadValues({}, q), {
            id: `p${passageNum}_${q.id}`
          }));
          const fixedData = __spreadProps(__spreadValues({}, data), { questions: fixedQuestions });
          setTestData((prev) => __spreadProps(__spreadValues({}, prev), { [passageNum]: fixedData }));
          setTimerActive(true);
        } catch (err) {
          console.error("Error loading passage:", err);
          setError(err.message || "Failed to load reading passage.");
        } finally {
          setLoading(false);
        }
      });
      reactExports.useEffect(() => {
        if (readingTest) {
          setCurrentPassage(readingTest.currentPassage);
          setTestData(readingTest.testData);
          setAnswers(readingTest.answers);
          setSubmitted(readingTest.submitted);
          setFinalScore(readingTest.finalScore);
          setTimeLeft(readingTest.timeLeft);
          setTimerActive(false);
        } else {
          loadPassage(1);
        }
        return () => {
          setReadingTest(stateRef.current);
        };
      }, []);
      const handleNextPassage = () => {
        if (currentPassage < 3) {
          const nextPassage = currentPassage + 1;
          setCurrentPassage(nextPassage);
          if (!testData[nextPassage]) {
            loadPassage(nextPassage);
          }
        } else {
          calculateScore();
        }
      };
      const normalizeAnswer = (text) => {
        return text.toLowerCase().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g, "").trim();
      };
      const calculateScore = () => {
        let correct = 0;
        let totalQuestions = 0;
        Object.values(testData).forEach((part) => {
          part.questions.forEach((q) => {
            totalQuestions++;
            const userAns = normalizeAnswer(answers[q.id] || "");
            const correctAns = normalizeAnswer(q.correctAnswer);
            if (userAns === correctAns) correct++;
          });
        });
        const accuracy = totalQuestions > 0 ? correct / totalQuestions : 0;
        let band = 0;
        if (accuracy >= 0.97) band = 9;
        else if (accuracy >= 0.92) band = 8.5;
        else if (accuracy >= 0.87) band = 8;
        else if (accuracy >= 0.8) band = 7.5;
        else if (accuracy >= 0.75) band = 7;
        else if (accuracy >= 0.65) band = 6.5;
        else if (accuracy >= 0.57) band = 6;
        else if (accuracy >= 0.45) band = 5.5;
        else if (accuracy >= 0.37) band = 5;
        else if (accuracy >= 0.32) band = 4.5;
        else if (accuracy >= 0.25) band = 4;
        else band = 3.5;
        setFinalScore(correct);
        setSubmitted(true);
        setTimerActive(false);
        saveToHistory(correct, band);
      };
      const currentTest = testData[currentPassage];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto space-y-8 animate-in fade-in duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-black text-slate-900 dark:text-white mb-2", children: "IELTS Reading" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-400", children: "Academic Reading Practice" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setShowHistory(!showHistory),
                className: "px-4 py-2 rounded-lg bg-slate-200 dark:bg-white/10 text-slate-700 dark:text-white font-bold text-sm hover:bg-slate-300 dark:hover:bg-white/20 transition-colors",
                children: showHistory ? "Back to Test" : "History"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-200 dark:bg-white/10 px-4 py-2 rounded-lg font-mono font-bold text-slate-700 dark:text-white flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Timer, { size: 16, className: timeLeft < 300 ? "text-red-500 animate-pulse" : "" }),
              formatTime(timeLeft)
            ] })
          ] })
        ] }),
        showHistory ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-6 rounded-2xl border border-slate-200 dark:border-white/10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-900 dark:text-white", children: "Test History" }),
            history.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearHistory, className: "text-xs text-red-500 hover:text-red-400 flex items-center gap-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 12 }),
              " Clear History"
            ] })
          ] }),
          history.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-12 text-slate-500", children: "No test history available yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: history.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 bg-slate-50 dark:bg-black/20 rounded-xl border border-slate-100 dark:border-white/5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-slate-800 dark:text-white", children: item.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-slate-500", children: [
                "Score: ",
                item.score,
                " / 40"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-black text-emerald-500", children: [
              "Band ",
              item.band
            ] })
          ] }, item.id)) })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 justify-end mb-6", children: [1, 2, 3].map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-2 w-8 rounded-full transition-colors ${p <= currentPassage ? "bg-emerald-500" : "bg-slate-200 dark:bg-white/10"}` }, p)) }),
          error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-xl border border-red-200 dark:border-red-900/30 flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 20 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: error }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => loadPassage(currentPassage), className: "underline font-bold hover:text-red-700 ml-auto", children: "Retry" })
          ] }),
          loading && !testData[currentPassage] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center py-20 space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-emerald-500", size: 48 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-slate-500 font-medium animate-pulse", children: [
              "Generating Reading Passage ",
              currentPassage,
              "..."
            ] })
          ] }) : currentTest ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !submitted ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-white/5 p-8 rounded-2xl border border-slate-200 dark:border-white/10 h-[80vh] overflow-y-auto shadow-inner", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold mb-6 text-slate-900 dark:text-white sticky top-0 bg-white dark:bg-[#121212] py-2 border-b border-slate-100 dark:border-white/10", children: currentTest.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "prose dark:prose-invert max-w-none text-slate-700 dark:text-slate-300 leading-relaxed font-serif text-lg", children: currentTest.text.split("\n").map((para, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-4", children: para }, i)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 h-[80vh] overflow-y-auto pr-2", children: [
              currentTest.questions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 rounded-xl border border-slate-200 dark:border-white/10 bg-slate-50 dark:bg-white/5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium text-slate-800 dark:text-slate-200 mb-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-emerald-500 mr-2", children: [
                    i + 1,
                    "."
                  ] }),
                  q.text
                ] }),
                q.type === "mcq" && q.options ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all border ${answers[q.id] === opt ? "bg-emerald-500/20 border-emerald-400" : "border-transparent hover:bg-white/10"}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "radio",
                      name: q.id,
                      value: opt,
                      onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value })),
                      checked: answers[q.id] === opt,
                      className: "w-5 h-5 text-emerald-500 accent-emerald-500"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
                ] }, opt)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    className: "w-full p-4 rounded-xl border border-slate-300 dark:border-white/10 bg-white dark:bg-black text-slate-900 dark:text-white focus:ring-2 focus:ring-emerald-500 outline-none transition-all",
                    placeholder: "Type answer here...",
                    value: answers[q.id] || "",
                    onChange: (e) => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: e.target.value }))
                  }
                )
              ] }, q.id)),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-4 pt-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: handleNextPassage,
                    className: "w-full bg-emerald-600 hover:bg-emerald-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 shadow-lg shadow-emerald-500/30 transition-all transform active:scale-[0.98]",
                    children: currentPassage < 3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      "Next Passage ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 20 })
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 20 }),
                      " Finish Test"
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    onClick: () => {
                      if (confirm("Are you sure you want to finish early? You will be scored on what you have completed so far.")) calculateScore();
                    },
                    className: "w-full bg-slate-200 hover:bg-slate-300 dark:bg-white/10 dark:hover:bg-white/20 text-slate-700 dark:text-slate-300 py-3 rounded-xl font-bold flex items-center justify-center gap-2 transition-colors",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 18 }),
                      " Finish Early & Get Score"
                    ]
                  }
                )
              ] })
            ] })
          ] }) : (
            /* Results View */
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 space-y-6 max-w-3xl mx-auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 bg-emerald-50 dark:bg-white/5 rounded-3xl text-center border border-emerald-100 dark:border-white/10 shadow-xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-slate-500 font-bold uppercase tracking-wider mb-2", children: "Projected Band Score" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-6xl font-black text-emerald-600 dark:text-emerald-400 mb-4", children: (() => {
                  let correct = 0;
                  let total = 0;
                  Object.values(testData).forEach((part) => {
                    part.questions.forEach((q) => {
                      total++;
                      if (normalizeAnswer(answers[q.id] || "") === normalizeAnswer(q.correctAnswer)) correct++;
                    });
                  });
                  const accuracy = total > 0 ? correct / total : 0;
                  let band = 0;
                  if (accuracy >= 0.97) band = 9;
                  else if (accuracy >= 0.92) band = 8.5;
                  else if (accuracy >= 0.87) band = 8;
                  else if (accuracy >= 0.8) band = 7.5;
                  else if (accuracy >= 0.75) band = 7;
                  else if (accuracy >= 0.65) band = 6.5;
                  else if (accuracy >= 0.57) band = 6;
                  else if (accuracy >= 0.45) band = 5.5;
                  else if (accuracy >= 0.37) band = 5;
                  else if (accuracy >= 0.32) band = 4.5;
                  else if (accuracy >= 0.25) band = 4;
                  else band = 3.5;
                  return band;
                })() }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-block bg-white dark:bg-black px-6 py-2 rounded-full text-sm font-bold shadow-sm border border-white/10", children: [
                  "Raw Score: ",
                  finalScore,
                  " Correct"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-4 text-slate-500 text-sm", children: [
                  "Based on ",
                  Object.keys(testData).length,
                  " passage(s) completed."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-8", children: Object.entries(testData).map(([part, data]) => {
                const testPart = data;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-slate-200 dark:border-white/10 pt-8 first:border-0 first:pt-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-xl mb-4 text-slate-800 dark:text-white", children: [
                    "Passage ",
                    part,
                    ": ",
                    testPart.title
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: testPart.questions.map((q, i) => {
                    const userAns = normalizeAnswer(answers[q.id] || "");
                    const correctAns = normalizeAnswer(q.correctAnswer);
                    const isCorrect = userAns === correctAns;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 rounded-xl border ${isCorrect ? "border-green-500/30 bg-green-500/10" : "border-red-500/30 bg-red-500/10"}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-slate-700 dark:text-slate-200", children: [
                          "Q",
                          i + 1,
                          ". ",
                          q.text
                        ] }),
                        isCorrect ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16, className: "text-green-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { size: 16, className: "text-red-500" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm grid grid-cols-2 gap-4", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Your Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: isCorrect ? "text-green-600 dark:text-green-400" : "text-red-600 dark:text-red-400", children: answers[q.id] || "(No Answer)" })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 uppercase block", children: "Correct Answer" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-800 dark:text-white font-medium", children: q.correctAnswer })
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-xs text-slate-500 italic border-t border-black/5 dark:border-white/5 pt-2", children: q.explanation })
                    ] }, q.id);
                  }) })
                ] }, part);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => {
                setSubmitted(false);
                setAnswers({});
                setTestData({});
                setCurrentPassage(1);
                setFinalScore(0);
                setTimeLeft(60 * 60);
                setReadingTest(null);
                loadPassage(1);
              }, className: "w-full py-4 text-emerald-500 font-bold hover:bg-emerald-500/10 rounded-xl transition-colors border border-transparent hover:border-emerald-500/30", children: "Start New Reading Test" })
            ] })
          ) }) : null
        ] })
      ] });
    };
    const VeoVisuals = () => {
      const [image, setImage] = reactExports.useState(null);
      const [videoUrl, setVideoUrl] = reactExports.useState(null);
      const [loading, setLoading] = reactExports.useState(false);
      const [prompt, setPrompt] = reactExports.useState("A cinematic slow pan of this environment with ambient movement");
      const handleImageUpload = (e) => {
        var _a;
        const file = (_a = e.target.files) == null ? void 0 : _a[0];
        if (file) {
          const reader = new FileReader();
          reader.onloadend = () => {
            setImage(reader.result);
          };
          reader.readAsDataURL(file);
        }
      };
      const handleGenerate = () => __async(null, null, function* () {
        if (!image) return;
        setLoading(true);
        try {
          const base64Data = image.split(",")[1];
          const url = yield generateVisualScenario(base64Data, prompt);
          setVideoUrl(url);
        } catch (error) {
          console.error(error);
          alert("Video generation failed. Ensure you have access to Veo.");
        } finally {
          setLoading(false);
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-3xl mx-auto bg-white dark:bg-slate-900 rounded-3xl shadow-lg border border-slate-200 dark:border-slate-800 overflow-hidden animate-in fade-in slide-in-from-bottom-8 duration-500", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 border-b border-slate-100 dark:border-slate-800 bg-gradient-to-r from-pink-50 to-white dark:from-slate-900 dark:to-slate-900", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 bg-pink-100 dark:bg-pink-900/50 rounded-xl text-pink-600 dark:text-pink-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Video, { size: 24 }) }),
            "Visual Vocabulary Builder"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-500 dark:text-slate-400 mt-2 max-w-xl", children: "Upload a static image of a place or object. Veo will animate it into a 720p video scenario to help you practice describing moving scenes in Speaking Part 2." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 space-y-8", children: [
          !image ? /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "group block w-full h-64 border-2 border-dashed border-slate-300 dark:border-slate-700 rounded-3xl hover:bg-slate-50 dark:hover:bg-slate-800/50 hover:border-pink-400 dark:hover:border-pink-500 transition-all cursor-pointer flex flex-col items-center justify-center text-slate-400 dark:text-slate-500", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 rounded-full bg-slate-100 dark:bg-slate-800 flex items-center justify-center mb-4 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "text-slate-400 dark:text-slate-500 group-hover:text-pink-500", size: 24 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Click to upload reference image" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", accept: "image/*", className: "hidden", onChange: handleImageUpload })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative rounded-2xl overflow-hidden bg-black h-80 flex items-center justify-center group border border-slate-200 dark:border-slate-700 shadow-md", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image, alt: "Source", className: "h-full w-full object-cover opacity-80 group-hover:opacity-100 transition-opacity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setImage(null),
                className: "absolute top-4 right-4 bg-black/60 text-white p-2 rounded-full hover:bg-black/80 backdrop-blur-md transition-colors",
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded-lg text-xs font-bold backdrop-blur-md", children: "Reference Image" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wide", children: "Prompt" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 16, className: "absolute left-4 top-1/2 -translate-y-1/2 text-pink-400" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: prompt,
                  onChange: (e) => setPrompt(e.target.value),
                  className: "w-full pl-10 p-4 border border-slate-300 dark:border-slate-700 bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-white rounded-xl text-sm focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all",
                  placeholder: "Describe how you want the video to look..."
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleGenerate,
              disabled: !image || loading,
              className: "w-full bg-pink-600 hover:bg-pink-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 shadow-lg shadow-pink-500/30 transition-all hover:scale-[1.02]",
              children: [
                loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Video, { size: 20 }),
                loading ? "Generating with Veo 3.1..." : "Generate Video Scenario"
              ]
            }
          ),
          videoUrl && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8 animate-in fade-in slide-in-from-bottom-8", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-slate-800 dark:text-white", children: "Generated Scenario" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold bg-pink-100 dark:bg-pink-900/50 text-pink-700 dark:text-pink-300 px-2 py-1 rounded", children: "Veo 3.1" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "video",
              {
                src: videoUrl,
                controls: true,
                className: "w-full rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-800",
                autoPlay: true,
                loop: true
              }
            )
          ] })
        ] })
      ] });
    };
    const DiagnosticTest = ({ onComplete }) => {
      const [test, setTest] = reactExports.useState(null);
      const [answers, setAnswers] = reactExports.useState({});
      const [step, setStep] = reactExports.useState(0);
      reactExports.useEffect(() => {
        const load = () => __async(null, null, function* () {
          const data = yield generateDiagnostic();
          setTest(data);
        });
        load();
      }, []);
      if (!test) return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center justify-center h-96 space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "animate-spin text-blue-600", size: 40 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-slate-700 dark:text-slate-200", children: "Preparing your diagnostic assessment..." })
      ] });
      const sections = ["listening", "reading", "grammar"];
      const currentSection = sections[step - 1];
      const currentQuestions = step > 0 && step <= 3 ? test[currentSection].questions : [];
      const handleNext = () => {
        if (step < 3) setStep(step + 1);
        else {
          let scores = { listening: 0, reading: 0, grammar: 0 };
          ["listening", "reading", "grammar"].forEach((sec) => {
            test[sec].questions.forEach((q) => {
              if (answers[q.id] === q.correctAnswer) scores[sec]++;
            });
          });
          onComplete(scores);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-2xl mx-auto bg-white dark:bg-slate-900 p-4 md:p-8 rounded-3xl shadow-xl border border-slate-200 dark:border-slate-800 mt-4 md:mt-8", children: step === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 bg-slate-900 dark:bg-white rounded-2xl flex items-center justify-center mx-auto text-white dark:text-black shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { size: 32 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-slate-800 dark:text-white", children: "IELTS Diagnostic Test" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-slate-600 dark:text-slate-300", children: "Take this quick 5-minute assessment to determine your current estimated band level and get a personalized study plan." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setStep(1), className: "w-full bg-slate-900 hover:bg-black dark:bg-white dark:hover:bg-slate-200 text-white dark:text-black py-4 rounded-xl font-bold text-lg shadow-lg transition-all", children: "Start Assessment" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold uppercase tracking-wider text-slate-500 dark:text-slate-400", children: currentSection }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-bold bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded", children: [
            "Step ",
            step,
            " of 3"
          ] })
        ] }),
        test[currentSection].script && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl text-sm italic text-slate-600 dark:text-slate-400 border-l-4 border-slate-900 dark:border-white", children: [
          '" ',
          test[currentSection].script,
          ' "'
        ] }),
        test[currentSection].passage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl text-sm text-slate-700 dark:text-slate-300 max-h-40 overflow-y-auto border border-slate-200 dark:border-slate-700", children: test[currentSection].passage }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: currentQuestions.map((q, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl border border-slate-100 dark:border-slate-800", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium mb-3 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold mr-2", children: [
              i + 1,
              "."
            ] }),
            q.text
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 gap-2", children: q.options.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `flex items-center gap-3 p-2.5 rounded-lg cursor-pointer text-sm transition-colors ${answers[q.id] === opt ? "bg-slate-100 dark:bg-white/10 border border-slate-300 dark:border-white/30" : "hover:bg-slate-50 dark:hover:bg-slate-800"}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "radio",
                name: q.id,
                value: opt,
                checked: answers[q.id] === opt,
                onChange: () => setAnswers(__spreadProps(__spreadValues({}, answers), { [q.id]: opt })),
                className: "text-slate-900 dark:text-white accent-black dark:accent-white"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-700 dark:text-slate-300", children: opt })
          ] }, opt)) })
        ] }, q.id)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleNext, className: "w-full bg-slate-900 hover:bg-black dark:bg-white dark:hover:bg-slate-200 text-white dark:text-black py-3 rounded-xl font-bold flex items-center justify-center gap-2", children: [
          step === 3 ? "Finish" : "Next Section",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, { size: 16 })
        ] })
      ] }) });
    };
    const ScrollToTop = () => {
      const { pathname } = useLocation();
      reactExports.useEffect(() => {
        window.scrollTo(0, 0);
      }, [pathname]);
      return null;
    };
    const ThemeContext = reactExports.createContext({
      isDark: false,
      toggleTheme: () => {
      }
    });
    const XPContext = reactExports.createContext({
      xp: 0,
      addXP: () => {
      },
      level: 1
    });
    const useXP = () => reactExports.useContext(XPContext);
    const ScoreContext = reactExports.createContext({
      scores: null,
      updateScore: () => {
      }
    });
    const useScore = () => reactExports.useContext(ScoreContext);
    const NavItem = ({ to, icon: Icon2, label }) => {
      const location = useLocation();
      const active = location.pathname === to;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Link,
        {
          to,
          className: `flex flex-col items-center gap-1 p-2 rounded-xl transition-all ${active ? "text-cyan-400 bg-white/10" : "text-slate-400 hover:text-slate-200"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, strokeWidth: active ? 2.5 : 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] font-medium uppercase tracking-wide", children: label })
          ]
        }
      );
    };
    const SidebarItem = ({ to, icon: Icon2, label }) => {
      const location = useLocation();
      const active = location.pathname === to;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Link,
        {
          to,
          className: `flex items-center gap-3 px-4 py-3 rounded-xl transition-all font-medium ${active ? "bg-white/10 text-cyan-400 border-r-2 border-cyan-400" : "text-slate-400 hover:bg-white/5 hover:text-white"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 20, strokeWidth: active ? 2.5 : 2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label })
          ]
        }
      );
    };
    const Dashboard = ({ scores }) => {
      const { xp, level } = useXP();
      const [listeningDone, setListeningDone] = reactExports.useState(false);
      const [writingDone, setWritingDone] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const uid = localStorage.getItem("ielts_uid");
        if (!uid) return;
        const lHistory = localStorage.getItem(`ielts_listening_history_${uid}`) || localStorage.getItem("ielts_listening_history");
        if (lHistory && JSON.parse(lHistory).length > 0) setListeningDone(true);
        const wHistory = localStorage.getItem(`ielts_writing_history_${uid}`) || localStorage.getItem("ielts_writing_history");
        if (wHistory && JSON.parse(wHistory).length > 0) setWritingDone(true);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 md:space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-700", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "relative overflow-hidden bg-gradient-to-br from-neutral-900 via-neutral-900 to-black p-6 md:p-8 rounded-3xl text-white shadow-2xl border border-white/10 group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 right-0 -mt-10 -mr-10 w-64 h-64 bg-cyan-500/10 rounded-full blur-3xl group-hover:bg-cyan-500/20 transition-all duration-1000" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start mb-2 md:mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl md:text-4xl font-black mb-2 tracking-tight", children: "NEURAL DASHBOARD" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-cyan-200/80 font-mono text-xs md:text-sm", children: "SYSTEM ONLINE // READY FOR TRAINING" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[10px] md:text-xs font-bold text-cyan-300 uppercase tracking-widest mb-1", children: [
                  "Level ",
                  level
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xl md:text-3xl font-black text-white", children: [
                  xp,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs md:text-sm text-cyan-400", children: "XP" })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-4 mt-6 md:mt-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/5 backdrop-blur-md px-4 py-3 md:px-6 md:py-4 rounded-2xl border border-white/10 hover:bg-white/10 transition-all", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[10px] text-cyan-300 uppercase font-bold block tracking-wider mb-1", children: "Projected Band" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl md:text-4xl font-black bg-clip-text text-transparent bg-gradient-to-r from-white to-cyan-200", children: scores ? (() => {
                const sections = ["listening", "reading", "writing", "speaking"];
                let total = 0;
                let count = 0;
                sections.forEach((section) => {
                  if (scores[section]) {
                    total += scores[section];
                    count++;
                  }
                });
                if (count === 0 && scores.grammar) {
                  return ((scores.listening + scores.reading + scores.grammar) / 3 + 4).toFixed(1);
                }
                return count > 0 ? (total / count).toFixed(1) : "N/A";
              })() : "N/A" })
            ] }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/listening", icon: Volume2, title: "Listening", color: "cyan", desc: "Neural Audio Analysis" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/reading", icon: BookOpen, title: "Reading", color: "emerald", desc: "Semantic Processing" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/writing", icon: PenTool, title: "Writing", color: "violet", desc: "Generative Grading" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModuleCard, { to: "/speaking", icon: Mic, title: "Speaking", color: "rose", desc: "Live Conversational AI" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white dark:bg-black p-5 md:p-8 rounded-3xl border border-slate-200 dark:border-white/10 shadow-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-slate-800 dark:text-white mb-4 md:mb-6 flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { className: "text-cyan-500" }),
            "Neural Optimization Plan"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/listening", className: `flex items-center gap-4 p-4 rounded-2xl border transition-all ${listeningDone ? "bg-green-500/10 border-green-500/20 cursor-default" : "bg-slate-50 dark:bg-white/5 border-slate-100 dark:border-white/5 hover:scale-[1.01] cursor-pointer"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-10 h-10 rounded-full flex items-center justify-center ${listeningDone ? "bg-green-500 text-white" : "bg-cyan-500/10 text-cyan-600 dark:text-cyan-400"}`, children: listeningDone ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Volume2, { size: 20 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: `font-bold ${listeningDone ? "text-green-600 dark:text-green-400" : "text-slate-800 dark:text-white"}`, children: listeningDone ? "Listening Simulation Complete" : "Listening: Part 3 Simulation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: listeningDone ? "Neural pathway optimized." : "Improve multi-speaker tracking (+150 XP)" })
              ] }),
              !listeningDone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-cyan-500 animate-pulse" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: "/writing", className: `flex items-center gap-4 p-4 rounded-2xl border transition-all ${writingDone ? "bg-green-500/10 border-green-500/20 cursor-default" : "bg-slate-50 dark:bg-white/5 border-slate-100 dark:border-white/5 hover:scale-[1.01] cursor-pointer"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-10 h-10 rounded-full flex items-center justify-center ${writingDone ? "bg-green-500 text-white" : "bg-violet-500/10 text-violet-600 dark:text-violet-400"}`, children: writingDone ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheck, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PenTool, { size: 20 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: `font-bold ${writingDone ? "text-green-600 dark:text-green-400" : "text-slate-800 dark:text-white"}`, children: writingDone ? "Writing Task Complete" : "Writing: Task 2 Outline" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: writingDone ? "Structure logic reinforced." : "Structure your argument logic (+200 XP)" })
              ] }),
              !writingDone && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-violet-500 animate-pulse" })
            ] })
          ] })
        ] })
      ] });
    };
    const ModuleCard = ({ to, icon: Icon2, title, color, desc }) => {
      const colors = {
        cyan: "from-cyan-500 to-blue-500",
        emerald: "from-emerald-500 to-green-500",
        violet: "from-violet-500 to-purple-500",
        rose: "from-rose-500 to-pink-500"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to, className: "relative group bg-white dark:bg-black p-6 rounded-2xl shadow-sm border border-slate-200 dark:border-white/10 hover:-translate-y-1 transition-all overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0 left-0 w-1 h-full bg-gradient-to-b ${colors[color]}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 inline-flex p-3 rounded-xl bg-slate-50 dark:bg-white/5 group-hover:scale-110 transition-transform", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: 24, className: `text-${color}-500` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-black text-slate-800 dark:text-white text-xl mb-1", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-medium text-slate-400 dark:text-slate-500 uppercase tracking-wide", children: desc }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 right-0 p-2 opacity-0 group-hover:opacity-100 transition-opacity", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { className: `w-24 h-24 text-${color}-500/5 -rotate-12` }) })
      ] });
    };
    const TestContext = reactExports.createContext({
      listeningTest: null,
      setListeningTest: () => {
      },
      readingTest: null,
      setReadingTest: () => {
      },
      writingTest: null,
      setWritingTest: () => {
      }
    });
    const useTest = () => reactExports.useContext(TestContext);
    const App = () => {
      const [isDark, setIsDark] = reactExports.useState(true);
      const [user, setUser] = reactExports.useState(null);
      const [onboarded, setOnboarded] = reactExports.useState(false);
      const [scores, setScores] = reactExports.useState(null);
      const [hasKey, setHasKey] = reactExports.useState(false);
      const [xp, setXp] = reactExports.useState(0);
      const [level, setLevel] = reactExports.useState(1);
      const [listeningTest, setListeningTest] = reactExports.useState(null);
      const [readingTest, setReadingTest] = reactExports.useState(null);
      const [writingTest, setWritingTest] = reactExports.useState(null);
      const [apiKeyInput, setApiKeyInput] = reactExports.useState("");
      reactExports.useEffect(() => {
        const checkAuth = () => {
          const uid = localStorage.getItem("ielts_uid");
          const email = localStorage.getItem("ielts_email");
          const isGuest = localStorage.getItem("ielts_guest") === "true";
          if (uid) {
            setUser({ uid, email, isGuest });
            const savedScores = localStorage.getItem(`ielts_scores_${uid}`) || localStorage.getItem("ielts_scores");
            setScores(savedScores ? JSON.parse(savedScores) : null);
            const savedOnboarded = localStorage.getItem(`ielts_ace_onboarded_${uid}`) === "true";
            setOnboarded(savedOnboarded);
            const storedKey = localStorage.getItem(`gemini_api_key_${uid}`);
            if (storedKey) {
              setGeminiApiKey(storedKey);
              setHasKey(true);
            } else {
              setHasKey(false);
              setGeminiApiKey("");
            }
          } else {
            setUser(null);
            setScores(null);
            setOnboarded(false);
            setHasKey(false);
            setGeminiApiKey("");
          }
        };
        checkAuth();
        const handleAuthChange = () => checkAuth();
        window.addEventListener("auth-change", handleAuthChange);
        return () => window.removeEventListener("auth-change", handleAuthChange);
      }, []);
      const addXP = (amount) => {
        const newXp = xp + amount;
        setXp(newXp);
        if (newXp >= level * 100) {
          setLevel((l) => l + 1);
        }
      };
      reactExports.useEffect(() => {
        if (isDark) document.documentElement.classList.add("dark");
        else document.documentElement.classList.remove("dark");
      }, [isDark]);
      const handleKeySubmit = (e) => {
        e.preventDefault();
        if (apiKeyInput.trim().length > 10 && user) {
          const key = apiKeyInput.trim();
          setGeminiApiKey(key);
          localStorage.setItem(`gemini_api_key_${user.uid}`, key);
          setHasKey(true);
        }
      };
      const clearKey = () => {
        if (user) {
          localStorage.removeItem(`gemini_api_key_${user.uid}`);
          setHasKey(false);
          setGeminiApiKey("");
        }
      };
      const toggleTheme = () => setIsDark(!isDark);
      const handleDiagnosticComplete = (results) => {
        if (!user) return;
        setScores(results);
        localStorage.setItem(`ielts_scores_${user.uid}`, JSON.stringify(results));
        addXP(500);
        setOnboarded(true);
        localStorage.setItem(`ielts_ace_onboarded_${user.uid}`, "true");
      };
      const updateScore = (section, score) => {
        if (!user) return;
        const newScores = __spreadProps(__spreadValues({}, scores), { [section]: score });
        setScores(newScores);
        localStorage.setItem(`ielts_scores_${user.uid}`, JSON.stringify(newScores));
      };
      if (!user) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen w-full flex items-center justify-center bg-[#050505] text-white relative overflow-hidden font-sans selection:bg-cyan-500/30", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-0 left-0 w-full h-full overflow-hidden z-0 pointer-events-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[-10%] left-[-10%] w-[40%] h-[40%] bg-purple-600/20 rounded-full blur-[120px] animate-blob mix-blend-screen" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[20%] right-[-10%] w-[35%] h-[35%] bg-cyan-500/20 rounded-full blur-[120px] animate-blob animation-delay-2000 mix-blend-screen" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[-10%] left-[20%] w-[45%] h-[45%] bg-blue-600/20 rounded-full blur-[120px] animate-blob animation-delay-4000 mix-blend-screen" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 brightness-100 contrast-150" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 w-full max-w-5xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-12 p-6 items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8 text-center lg:text-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-3 py-1 rounded-full bg-white/5 border border-white/10 backdrop-blur-md text-xs font-medium text-cyan-300 tracking-wide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative flex h-2 w-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-cyan-400 opacity-75" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "relative inline-flex rounded-full h-2 w-2 bg-cyan-500" })
                ] }),
                "AI-POWERED PREPARATION"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-32 h-32 mx-auto lg:mx-0 relative", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-cyan-500/30 blur-3xl rounded-full" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: logo,
                      alt: "IELTS ACE Logo",
                      className: "w-full h-full object-contain relative z-10 mix-blend-screen drop-shadow-[0_0_15px_rgba(6,182,212,0.5)]"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "text-5xl md:text-7xl font-black tracking-tighter leading-[0.9]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-clip-text text-transparent bg-gradient-to-b from-white to-slate-400", children: "IELTS" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600", children: "ACE" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-lg text-slate-400 max-w-md mx-auto lg:mx-0 leading-relaxed", children: [
                  "The world's most advanced ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white font-semibold", children: "Neural Preparation System" }),
                  ". Real-time feedback, generative grading, and adaptive learning paths."
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden lg:flex gap-6 text-sm font-medium text-slate-500", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1.5 rounded-lg bg-white/5 text-cyan-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 16 }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Instant Analysis" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1.5 rounded-lg bg-white/5 text-purple-400", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { size: 16 }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Band 9.0 Logic" })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -inset-1 bg-gradient-to-r from-cyan-500 to-purple-600 rounded-3xl blur opacity-20 group-hover:opacity-40 transition duration-1000" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative bg-black/40 backdrop-blur-xl border border-white/10 p-8 md:p-10 rounded-3xl shadow-2xl", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-6", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-2 mb-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-white", children: "Get Started" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-slate-400", children: "Join the elite preparation network" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: () => window.loginWithGoogle(),
                      className: "group/btn relative w-full py-4 bg-white text-black rounded-xl font-bold text-lg overflow-hidden transition-all hover:scale-[1.02] hover:shadow-xl hover:shadow-cyan-500/20",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-slate-100 to-white opacity-100 group-hover/btn:opacity-90 transition-opacity" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative flex items-center justify-center gap-3", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-5 h-5", viewBox: "0 0 24 24", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z", fill: "#4285F4" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z", fill: "#34A853" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.84 14.11c-.22-.66-.35-1.36-.35-2.11s.13-1.45.35-2.11V7.05H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.95l3.66-2.84z", fill: "#FBBC05" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.05l3.66 2.84c.87-2.6 3.3-4.51 6.16-4.51z", fill: "#EA4335" })
                          ] }),
                          "Continue with Google"
                        ] })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex items-center gap-4 py-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-white/10 flex-1" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-slate-500 font-medium uppercase tracking-wider", children: "or" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-px bg-white/10 flex-1" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: () => window.startAsGuest(),
                      className: "w-full py-4 bg-white/5 border border-white/10 text-slate-300 rounded-xl font-bold text-sm hover:bg-white/10 hover:text-white hover:border-white/20 transition-all flex items-center justify-center gap-2 group/guest",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Continue as Guest" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "group-hover/guest:translate-x-1 transition-transform", children: "" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 pt-6 border-t border-white/5 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-slate-500", children: [
                  "By continuing, you agree to our ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 hover:text-white cursor-pointer transition-colors", children: "Terms" }),
                  " and ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-slate-400 hover:text-white cursor-pointer transition-colors", children: "Privacy Policy" }),
                  "."
                ] }) })
              ] })
            ] })
          ] })
        ] });
      }
      if (!hasKey) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `min-h-screen w-full flex flex-col items-center justify-center bg-black text-white relative overflow-hidden font-sans ${isDark ? "dark" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "z-10 text-center space-y-8 p-8 max-w-md w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center gap-2 text-sm text-slate-400 mb-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 16 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Logged in as ",
                user.isGuest ? "Guest" : user.email
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/5 border border-white/10 rounded-2xl p-6 text-left space-y-4 backdrop-blur-sm", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-white font-bold flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 16, className: "text-cyan-400" }),
                "Initialize System"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "text-sm text-slate-400 space-y-2 list-decimal list-inside", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                  "Go to ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://aistudio.google.com/app/api-keys", target: "_blank", rel: "noopener noreferrer", className: "text-cyan-400 hover:underline hover:text-cyan-300 transition-colors", children: "Google AI Studio" }),
                  "."
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: `Click "Create API key" (it's free).` }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Copy the key and paste it below." })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleKeySubmit, className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -inset-0.5 bg-gradient-to-r from-cyan-500 to-blue-500 rounded-xl blur opacity-30 group-hover:opacity-75 transition duration-1000 group-hover:duration-200" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "password",
                    value: apiKeyInput,
                    onChange: (e) => setApiKeyInput(e.target.value),
                    placeholder: "Enter your Gemini API Key",
                    className: "relative w-full bg-black border border-white/10 rounded-xl px-6 py-4 text-white placeholder:text-slate-600 focus:outline-none focus:ring-2 focus:ring-cyan-500/50 font-mono text-center"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  type: "submit",
                  disabled: !apiKeyInput,
                  className: "group relative w-full py-4 bg-white text-black rounded-xl font-bold text-lg overflow-hidden transition-all hover:scale-[1.02] hover:shadow-xl hover:shadow-white/10 disabled:opacity-50 disabled:hover:scale-100",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 opacity-0 group-hover:opacity-10 transition-opacity" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex items-center justify-center gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 20 }),
                      " INITIALIZE SYSTEM"
                    ] })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.logoutUser(), className: "text-xs text-slate-500 hover:text-white flex items-center justify-center gap-2 mx-auto mt-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 14 }),
              " Not you? Log out"
            ] })
          ] })
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value: { isDark, toggleTheme }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(XPContext.Provider, { value: { xp, addXP, level }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScoreContext.Provider, { value: { scores, updateScore }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TestContext.Provider, { value: { listeningTest, setListeningTest, readingTest, setReadingTest, writingTest, setWritingTest }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HashRouter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollToTop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-slate-50 dark:bg-black text-slate-900 dark:text-slate-100 transition-colors duration-300 pb-20 md:pb-0 font-sans selection:bg-cyan-500/30 overflow-x-hidden", children: !onboarded ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 max-w-4xl mx-auto min-h-screen flex flex-col justify-start pt-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: toggleTheme, className: "p-2 rounded-full bg-slate-200 dark:bg-white/10 hover:bg-slate-300 dark:hover:bg-white/20 transition-colors", children: isDark ? /* @__PURE__ */ jsxRuntimeExports.jsx(Sun, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Moon, { size: 20 }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DiagnosticTest, { onComplete: handleDiagnosticComplete })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: "hidden md:fixed md:inset-y-0 md:left-0 md:flex md:w-64 md:flex-col bg-white dark:bg-black border-r border-slate-200 dark:border-white/10 z-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-8 flex items-center gap-3 font-black text-2xl tracking-tighter text-slate-800 dark:text-white", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 bg-cyan-500 rounded-lg flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 18, className: "text-white", fill: "currentColor" }) }),
              "ACE"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "flex-1 px-4 space-y-2 mt-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/", icon: LayoutDashboard, label: "Command Center" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/listening", icon: Volume2, label: "Listening" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/reading", icon: BookOpen, label: "Reading" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/writing", icon: PenTool, label: "Writing" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/speaking", icon: Mic, label: "Speaking" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarItem, { to: "/veo", icon: Video, label: "Visuals" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 border-t border-slate-100 dark:border-white/10 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mb-4 px-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Trophy, { size: 16, className: "text-yellow-500" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs font-bold uppercase text-slate-500 dark:text-slate-400", children: [
                  "XP Level ",
                  level
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-1.5 bg-slate-100 dark:bg-white/10 rounded-full overflow-hidden mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full bg-gradient-to-r from-cyan-400 to-blue-500", style: { width: `${xp % 1e3 / 10}%` } }) }),
              user.isGuest && /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.upgradeToGoogle(), className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-white bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-400 hover:to-blue-400 py-2 rounded-lg transition-all shadow-lg shadow-cyan-500/20 mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(CircleArrowUp, { size: 14 }),
                " Upgrade Account"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: toggleTheme, className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-cyan-600 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                isDark ? /* @__PURE__ */ jsxRuntimeExports.jsx(Sun, { size: 14 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Moon, { size: 14 }),
                " Toggle Mode"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: clearKey, className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-red-500 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { size: 14 }),
                " Change API Key"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => window.logoutUser(), className: "w-full flex items-center justify-center gap-2 text-xs font-bold text-slate-500 hover:text-red-500 py-2 rounded-lg hover:bg-slate-50 dark:hover:bg-white/5 transition-all", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 14 }),
                " Log Out"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "md:pl-64 p-3 md:p-8 max-w-7xl mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, { scores }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/listening", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Listening, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/reading", element: /* @__PURE__ */ jsxRuntimeExports.jsx(IELTSReading, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/writing", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WritingSection, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/speaking", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LiveSpeaking, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/veo", element: /* @__PURE__ */ jsxRuntimeExports.jsx(VeoVisuals, {}) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "md:hidden fixed bottom-0 left-0 right-0 bg-white/90 dark:bg-black/90 backdrop-blur-xl border-t border-slate-200 dark:border-white/10 pb-1 pt-3 px-2 flex justify-around z-50 shadow-2xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/listening", icon: Volume2, label: "Listen" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/reading", icon: BookOpen, label: "Read" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/", icon: LayoutDashboard, label: "Hub" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/writing", icon: PenTool, label: "Write" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NavItem, { to: "/speaking", icon: Mic, label: "Speaking" })
          ] })
        ] }) })
      ] }) }) }) }) });
    };
    const mount = () => {
      const rootElement = document.getElementById("root");
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
      );
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", mount);
    } else {
      mount();
    }
    const firebaseConfig = {
      apiKey: "AIzaSyDInQWPq-TdSJGSUdRPV5A98dhYGSHtIOY",
      authDomain: "ielts-prac.firebaseapp.com",
      projectId: "ielts-prac",
      storageBucket: "ielts-prac.firebasestorage.app",
      messagingSenderId: "907025192758",
      appId: "1:907025192758:web:9751827c2e4fdd61600597",
      measurementId: "G-L1CGX452RB"
    };
    const app$1 = initializeApp(firebaseConfig);
    getAnalytics(app$1);
    const app = getApp();
    const auth = getAuth(app);
    const googleProvider = new GoogleAuthProvider();
    window.loginWithGoogle = function() {
      return __async(this, null, function* () {
        try {
          const result = yield signInWithPopup(auth, googleProvider);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_email", user.email || "");
          localStorage.removeItem("ielts_guest");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Google sign in failed: " + err.message);
        }
      });
    };
    window.startAsGuest = function() {
      return __async(this, null, function* () {
        try {
          const result = yield signInAnonymously(auth);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_guest", "true");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Guest login failed: " + err.message);
        }
      });
    };
    window.upgradeToGoogle = function() {
      return __async(this, null, function* () {
        try {
          const result = yield linkWithPopup(auth.currentUser, googleProvider);
          const user = result.user;
          localStorage.setItem("ielts_uid", user.uid);
          localStorage.setItem("ielts_email", user.email);
          localStorage.removeItem("ielts_guest");
          window.dispatchEvent(new Event("auth-change"));
        } catch (err) {
          console.error(err);
          alert("Account upgrade failed: " + err.message);
        }
      });
    };
    window.logoutUser = function() {
      return __async(this, null, function* () {
        yield signOut(auth);
        localStorage.removeItem("ielts_uid");
        localStorage.removeItem("ielts_email");
        localStorage.removeItem("ielts_guest");
        window.dispatchEvent(new Event("auth-change"));
      });
    };
    onAuthStateChanged(auth, (user) => {
      if (user) {
        localStorage.setItem("ielts_uid", user.uid);
      } else {
        localStorage.removeItem("ielts_uid");
      }
      window.dispatchEvent(new Event("auth-change"));
    });
  }
});
export default require_index_001();</script>
</head>

<body
  class="bg-slate-50 text-slate-900 dark:bg-black dark:text-slate-100 transition-colors duration-300 overflow-x-hidden">
  <div id="root">
    <div
      style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #888; font-family: sans-serif;">
      Loading Application...
    </div>
  </div>

  <!-- Firebase App & Analytics -->

  <!-- Firebase Auth -->
</body>

</html>
